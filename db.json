{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/test2.jpeg","path":"uploads/test2.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/bg.jpg","path":"images/bg.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/images/bg2.jpg","path":"images/bg2.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"1415d5dc97bcc7d473c7924dd6679239c0f5ead8","modified":1549077773073},{"_id":"source/robots.txt","hash":"361c70ce4234cd458c8148d1ce319c864d40750c","modified":1549077773093},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1549077773277},{"_id":"themes/next/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1549077773277},{"_id":"themes/next/README.cn.md","hash":"87950c415dd162ff78e98b41f1148b85462103e2","modified":1549077773277},{"_id":"themes/next/README.md","hash":"3835ddd15c7f9a575ce56af54c5c33cf45087fc5","modified":1549077773277},{"_id":"themes/next/_config.yml","hash":"9bc837c0fa354e32790289f26eeb50e44f94b5ba","modified":1549077773277},{"_id":"themes/next/bower.json","hash":"f124431f2ff1225322863d6e6f73de980a85fd7a","modified":1549077773277},{"_id":"themes/next/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1549077773287},{"_id":"themes/next/package.json","hash":"93526ad6d3c5145ea32a1cda8dfd19f79b773aa5","modified":1549077773347},{"_id":"source/_posts/2018-01-19-test-source.md","hash":"4c2fb92cb6ab0b20113a643c7a8922d86d830a46","modified":1549077773073},{"_id":"source/_posts/2018-01-23-CFNetwork的介绍和使用.md","hash":"10ff696165c99ed2efefd897e51517b51ab07f4c","modified":1549077773073},{"_id":"source/_posts/2018-01-23-IOS下三种DNS解析方式分析（LocalDns）.md","hash":"7763380e8cb03a64f89ca469fd7ebc3f3a01f32e","modified":1549077773083},{"_id":"source/_posts/2018-01-23-关于物理效果的动画引擎UIDynamic介绍.md","hash":"47aead699adfea587a9b101ab442e9c4591e08e8","modified":1549077773083},{"_id":"source/_posts/2018-01-23-在iOS11下app图标变空白的问题解决.md","hash":"450a54e5ddb7854af147d616b7ef9cb733f8282b","modified":1549077773083},{"_id":"source/_posts/2018-01-23-iOS中使用OpenGL实现增高功能.md","hash":"4c7adc60649ca9570a06c1d1545615b41fec6351","modified":1549077773083},{"_id":"source/_posts/2018-01-23-关于视图在切圆角时候的导致的性能下降的一些探讨.md","hash":"1ac9548b4669c3bd4d0017f8c71a019d17ed254e","modified":1549077773083},{"_id":"source/_posts/2018-01-23-深入理解Http请求、DNS劫持与解析.md","hash":"e000fed3405d81022ac0b973833057056504164c","modified":1549077773083},{"_id":"source/_posts/2018-01-24-NSURLProtocol对WKWebView的处理.md","hash":"7ce55de7e483711c51c50952eb5922679adbd2a0","modified":1549077773083},{"_id":"source/_posts/2018-01-24-iOS-Runtime简单介绍，以及不同类的Method-Swizzling.md","hash":"29ce85e51f34b6726d62eaf277bd4e57825f0bc7","modified":1549077773083},{"_id":"source/_posts/2018-01-24-iOS端自动内存泄漏检测工具.md","hash":"66a46bb828453740ccba15e901c2e2b8e0403fc1","modified":1549077773083},{"_id":"source/_posts/2018-01-24-可能是最全的iOS端HttpDns集成方案.md","hash":"2f043d89766c01485ed8e6d03abbc4f7f29b5800","modified":1549077773083},{"_id":"source/_posts/2018-01-24-在iOS工程中Cocoapods的使用.md","hash":"cb753a38eb5b354bfc331222c86f3c3466fdd348","modified":1549077773083},{"_id":"source/_posts/2018-01-24-自定义AlertView.md","hash":"078f883fd35c74fd6cbb1be7ae7ecfe069147d8d","modified":1549077773083},{"_id":"source/_posts/2018-01-24-记一次Runtime-Hook的问题.md","hash":"f712d3253d773e510ef10c3a34a705b6b59f28c9","modified":1549077773083},{"_id":"source/_posts/2018-01-24-转-如何掌握所有的程序语言.md","hash":"e4dea77fc0c791ba7504fa09c953de85d4d65478","modified":1549077773083},{"_id":"source/_posts/2018-01-25-可能是最全的使用HEXO搭建个人博客教程.md","hash":"ddc6b6d384a77cd6d71ddc61e819ac533c5a4a57","modified":1549077773083},{"_id":"source/_posts/2018-02-08-关于iPhone-X下Home键的隐藏和延迟响应.md","hash":"bf43a998747464d9b64cb0d8b445fc16791c2822","modified":1549077773083},{"_id":"source/_posts/2018-02-11-关于博客评论插件的问题.md","hash":"10a680daa86ead61819be2c6a436733609ccf7b2","modified":1549077773093},{"_id":"source/_posts/2018-02-12-At-The-End-Of-2017.md","hash":"a677b47c01ccb6ca84c9e7c367f6c8482985e10f","modified":1549077773093},{"_id":"source/_posts/2018-03-14-Simple-HotFix-Mtehod.md","hash":"065f0232bf05bbdc2bbc01abc4ac1cec7ffbb6bf","modified":1549077773093},{"_id":"source/_posts/2018-03-30-AlamoFire.md","hash":"14bb60be50eb804e8c8d9ba1427340c251cbe21b","modified":1549077773093},{"_id":"source/_posts/2018-05-08-RX-Swift-Study-One.md","hash":"7cffa3888e31fb5f6f5a601b282379b0656cbfd9","modified":1549077773093},{"_id":"source/_posts/2018-06-19-MusicAbout.md","hash":"b2f6187e77aea91c16412f41f8b5e616dec8ab4d","modified":1549077773093},{"_id":"source/_posts/2018-08-22-GitFlow.md","hash":"0f14e4218f1bdbf8f520002e9aca483e7aea2e1a","modified":1549077773093},{"_id":"source/_posts/2018-08-23-ChangeSvnToGit.md","hash":"664604791ecbdc07f36fccf13e0075d07bfb4b91","modified":1549077773093},{"_id":"source/_posts/2019-02-14-At-the-end-of-2018.md","hash":"6c1744019ee4e80361d3db8584946404d979cf27","modified":1550474422275},{"_id":"source/_posts/位运算的简单理解😊.md","hash":"7f4c4f89811e9c19544173e8736db0dca5088f60","modified":1549077773093},{"_id":"source/about/index.md","hash":"8210136e1ca609e60e9f4965b677b023a72432e2","modified":1549077773093},{"_id":"source/about-me/index.md","hash":"91eda30090381f557cfd0bd6412d970a19d529b1","modified":1549077773093},{"_id":"source/categories/index.md","hash":"85a055685face1e81dcb3dbc22f1761e497ccbcc","modified":1549077773093},{"_id":"source/tags/index.md","hash":"4531c1db9f4b3605e852993f64a82d5b2713258a","modified":1549077773093},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1549077773277},{"_id":"themes/next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1549077773277},{"_id":"themes/next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1549077773287},{"_id":"themes/next/docs/INSTALLATION.md","hash":"bbec0578145441f9975950c82972125e2d89ff51","modified":1549077773287},{"_id":"themes/next/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1549077773287},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1549077773287},{"_id":"themes/next/languages/de.yml","hash":"b8962e3a680530c331c96b06a41a519e7eca9988","modified":1549077773287},{"_id":"themes/next/languages/default.yml","hash":"2e52aa06eedfdfbb90ab0e8792968721aac412fb","modified":1549077773287},{"_id":"themes/next/languages/en.yml","hash":"67eea69a742a2221f2d78af87ad7f6d12cc7b368","modified":1549077773287},{"_id":"themes/next/languages/fr-FR.yml","hash":"e8cf4d66e919f3c1672b8ca26827185e774c4439","modified":1549077773287},{"_id":"themes/next/languages/id.yml","hash":"d0c2f8e90b047db16491a1a5c8f288d0e7244ed3","modified":1549077773297},{"_id":"themes/next/languages/it.yml","hash":"ac109a258ba8a58d07ece728239b093e132feb82","modified":1549077773297},{"_id":"themes/next/languages/ja.yml","hash":"640f0886603b8ed850a2ce81240a414c0cdda997","modified":1549077773297},{"_id":"themes/next/languages/ko.yml","hash":"edf0eeebb6d713c1f7e6b9751b19e8d0b13de4ee","modified":1549077773297},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1549077773297},{"_id":"themes/next/languages/pt-BR.yml","hash":"379591d355f7a1f16447635a0c154bad655db06e","modified":1549077773297},{"_id":"themes/next/languages/pt.yml","hash":"ef68c52c85fa6c1aa0d53586794f8afd0d3a99ae","modified":1549077773297},{"_id":"themes/next/languages/ru.yml","hash":"06e92838a38696f6a519caee12e70ca7898eaea4","modified":1549077773297},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1549077773297},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b016403ee1d4a077a8b82f26918d7679ccd79c2d","modified":1549077773297},{"_id":"themes/next/languages/zh-hk.yml","hash":"6f01b26859d6f3fa86ae346c03f2cff86cdbdc63","modified":1549077773297},{"_id":"themes/next/languages/zh-tw.yml","hash":"85a434a7ed860fed58dc748cba2a857ad6878338","modified":1549077773297},{"_id":"themes/next/layout/_layout.swig","hash":"05119520664cab911dc8bf47eb4f35ecb3d2af68","modified":1549077773297},{"_id":"themes/next/layout/archive.swig","hash":"678a6cab739b54da9dfb2d6634848cffdc7aab6a","modified":1549077773337},{"_id":"themes/next/layout/page.swig","hash":"6f026bd43aa97a49b970cdd6032c8f905909eb91","modified":1549077773337},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1549077773337},{"_id":"themes/next/layout/index.swig","hash":"391e38bf19150b056e443340ad0e86bf28b3be65","modified":1549077773337},{"_id":"themes/next/layout/post.swig","hash":"ceba7287574c429a235aa7a62bf7a3dc1efb265a","modified":1549077773347},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1549077773347},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1549077773347},{"_id":"themes/next/scripts/merge-configs.js","hash":"176952dfe3605c2ab57f3f7cdbac4f2487825c41","modified":1549077773347},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1549077773347},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1549077773478},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1549077773479},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1549077773479},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773297},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773417},{"_id":"themes/next/docs/cn/DATA-FILES.md","hash":"9d1efb47c78969e9b1e5a2374d03ad9ea6e8b738","modified":1549077773287},{"_id":"themes/next/docs/cn/INSTALLATION.md","hash":"67455156e74c6cd72a2c2a342528dfe9677d6fd9","modified":1549077773287},{"_id":"themes/next/docs/cn/README.md","hash":"a9aa0aba1f01a7715c2275f342550555c17b5c78","modified":1549077773287},{"_id":"themes/next/docs/cn/UPDATE-FROM-5.1.X.md","hash":"a667000e655fe66b2234fb66cc99e66450ba8cc8","modified":1549077773287},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"6f10fbc0aa0bb65a8eaeb0a9454aa280f1d84d77","modified":1549077773287},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"995e776aa6d4dbdb4e665e08683873512254100d","modified":1549077773287},{"_id":"themes/next/docs/ru/README.md","hash":"a4f03adf5d20b204ff4d555a9838beca06b05f98","modified":1549077773287},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1549077773287},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1549077773297},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1549077773297},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1549077773297},{"_id":"themes/next/layout/_macro/post.swig","hash":"57a723cbe7de4b254fc9623abf43223e2852f3f4","modified":1549077773307},{"_id":"themes/next/layout/_macro/reward.swig","hash":"8dc3b6ba76c389aaa0810cbd0df206f7096d76a0","modified":1549077773307},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5144734628d75da4e03bc913ca8219575573047d","modified":1549077773307},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"616ffee93e84958e72ee0f996808f866c4ccdbf7","modified":1549077773307},{"_id":"themes/next/layout/_partials/comments.swig","hash":"553d94e5e14bb50cc0b9f31abfe42cbe80d4fa5f","modified":1549077773307},{"_id":"themes/next/layout/_partials/footer.swig","hash":"bc95aa572b504fe63c1a62994ac603442c1d2f5e","modified":1549077773307},{"_id":"themes/next/layout/_partials/header.swig","hash":"73a575d672902cbc926fa1d6a063a0ca163692aa","modified":1549077773307},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1549077773307},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1549077773307},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1549077773307},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1549077773317},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"5c3fe1c304163eab54368b4da70e49eb8c3b4310","modified":1549077773317},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1549077773317},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1549077773317},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1549077773337},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1549077773337},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"1c7d77fce262065cfc321bc2e69f4d6701e4b333","modified":1549077773337},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1549077773337},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1549077773337},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1549077773337},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1549077773337},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1549077773347},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1549077773347},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1549077773347},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1549077773347},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1549077773347},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1549077773347},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1549077773347},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1549077773347},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1549077773347},{"_id":"themes/next/source/css/main.styl","hash":"0bf0dc29230d0de2057471aa01412475cb1da9c0","modified":1549077773417},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1549077773417},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1549077773417},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1549077773427},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1549077773427},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1549077773427},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1549077773437},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1549077773437},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1549077773437},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1549077773437},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"d7c0ff4097f970c0f4be53ede903b51bb0b5c1a7","modified":1549077773437},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"3b5adf169f62fc09db0884850950416226179001","modified":1549077773437},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1549077773437},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1549077773437},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1549077773437},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1549077773437},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1549077773437},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1549077773437},{"_id":"themes/next/source/uploads/test2.jpeg","hash":"a28e5ce4691b6dc8cc9f5c44282a927a29c2c31d","modified":1549077773477},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773317},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773317},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773397},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773397},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773397},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773417},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549077773417},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1549077773307},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1549077773307},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a4b00fd8d70be5dc94ca5d25d373eb9bd8145bab","modified":1549077773307},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"638457c4abfc4c8d3376f878a01e86659214e399","modified":1549077773307},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1549077773307},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1549077773307},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1549077773307},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1549077773317},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1549077773317},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1549077773317},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1549077773317},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1549077773317},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1549077773317},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1549077773317},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1549077773317},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1549077773317},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1549077773317},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1549077773327},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"a693a2c00497471d06113443f548b676ee2e527d","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"787d482d797c38e77d69629ebb88d45f972216b7","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"77fd4a2716aaae1f180060f2812e39d70cd21b68","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"292cdd1059b76d3d10486b71c99d9afb3e59ea44","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"b1fca51cebc5ab7251c8b25afb2d5a4fca8595bc","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"7cf0c589d95a2d1848266ffe2357e91c95d2e7f8","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"ab181c036cda9656f87bb1a749e3e7cbc437f012","modified":1549077773327},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"a6529ec672f69efe5c4e4ba3ea3cf38ca68a3235","modified":1549077773327},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1549077773337},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1549077773337},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1549077773337},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1549077773337},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"b1cee5cc1462b14ab65bd17426821d6729a99361","modified":1549077773397},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1549077773397},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1549077773397},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1549077773397},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1549077773417},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1549077773417},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1549077773417},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1549077773417},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1549077773437},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1549077773437},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1549077773437},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"6c30aab4822b189d1fe9b20ca5272fd8d3ebe998","modified":1549077773437},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1549077773447},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1549077773437},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1549077773447},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1549077773447},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1549077773447},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1549077773447},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9c0e38750e26eb9e83e2b5ab9e069b66f0965ce4","modified":1549077773447},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1549077773447},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1549077773459},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1549077773460},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1549077773460},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1549077773461},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1549077773461},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1549077773475},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1549077773475},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1549077773476},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1549077773470},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1549077773337},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1549077773337},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1549077773377},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1549077773387},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1549077773387},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1549077773397},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1549077773397},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1549077773397},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1549077773397},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1549077773397},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1549077773397},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1549077773397},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1549077773397},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1549077773397},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"65b23000b74b935b2a26f1b4c67d5c8514fd9d34","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"fada15ae00295ebd7b4d9390512ddc09ab759bf1","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1549077773417},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1549077773447},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"f7b9796b5b50c2c267eae284fefb6456ba83d656","modified":1549077773447},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1549077773447},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"b9a1185936351c902a3dfa179a3fde1d81d0ae68","modified":1549077773447},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1549077773462},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1549077773464},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1549077773463},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1549077773471},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1549077773472},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"a2ee51942c79ae7b169eb97c1a310181498d8af5","modified":1549077773417},{"_id":"themes/next/source/images/bg.jpg","hash":"31218a99430dd77d72f4eceeed39896296cbb2e2","modified":1549077773427},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1549077773467},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1549077773468},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1549077773474},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"66f22eb57dda1084c86c54391b6e0465e6534ea4","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1549077773357},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"f1e6e6495e69c4da3e8167ffc56bfc4d17aa15e1","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1549077773367},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"1faeb3fca899df9d033e4e6ad9a4867cdce7ef9d","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1549077773377},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1549077773387},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"b66aa075b48429cf3875fd02f693f378aec424da","modified":1549077773387},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1549077773407},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1549077773407},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"e72794707ef26fbdf5995532d91d95766173ecd4","modified":1549077773447},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"e72794707ef26fbdf5995532d91d95766173ecd4","modified":1549077773458},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1549077773466},{"_id":"themes/next/source/images/bg2.jpg","hash":"925ef1eaccbeccd013f87ef03868f4e1138638dd","modified":1549077773427},{"_id":"public/baidusitemap.xml","hash":"122605943bf6efb7bc1098e8c300e8151a84f174","modified":1550474442969},{"_id":"public/sitemap.xml","hash":"97f921e0da7b7cda83680fcef7846bda31aa02dd","modified":1550474443010},{"_id":"public/search.xml","hash":"5114cec39aacfea17244cdbf96980a48eee238d9","modified":1550474443010},{"_id":"public/about-me/index.html","hash":"88b690f31dd6cf7f0781061ee637fed3a4b7c45b","modified":1550474443066},{"_id":"public/categories/index.html","hash":"d94f2db635b5a14ca72879afcc476860512ddbc8","modified":1550474443066},{"_id":"public/about/index.html","hash":"1f212bb67e31c41f9f44db178489549958a15694","modified":1550474443066},{"_id":"public/tags/index.html","hash":"242f398ff32a0c3ecd7abd2b85c54de189160654","modified":1550474443066},{"_id":"public/2019/02/14/At-the-end-of-2018/index.html","hash":"cb2806f5c703afba39fc16a4a7795d0af3b67ec3","modified":1550474443066},{"_id":"public/2018/08/23/ChangeSvnToGit/index.html","hash":"17b8599d16c156d30b0a866d33c8732011199c95","modified":1550474443066},{"_id":"public/2018/08/23/GitFlow/index.html","hash":"f89fd2376692f8d2d4e3a19f987ed4b0c132b74c","modified":1550474443066},{"_id":"public/2018/06/19/MusicAbout/index.html","hash":"4b0918254df2aa8b2be2a1efe40c28f8004f2945","modified":1550474443066},{"_id":"public/2018/05/08/RX-Swift-Study-One/index.html","hash":"2fe0c43b7cfbf19622e9e8f420a776c99197ce16","modified":1550474443066},{"_id":"public/2018/03/30/AlamoFire/index.html","hash":"0387e9ef10459f9270c472f8a2c8b621573e2f19","modified":1550474443067},{"_id":"public/2018/03/14/Simple-HotFix-Mtehod/index.html","hash":"96e650bf8353c9e672cda4fc07c47c9c1314f209","modified":1550474443067},{"_id":"public/2018/02/12/At-The-End-Of-2017/index.html","hash":"df76fca648ecfa02534c1f8787966c78efcfeed4","modified":1550474443067},{"_id":"public/2018/02/11/关于博客评论插件的问题/index.html","hash":"57bfb16004d250bc0dcae8fd26754141195c6c2a","modified":1550474443067},{"_id":"public/2018/02/08/关于iPhone-X下Home键的隐藏和延迟响应/index.html","hash":"06cd53cc3c565135baa8915f4827112e84017f33","modified":1550474443067},{"_id":"public/2018/01/25/可能是最全的使用HEXO搭建个人博客教程/index.html","hash":"50e0c6fa5611a97d1daf4962028411ce3604c467","modified":1550474443067},{"_id":"public/2018/01/24/可能是最全的iOS端HttpDns集成方案/index.html","hash":"57dd473822ea7dd4b30d7a53fd4ff2ad8f5a98a6","modified":1550474443067},{"_id":"public/2018/01/24/在iOS工程中Cocoapods的使用/index.html","hash":"43158ea1d46c1bc04a5c8b464e32a48356c89549","modified":1550474443067},{"_id":"public/2018/01/24/自定义AlertView/index.html","hash":"377249ededbb4fc346ef1c175c3eec93ed8e672b","modified":1550474443067},{"_id":"public/2018/01/24/NSURLProtocol对WKWebView的处理/index.html","hash":"965fa0e5b58bbefd8547bc3bdea4c71b0a67abe3","modified":1550474443067},{"_id":"public/2018/01/24/iOS-Runtime简单介绍，以及不同类的Method-Swizzling/index.html","hash":"dfee2b1487281c6f55a228fa50f075e812e5f9af","modified":1550474443068},{"_id":"public/2018/01/24/iOS端自动内存泄漏检测工具/index.html","hash":"0a9cce57e3eba18904e4a2cdf625d806ae13ef94","modified":1550474443068},{"_id":"public/2018/01/24/转-如何掌握所有的程序语言/index.html","hash":"cf87fbbef0373359b761b49939d9b42005c390a8","modified":1550474443068},{"_id":"public/2018/01/24/记一次Runtime-Hook的问题/index.html","hash":"06c36d8c560954f66dc9cfde22e13a0fcd7af397","modified":1550474443068},{"_id":"public/2018/01/23/iOS中使用OpenGL实现增高功能/index.html","hash":"a25a8b713c6118c7e104251a948788999cd91c4b","modified":1550474443068},{"_id":"public/2018/01/23/关于物理效果的动画引擎UIDynamic介绍/index.html","hash":"51bf86b935a57eb0bdcdfbfc4d22d8a83490563d","modified":1550474443068},{"_id":"public/2018/01/23/关于视图在切圆角时候的导致的性能下降的一些探讨/index.html","hash":"a44f1ca8846503fa9c067023e38a01dc3ff330ae","modified":1550474443068},{"_id":"public/2018/01/23/CFNetwork的介绍和使用/index.html","hash":"891b3e51484788d32cecdc548cf8d0f8ceec3c11","modified":1550474443068},{"_id":"public/2018/01/23/深入理解Http请求、DNS劫持与解析/index.html","hash":"e8bf111b430ef6841d65b2bdca5d719ee902c28b","modified":1550474443068},{"_id":"public/2018/01/23/在iOS11下app图标变空白的问题解决/index.html","hash":"287dcbf47b9a5121164fb81609252d98e550bd53","modified":1550474443069},{"_id":"public/2018/01/23/IOS下三种DNS解析方式分析（LocalDns）/index.html","hash":"86cef368351856e959619a5ac7d70bf9d522e841","modified":1550474443069},{"_id":"public/2018/01/19/test-source/index.html","hash":"b1937c28fb6a3400c64c9f76269d242944674f7b","modified":1550474443069},{"_id":"public/2018/01/19/位运算的简单理解😊/index.html","hash":"dc6ab6f9448a04138f35d52e5fa22ca89b702dda","modified":1550474443069},{"_id":"public/archives/index.html","hash":"98c66c7818063e724b4728f47ab622d2a4ece51b","modified":1550474443069},{"_id":"public/archives/page/2/index.html","hash":"b06353f0b2eea52ecc919bfc942d2b2252a7f6d4","modified":1550474443069},{"_id":"public/archives/page/3/index.html","hash":"19b6ec335a21b6bbd23188aaa696afa29412c1d1","modified":1550474443069},{"_id":"public/archives/2018/index.html","hash":"05b45e0cb82c680ec98b977b4ab7faa9994cdb3b","modified":1550474443069},{"_id":"public/archives/2018/page/2/index.html","hash":"88589cb9a3ac8b5d355315cf9374a9fc02498f46","modified":1550474443070},{"_id":"public/archives/2018/page/3/index.html","hash":"11227b39d98d885f1b38247575f92cf296f103c0","modified":1550474443070},{"_id":"public/archives/2018/01/index.html","hash":"12122c1145632c9ec46daab3608ab12090792ae3","modified":1550474443070},{"_id":"public/archives/2018/01/page/2/index.html","hash":"cedcd6c24648e9e6419d8bf271644d309038cf6f","modified":1550474443070},{"_id":"public/archives/2018/02/index.html","hash":"32a89114f08b62b4b16d0b7597e20e6de9142325","modified":1550474443070},{"_id":"public/archives/2018/03/index.html","hash":"f658544305a45e36e9d706cf9d15dac81727ff9d","modified":1550474443071},{"_id":"public/archives/2018/05/index.html","hash":"25dd997e0be0d583b8070fc2669f4ee6c77e4118","modified":1550474443071},{"_id":"public/archives/2018/06/index.html","hash":"cc5299a7fceee2210a5282746246599be125eb0e","modified":1550474443071},{"_id":"public/archives/2018/08/index.html","hash":"34462272f2b354fa38023b77295e7e35b175c44f","modified":1550474443071},{"_id":"public/archives/2019/index.html","hash":"38ff3f35f167025fa9f8e37132bf4a2912108c75","modified":1550474443071},{"_id":"public/archives/2019/02/index.html","hash":"f14e4d049882dc2772456db0043f6e86bdf32295","modified":1550474443071},{"_id":"public/categories/iOS开发/index.html","hash":"bbb2f2f9eb8d6cee7e7ee128d965f433f63a5534","modified":1550474443071},{"_id":"public/categories/iOS开发/page/2/index.html","hash":"d22d3b0eeb84a5a10c910468f1cde51267f6e37e","modified":1550474443071},{"_id":"public/categories/其他/index.html","hash":"2a9091fc69e28c08cfc0deb091e076e0f738eabc","modified":1550474443071},{"_id":"public/categories/译文/index.html","hash":"841f4c0b43539b926443eb9027b1219aa77442eb","modified":1550474443072},{"_id":"public/categories/通用开发/index.html","hash":"436af2f6d9814f2e0e8d20c93c78827d149f8eb8","modified":1550474443072},{"_id":"public/categories/闲谈/index.html","hash":"c93ff0caf881e682f36388649787c2cc3726ceb0","modified":1550474443072},{"_id":"public/index.html","hash":"057920e6103e2139f4627ba7d5db402f64de9ff6","modified":1550474443072},{"_id":"public/page/2/index.html","hash":"d6b51580d49bbed6225f42e2608eb27aa93d8e65","modified":1550474443072},{"_id":"public/page/3/index.html","hash":"d7477e6bae3907d0f2d8d7f1f18c8bcde5fa709d","modified":1550474443072},{"_id":"public/tags/DNS解析/index.html","hash":"073057c68c524b0287dc3cd788c09fb0215a0fa5","modified":1550474443072},{"_id":"public/tags/LocalDNS/index.html","hash":"017a62e6bbf38e6a05dfaf5b55e56ccf3bea1103","modified":1550474443073},{"_id":"public/tags/xcode/index.html","hash":"d29569a9759de487712234ce09bd4a8d84b1bcb3","modified":1550474443073},{"_id":"public/tags/cocoapods/index.html","hash":"d5a3a93ef827aebfd2e12cbf0b3f10edb854c6d1","modified":1550474443073},{"_id":"public/tags/podfile/index.html","hash":"f1e562544b1d33389f013eb72e0f1f97341e77e1","modified":1550474443073},{"_id":"public/tags/网络/index.html","hash":"a986025775a22c68566ec707e44b8659319b783c","modified":1550474443073},{"_id":"public/tags/底层/index.html","hash":"f78ec59c36aacc7ce7adade75e3fde9eeda4f9b3","modified":1550474443073},{"_id":"public/tags/动画/index.html","hash":"ae85dcbb87e2001718d729bb87297e19878f0b89","modified":1550474443073},{"_id":"public/tags/UI/index.html","hash":"cdc6b90239f43079c35a186ee72440e87c9ebb7f","modified":1550474443073},{"_id":"public/tags/性能优化/index.html","hash":"500c2dc8f9f37a9bd1520ac91390794728ff2e1d","modified":1550474443073},{"_id":"public/tags/欢迎页/index.html","hash":"a2b23223b6f3553ba66cdc7587e43f06d01b606a","modified":1550474443073},{"_id":"public/tags/OpenGL/index.html","hash":"c811125ab5f1d493619d9a4e89ea406cd6196e13","modified":1550474443073},{"_id":"public/tags/webview/index.html","hash":"cc075dbba07e740b5975a68339caf1a8de267a62","modified":1550474443073},{"_id":"public/tags/hook/index.html","hash":"fd8b14ccc17be040f22335e865af161eebbacdcb","modified":1550474443074},{"_id":"public/tags/runtime/index.html","hash":"d0c474e9262f8820d22ac6edbbf102843ecdf480","modified":1550474443074},{"_id":"public/tags/翻译/index.html","hash":"4ca961ff98c6f089deea173a10e1aa403933b7d7","modified":1550474443074},{"_id":"public/tags/优化/index.html","hash":"bfb25d2280fdf2055ece5594737df9009a9b17aa","modified":1550474443074},{"_id":"public/tags/国外文献/index.html","hash":"c258cd5176b0f3bd4b8ca06f685bfdf024e3d07f","modified":1550474443074},{"_id":"public/tags/httpdns/index.html","hash":"68adba79aaad1527101f3b5a5fbfcb499a804c6b","modified":1550474443074},{"_id":"public/tags/AlertView/index.html","hash":"9726949623823bf95e795d9865c0d933ae34d38b","modified":1550474443074},{"_id":"public/tags/Cocoapods/index.html","hash":"fb5092a16002f4665a718163aa794cf4399ad1bb","modified":1550474443074},{"_id":"public/tags/架构/index.html","hash":"b24568bf23d0177ea846213da092947e1e453de3","modified":1550474443074},{"_id":"public/tags/杂谈/index.html","hash":"c85997fe48adad0014424519874cec7df506341c","modified":1550474443074},{"_id":"public/tags/Hook/index.html","hash":"570c12ed0b123099d6cb5e722bae59431ff4cfbf","modified":1550474443074},{"_id":"public/tags/屏幕适配/index.html","hash":"18cd5839b21d81d1f771010b8c8e0029097e6364","modified":1550474443074},{"_id":"public/tags/iOS-11/index.html","hash":"32c8d321e196fa0e2ae02aecfac88679c135a4e6","modified":1550474443075},{"_id":"public/tags/Hexo/index.html","hash":"60097c6d17e8a33309b0b1810ff92b73b66fec49","modified":1550474443075},{"_id":"public/tags/个人博客/index.html","hash":"7a56581412895b4de1d48499b9beb668c9e263f9","modified":1550474443075},{"_id":"public/tags/网站/index.html","hash":"c407af6bd5ab29fafd8c287e61754a9da848a6e1","modified":1550474443075},{"_id":"public/tags/热修复/index.html","hash":"b7d02a3f0096b2ae3eb11faedef6700a3da2a4c2","modified":1550474443075},{"_id":"public/tags/JSPath/index.html","hash":"ca0196928075c7fb5efb33a438e2c15c6f2312ee","modified":1550474443075},{"_id":"public/tags/总结/index.html","hash":"167d3bb1f356992216cfbda928f0c733097da553","modified":1550474443075},{"_id":"public/tags/回味2017展望2018/index.html","hash":"292c5f1af8abbbd73dadf7fb6cfcbcf605b4a04d","modified":1550474443075},{"_id":"public/tags/评论插件/index.html","hash":"f0f1e32dfc60df54d63f1f0f663f3c8ce68551bd","modified":1550474443075},{"_id":"public/tags/Swift/index.html","hash":"f999164f7383cd0a6433e7148b722157c26fa686","modified":1550474443075},{"_id":"public/tags/swift/index.html","hash":"90ba8735343ae0abe981b14cccd7dfe2b42142f6","modified":1550474443075},{"_id":"public/tags/网络请求/index.html","hash":"2779ef16e4e4fe0d904eabe144026e7b7b6317a6","modified":1550474443075},{"_id":"public/tags/git/index.html","hash":"748ab1f7743e3c12f39275048bee1a9e0357e336","modified":1550474443075},{"_id":"public/tags/代码版本控制/index.html","hash":"21fb88a87a76d8836eac44c5db43d9ea7832e39a","modified":1550474443075},{"_id":"public/tags/效率工作/index.html","hash":"881126a07fc2a05c45576af6c496dbfe45075ff3","modified":1550474443075},{"_id":"public/tags/音频/index.html","hash":"0313628ad2fb2087700caa236c4b39c1177f7fc6","modified":1550474443076},{"_id":"public/tags/唱吧/index.html","hash":"c1b6465445625e7f8cd800002559fece43eca3a6","modified":1550474443076},{"_id":"public/tags/K歌/index.html","hash":"91f28d7696e6779d76e09a71516c331229f50205","modified":1550474443076},{"_id":"public/tags/AVFoundation/index.html","hash":"99c13dfd09e879b09d4e3a1ac1430307c783ac2a","modified":1550474443076},{"_id":"public/tags/回首2018展望2019/index.html","hash":"be973596bf2481ce329fd27c75b9d3792901f49d","modified":1550474443076},{"_id":"public/tags/算法/index.html","hash":"db9fd954147e76e8ab7130fa62eb7d55e875761f","modified":1550474443076},{"_id":"public/tags/C语言/index.html","hash":"6acc564f0e8afff84558b867fc09ad6e3e38882f","modified":1550474443076},{"_id":"public/tags/排序/index.html","hash":"3c01d2d949770ea52d35d93807f6dc91953bb7ad","modified":1550474443076},{"_id":"public/robots.txt","hash":"361c70ce4234cd458c8148d1ce319c864d40750c","modified":1550474443090},{"_id":"public/CNAME","hash":"1415d5dc97bcc7d473c7924dd6679239c0f5ead8","modified":1550474443090},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550474443090},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1550474443090},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1550474443090},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1550474443090},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1550474443090},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1550474443090},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1550474443091},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1550474443091},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1550474443091},{"_id":"public/images/favicon-16x16-next.png","hash":"d7c0ff4097f970c0f4be53ede903b51bb0b5c1a7","modified":1550474443091},{"_id":"public/images/favicon-32x32-next.png","hash":"3b5adf169f62fc09db0884850950416226179001","modified":1550474443091},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550474443091},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1550474443091},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550474443091},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1550474443091},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1550474443091},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550474443091},{"_id":"public/uploads/test2.jpeg","hash":"a28e5ce4691b6dc8cc9f5c44282a927a29c2c31d","modified":1550474443091},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1550474443091},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1550474443092},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550474443606},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550474443610},{"_id":"public/assets/js/APlayer.min.js","hash":"58bb2094b0610adedc3d78719f255c79e71fc4ab","modified":1550474443611},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1550474443620},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1550474443621},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1550474443621},{"_id":"public/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1550474443621},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1550474443621},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550474443621},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1550474443621},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1550474443621},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1550474443621},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550474443621},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1550474443622},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1550474443622},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1550474443622},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1550474443622},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1550474443622},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1550474443622},{"_id":"public/css/main.css","hash":"c2b802317db1b405e37599fddc7edcc2af6403e9","modified":1550474443622},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550474443622},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550474443622},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550474443622},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1550474443622},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550474443623},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1550474443623},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1550474443623},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1550474443623},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1550474443623},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550474443623},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550474443623},{"_id":"public/images/bg.jpg","hash":"31218a99430dd77d72f4eceeed39896296cbb2e2","modified":1550474443645},{"_id":"public/images/apple-touch-icon-next.png","hash":"a2ee51942c79ae7b169eb97c1a310181498d8af5","modified":1550474443645},{"_id":"public/images/bg2.jpg","hash":"925ef1eaccbeccd013f87ef03868f4e1138638dd","modified":1550474443702}],"Category":[{"name":"iOS开发","_id":"cjsa0g2kj0004a04wag0g1yua"},{"name":"其他","_id":"cjsa0g2l2000na04wmohzlphv"},{"name":"译文","_id":"cjsa0g2l8000xa04w54f9mqoy"},{"name":"通用开发","_id":"cjsa0g2le001aa04wnb4ie0bb"},{"name":"闲谈","_id":"cjsa0g2lo001qa04wajuicdln"}],"Data":[],"Page":[{"title":"about_me","date":"2019-01-12T03:48:04.000Z","_content":"# 哈哈我是谁\n你猜","source":"about-me/index.md","raw":"---\ntitle: about_me\ndate: 2019-01-12 11:48:04\n---\n# 哈哈我是谁\n你猜","updated":"2019-02-02T03:22:53.093Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cjsa0g2kd0001a04w87vszlo7","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"哈哈我是谁\"><a href=\"#哈哈我是谁\" class=\"headerlink\" title=\"哈哈我是谁\"></a>哈哈我是谁</h1><p>你猜</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"哈哈我是谁\"><a href=\"#哈哈我是谁\" class=\"headerlink\" title=\"哈哈我是谁\"></a>哈哈我是谁</h1><p>你猜</p>\n"},{"title":"categories","date":"2018-01-22T09:35:31.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-01-22 17:35:31\ntype: categories\ncomments: false\n\n---\n","updated":"2019-02-02T03:22:53.093Z","path":"categories/index.html","layout":"page","_id":"cjsa0g2kh0003a04wrnf5re1o","content":"<script src=\"/assets/js/APlayer.min.js\"> </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"molier","date":"2018-01-22T09:32:49.000Z","type":"about","comments":1,"_content":"<!-- 标签 方式，要求版本在0.4.5或以上 -->\n\n\n{% cq %}珍惜一切 <br> <br> 不管是一杯水还是一次公园的散步 <br> <br> 但大多数人都很幸运 <br> <br> 他们不知道什么时候会停 <br> <br> 讽刺的是就因为这个 <br> <br> 他们才不能好好地活着 <br> <br> 他们喝水却从不感受它的甘甜{% endcq %}\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"BINGBIAN(病变)\",\n            \"author\": \"鞠文娴\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/BINGBIAN.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000zFECL2iqwch.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002lUqDY0GmcWjc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n\n### 还在完善中，有什么想说的下面留言给我吧！\n","source":"about/index.md","raw":"---\ntitle: molier\ndate: 2018-01-22 17:32:49\ntype: about\ncomments: true\n---\n<!-- 标签 方式，要求版本在0.4.5或以上 -->\n\n\n{% cq %}珍惜一切 <br> <br> 不管是一杯水还是一次公园的散步 <br> <br> 但大多数人都很幸运 <br> <br> 他们不知道什么时候会停 <br> <br> 讽刺的是就因为这个 <br> <br> 他们才不能好好地活着 <br> <br> 他们喝水却从不感受它的甘甜{% endcq %}\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"BINGBIAN(病变)\",\n            \"author\": \"鞠文娴\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/BINGBIAN.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000zFECL2iqwch.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002lUqDY0GmcWjc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n\n### 还在完善中，有什么想说的下面留言给我吧！\n","updated":"2019-02-02T03:22:53.093Z","path":"about/index.html","layout":"page","_id":"cjsa0g2kn0007a04w0ok9yh6c","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><!-- 标签 方式，要求版本在0.4.5或以上 -->\n<blockquote class=\"blockquote-center\"><p>珍惜一切 <br> <br> 不管是一杯水还是一次公园的散步 <br> <br> 但大多数人都很幸运 <br> <br> 他们不知道什么时候会停 <br> <br> 讽刺的是就因为这个 <br> <br> 他们才不能好好地活着 <br> <br> 他们喝水却从不感受它的甘甜</p>\n</blockquote>\n\n\t\t\t<div id=\"aplayer6\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"BINGBIAN(病变)\",\"author\":\"鞠文娴\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/BINGBIAN.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000zFECL2iqwch.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002lUqDY0GmcWjc\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer6\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n<h3 id=\"还在完善中，有什么想说的下面留言给我吧！\"><a href=\"#还在完善中，有什么想说的下面留言给我吧！\" class=\"headerlink\" title=\"还在完善中，有什么想说的下面留言给我吧！\"></a>还在完善中，有什么想说的下面留言给我吧！</h3>","site":{"data":{}},"excerpt":"","more":"<!-- 标签 方式，要求版本在0.4.5或以上 -->\n<blockquote class=\"blockquote-center\"><p>珍惜一切 <br> <br> 不管是一杯水还是一次公园的散步 <br> <br> 但大多数人都很幸运 <br> <br> 他们不知道什么时候会停 <br> <br> 讽刺的是就因为这个 <br> <br> 他们才不能好好地活着 <br> <br> 他们喝水却从不感受它的甘甜</p>\n</blockquote>\n\n\t\t\t<div id=\"aplayer6\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"BINGBIAN(病变)\",\"author\":\"鞠文娴\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/BINGBIAN.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000zFECL2iqwch.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002lUqDY0GmcWjc\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer6\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n<h3 id=\"还在完善中，有什么想说的下面留言给我吧！\"><a href=\"#还在完善中，有什么想说的下面留言给我吧！\" class=\"headerlink\" title=\"还在完善中，有什么想说的下面留言给我吧！\"></a>还在完善中，有什么想说的下面留言给我吧！</h3>"},{"title":"tags","date":"2018-01-22T09:59:31.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-01-22 17:59:31\ntype: \"tags\"\ncomments: false\n\n---\n","updated":"2019-02-02T03:22:53.093Z","path":"tags/index.html","layout":"page","_id":"cjsa0g2kp0009a04win7e62e5","content":"<script src=\"/assets/js/APlayer.min.js\"> </script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"IOS下三种DNS解析方式分析（LocalDns）","date":"2018-01-23T10:02:29.000Z","comments":1,"_content":"### 背景\n最近在做iOS的DNS解析，顺便研究了下iOS端本地的DNS解析方式（localDNS）,也就是不依赖Http请求，而是用原始的API进行解析，虽然有HttpDNS但是考虑到成本、第三方服务稳定性的问题，LocalDNS仍然是一个很重要的部分，在iOS系统下，localDNS的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。\n### 方式一\n这个也是我一开始在项目中使用的方式。\n```\n1：struct hostent\t*gethostbyname(const char *);\n2：struct hostent\t*gethostbyname2(const char *, int);\n```\n两个函数作用完全一样，返回值一样，但是第一个只能用于IPV4的网络环境，而第二个则IPV4和IPV6都可使用，可以通过第二个参数传入当前的网络环境。\n<!---more--->\n###### 使用方式：\n```\n CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n\n    char   *ptr, **pptr;\n    struct hostent *hptr;\n    char   str[32];\n    ptr = \"www.meitu.com\";\n    NSMutableArray * ips = [NSMutableArray array];\n\n     if((hptr = gethostbyname(ptr)) == NULL)\n    {\n        return;\n    }\n\n    for(pptr=hptr->h_addr_list; *pptr!=NULL; pptr++) {\n         NSString * ipStr = [NSString stringWithCString:inet_ntop(hptr->h_addrtype, *pptr, str, sizeof(str)) encoding:NSUTF8StringEncoding];\n         [ips addObject:ipStr?:@\"\"];\n    }\n\n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    NSLog(@\"22222 === ip === %@ === time cost: %0.3fs\", ips,end - start);\n```\n\n使用gethostbyname方法后会得到一个struct,也就是上文的struct hostent *hptr：\n```\nstruct hostent {\n\tchar\t*h_name;\t/* official name of host */\n\tchar\t**h_aliases;\t/* alias list */\n\tint\th_addrtype;\t/* host address type */\n\tint\th_length;\t/* length of address */\n\tchar\t**h_addr_list;\t/* list of addresses from name server */\n#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)\n#define\th_addr\th_addr_list[0]\t/* address, for backward compatibility */\n#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */\n};\n```\n\n###### 参数解析：\n * hostent->h_name\n   表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。\n\n * hostent->h_aliases\n   表示的是主机的别名www.baidu.com的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。\n\n * hostent->h_addrtype     \n   表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)\n\n * hostent->h_length       \n   表示的是主机ip地址的长度\n\n * hostent->h_addr_lisst\n   表示的是主机的ip地址，注意，这个是以网络字节序存储的。不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用`const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt) `，来把它转成char。详细使用见上文\n###### 缺点：\n* 在进行网络切换的时候小概率卡死，自测十次有一两次左右。\n\n* 在本地的LocalDns被破坏的时候会必卡死30秒，然后返回nil 。\n\n* 缓存是个玄学东西，他会对自己解析出来的IP进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的IP，\n\n* 网上说的比较多的问题\n\n  ![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6myoq10ej30po01w0tb.jpg)\n\n### 方式二\n除了经常用到的gethostbyname(3)和gethostbyaddr(3)函数以外, Linux(以及其它UNIX/UNIX-like系统)还提供了一套用于在底层处理DNS相关问题的函数(这里所说的底层仅是相对gethostbyname和gethostbyaddr两个函数而言). 这套函数被称为地址解析函数(resolver functions)。曾经尝试过这个方式...\n```\nint\t\tres_query __P((const char *, int, int, u_char *, int));\n函数原型为：\nint res_query(const char *dname, int class, int type, unsigned char *answer, int anslen)\n```\n这个方式需要在项目中添加`libresolv.tbd`库，因为要依赖于库中的函数去解析。`res_query`用来发出一个指定类(由参数class指定)和类型(由参数type指定)的DNS询问. dname是要查询的主机名. 返回信息被存储在answser指向的内存区域中. 信息的长度不能大于anslen个字节. 这个函数会创建一个DNS查询报文并把它发送到指定的DNS服务器。\n###### 使用方式\n```\nCFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n\n    unsigned char auResult[512];\n    int nBytesRead = 0;\n\n    nBytesRead = res_query(\"www.meitu.com\", ns_c_in, ns_t_a, auResult, sizeof(auResult));\n\n    ns_msg handle;\n    ns_initparse(auResult, nBytesRead, &handle);\n\n    NSMutableArray *ipList = nil;\n    int msg_count = ns_msg_count(handle, ns_s_an);\n    if (msg_count > 0) {\n        ipList = [[NSMutableArray alloc] initWithCapacity:msg_count];\n        for(int rrnum = 0; rrnum < msg_count; rrnum++) {\n            ns_rr rr;\n            if(ns_parserr(&handle, ns_s_an, rrnum, &rr) == 0) {\n                char ip1[16];\n                strcpy(ip1, inet_ntoa(*(struct in_addr *)ns_rr_rdata(rr)));\n                NSString *ipString = [[NSString alloc] initWithCString:ip1 encoding:NSASCIIStringEncoding];\n                if (![ipString isEqualToString:@\"\"]) {\n\n                    //将提取到的IP地址放到数组中\n                    [ipList addObject:ipString];\n                }\n            }\n        }\n        CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n        NSLog(@\"11111 === ip === %@ === time cost: %0.3fs\", ipList,end - start);\n    }\n```\n###### 参数解析\n\n由于该逻辑是Linux底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对Linux内核的理解，这里放一篇[参考资料](https://www.cnblogs.com/renhao/archive/2011/11/14/2248528.html)\n###### 优点：\n* 在LocalDns被破坏掉的情况下能及时响应不会延迟。\n* 没有缓存，缓存由开发者控制\n###### 缺点\n* 在进行网络切换时候3G/4G切wify高概率出现卡死\n这一个缺点是比较致命的，所以没有再继续使用。\n\n### 方式三\n苹果原生的DNS解析\n\n```\nBoolean CFHostStartInfoResolution (CFHostRef theHost, CFHostInfoType info, CFStreamError *error);\n```\n###### 使用方法：\n```\n    Boolean result,bResolved;\n    CFHostRef hostRef;\n    CFArrayRef addresses = NULL;\n    NSMutableArray * ipsArr = [[NSMutableArray alloc] init];\n\n    CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, \"www.meitu.com\", kCFStringEncodingASCII);\n\n    hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);\n    CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n    result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);\n    if (result == TRUE) {\n        addresses = CFHostGetAddressing(hostRef, &result);\n    }\n    bResolved = result == TRUE ? true : false;\n\n    if(bResolved)\n    {\n        struct sockaddr_in* remoteAddr;\n        for(int i = 0; i < CFArrayGetCount(addresses); i++)\n        {\n            CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i);\n            remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData);\n\n            if(remoteAddr != NULL)\n            {\n                //获取IP地址\n                char ip[16];\n                strcpy(ip, inet_ntoa(remoteAddr->sin_addr));\n                NSString * ipStr = [NSString stringWithCString:ip encoding:NSUTF8StringEncoding];\n                [ipsArr addObject:ipStr];\n            }\n        }\n    }\n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    NSLog(@\"33333 === ip === %@ === time cost: %0.3fs\", ipsArr,end - start);\n    CFRelease(hostNameRef);\n    CFRelease(hostRef);\n```\n###### 参数解析：\n```\n/*\n *  CFHostStartInfoResolution()\n *  \n *  Discussion:\n *\tPerforms a lookup for the given host.  It will search for the\n *\trequested information if there is no other active request.\n *\tPreviously cached information of the given type will be released.\n *  \n *  Mac OS X threading:\n *\tThread safe\n *  \n *  Parameters:\n *\n *\ttheHost:  //需要被解决的CFHostRef的对象\n *\t  The CFHostRef which should be resolved. Must be non-NULL. If\n *\t  this reference is not a valid CFHostRef, the behavior is\n *\t  undefined.\n *\n *\tinfo: 返回值的类型 数组/Data/string..\n *\t  The enum representing the type of information to be retrieved.\n *\t  If the value is not a valid type, the behavior is undefined.\n *\n *\terror: 错误\n *\t  A reference to a CFStreamError structure which will be filled\n *\t  with any error information should an error occur.  May be set\n *\t  to NULL if error information is not wanted.\n *  \n *  Result: 解析结果成功还是失败\n *\tReturns TRUE on success and FALSE on failure.  In asynchronous\n *\tmode, this function will return immediately.  In synchronous\n *\tmode, it will block until the resolve has completed or until the\n *\tresolve is cancelled.\n *  \n */\nCFN_EXPORT __nullable CFArrayRef\nCFHostGetAddressing(CFHostRef theHost, Boolean * __nullable hasBeenResolved) CF_AVAILABLE(10_3, 2_0);\n```\n###### 优点：\n* 在网络切换时候不会卡顿。\n###### 缺点：\n* 在本地DNS被破坏的情况下会出现卡死的现象(卡30s)\n### 总结：\n以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地LocalDns破坏会卡死的问题看来是无法避免，不过开发者可以自行通过ping等方式来判断LocalDns的正确性，在被破坏的情况下使用httpDns来进行解析即可。具体的demo可以到[这里](https://github.com/zhangninghao/LocalDns)查看\n","source":"_posts/2018-01-23-IOS下三种DNS解析方式分析（LocalDns）.md","raw":"---\ntitle: IOS下三种DNS解析方式分析（LocalDns）\ndate: 2018-01-23 18:02:29\ntags:\n - DNS解析\n - LocalDNS\ncategories: iOS开发\ncomments:\n---\n### 背景\n最近在做iOS的DNS解析，顺便研究了下iOS端本地的DNS解析方式（localDNS）,也就是不依赖Http请求，而是用原始的API进行解析，虽然有HttpDNS但是考虑到成本、第三方服务稳定性的问题，LocalDNS仍然是一个很重要的部分，在iOS系统下，localDNS的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。\n### 方式一\n这个也是我一开始在项目中使用的方式。\n```\n1：struct hostent\t*gethostbyname(const char *);\n2：struct hostent\t*gethostbyname2(const char *, int);\n```\n两个函数作用完全一样，返回值一样，但是第一个只能用于IPV4的网络环境，而第二个则IPV4和IPV6都可使用，可以通过第二个参数传入当前的网络环境。\n<!---more--->\n###### 使用方式：\n```\n CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n\n    char   *ptr, **pptr;\n    struct hostent *hptr;\n    char   str[32];\n    ptr = \"www.meitu.com\";\n    NSMutableArray * ips = [NSMutableArray array];\n\n     if((hptr = gethostbyname(ptr)) == NULL)\n    {\n        return;\n    }\n\n    for(pptr=hptr->h_addr_list; *pptr!=NULL; pptr++) {\n         NSString * ipStr = [NSString stringWithCString:inet_ntop(hptr->h_addrtype, *pptr, str, sizeof(str)) encoding:NSUTF8StringEncoding];\n         [ips addObject:ipStr?:@\"\"];\n    }\n\n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    NSLog(@\"22222 === ip === %@ === time cost: %0.3fs\", ips,end - start);\n```\n\n使用gethostbyname方法后会得到一个struct,也就是上文的struct hostent *hptr：\n```\nstruct hostent {\n\tchar\t*h_name;\t/* official name of host */\n\tchar\t**h_aliases;\t/* alias list */\n\tint\th_addrtype;\t/* host address type */\n\tint\th_length;\t/* length of address */\n\tchar\t**h_addr_list;\t/* list of addresses from name server */\n#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)\n#define\th_addr\th_addr_list[0]\t/* address, for backward compatibility */\n#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */\n};\n```\n\n###### 参数解析：\n * hostent->h_name\n   表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。\n\n * hostent->h_aliases\n   表示的是主机的别名www.baidu.com的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。\n\n * hostent->h_addrtype     \n   表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)\n\n * hostent->h_length       \n   表示的是主机ip地址的长度\n\n * hostent->h_addr_lisst\n   表示的是主机的ip地址，注意，这个是以网络字节序存储的。不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用`const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt) `，来把它转成char。详细使用见上文\n###### 缺点：\n* 在进行网络切换的时候小概率卡死，自测十次有一两次左右。\n\n* 在本地的LocalDns被破坏的时候会必卡死30秒，然后返回nil 。\n\n* 缓存是个玄学东西，他会对自己解析出来的IP进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的IP，\n\n* 网上说的比较多的问题\n\n  ![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6myoq10ej30po01w0tb.jpg)\n\n### 方式二\n除了经常用到的gethostbyname(3)和gethostbyaddr(3)函数以外, Linux(以及其它UNIX/UNIX-like系统)还提供了一套用于在底层处理DNS相关问题的函数(这里所说的底层仅是相对gethostbyname和gethostbyaddr两个函数而言). 这套函数被称为地址解析函数(resolver functions)。曾经尝试过这个方式...\n```\nint\t\tres_query __P((const char *, int, int, u_char *, int));\n函数原型为：\nint res_query(const char *dname, int class, int type, unsigned char *answer, int anslen)\n```\n这个方式需要在项目中添加`libresolv.tbd`库，因为要依赖于库中的函数去解析。`res_query`用来发出一个指定类(由参数class指定)和类型(由参数type指定)的DNS询问. dname是要查询的主机名. 返回信息被存储在answser指向的内存区域中. 信息的长度不能大于anslen个字节. 这个函数会创建一个DNS查询报文并把它发送到指定的DNS服务器。\n###### 使用方式\n```\nCFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n\n    unsigned char auResult[512];\n    int nBytesRead = 0;\n\n    nBytesRead = res_query(\"www.meitu.com\", ns_c_in, ns_t_a, auResult, sizeof(auResult));\n\n    ns_msg handle;\n    ns_initparse(auResult, nBytesRead, &handle);\n\n    NSMutableArray *ipList = nil;\n    int msg_count = ns_msg_count(handle, ns_s_an);\n    if (msg_count > 0) {\n        ipList = [[NSMutableArray alloc] initWithCapacity:msg_count];\n        for(int rrnum = 0; rrnum < msg_count; rrnum++) {\n            ns_rr rr;\n            if(ns_parserr(&handle, ns_s_an, rrnum, &rr) == 0) {\n                char ip1[16];\n                strcpy(ip1, inet_ntoa(*(struct in_addr *)ns_rr_rdata(rr)));\n                NSString *ipString = [[NSString alloc] initWithCString:ip1 encoding:NSASCIIStringEncoding];\n                if (![ipString isEqualToString:@\"\"]) {\n\n                    //将提取到的IP地址放到数组中\n                    [ipList addObject:ipString];\n                }\n            }\n        }\n        CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n        NSLog(@\"11111 === ip === %@ === time cost: %0.3fs\", ipList,end - start);\n    }\n```\n###### 参数解析\n\n由于该逻辑是Linux底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对Linux内核的理解，这里放一篇[参考资料](https://www.cnblogs.com/renhao/archive/2011/11/14/2248528.html)\n###### 优点：\n* 在LocalDns被破坏掉的情况下能及时响应不会延迟。\n* 没有缓存，缓存由开发者控制\n###### 缺点\n* 在进行网络切换时候3G/4G切wify高概率出现卡死\n这一个缺点是比较致命的，所以没有再继续使用。\n\n### 方式三\n苹果原生的DNS解析\n\n```\nBoolean CFHostStartInfoResolution (CFHostRef theHost, CFHostInfoType info, CFStreamError *error);\n```\n###### 使用方法：\n```\n    Boolean result,bResolved;\n    CFHostRef hostRef;\n    CFArrayRef addresses = NULL;\n    NSMutableArray * ipsArr = [[NSMutableArray alloc] init];\n\n    CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, \"www.meitu.com\", kCFStringEncodingASCII);\n\n    hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);\n    CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n    result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);\n    if (result == TRUE) {\n        addresses = CFHostGetAddressing(hostRef, &result);\n    }\n    bResolved = result == TRUE ? true : false;\n\n    if(bResolved)\n    {\n        struct sockaddr_in* remoteAddr;\n        for(int i = 0; i < CFArrayGetCount(addresses); i++)\n        {\n            CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i);\n            remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData);\n\n            if(remoteAddr != NULL)\n            {\n                //获取IP地址\n                char ip[16];\n                strcpy(ip, inet_ntoa(remoteAddr->sin_addr));\n                NSString * ipStr = [NSString stringWithCString:ip encoding:NSUTF8StringEncoding];\n                [ipsArr addObject:ipStr];\n            }\n        }\n    }\n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    NSLog(@\"33333 === ip === %@ === time cost: %0.3fs\", ipsArr,end - start);\n    CFRelease(hostNameRef);\n    CFRelease(hostRef);\n```\n###### 参数解析：\n```\n/*\n *  CFHostStartInfoResolution()\n *  \n *  Discussion:\n *\tPerforms a lookup for the given host.  It will search for the\n *\trequested information if there is no other active request.\n *\tPreviously cached information of the given type will be released.\n *  \n *  Mac OS X threading:\n *\tThread safe\n *  \n *  Parameters:\n *\n *\ttheHost:  //需要被解决的CFHostRef的对象\n *\t  The CFHostRef which should be resolved. Must be non-NULL. If\n *\t  this reference is not a valid CFHostRef, the behavior is\n *\t  undefined.\n *\n *\tinfo: 返回值的类型 数组/Data/string..\n *\t  The enum representing the type of information to be retrieved.\n *\t  If the value is not a valid type, the behavior is undefined.\n *\n *\terror: 错误\n *\t  A reference to a CFStreamError structure which will be filled\n *\t  with any error information should an error occur.  May be set\n *\t  to NULL if error information is not wanted.\n *  \n *  Result: 解析结果成功还是失败\n *\tReturns TRUE on success and FALSE on failure.  In asynchronous\n *\tmode, this function will return immediately.  In synchronous\n *\tmode, it will block until the resolve has completed or until the\n *\tresolve is cancelled.\n *  \n */\nCFN_EXPORT __nullable CFArrayRef\nCFHostGetAddressing(CFHostRef theHost, Boolean * __nullable hasBeenResolved) CF_AVAILABLE(10_3, 2_0);\n```\n###### 优点：\n* 在网络切换时候不会卡顿。\n###### 缺点：\n* 在本地DNS被破坏的情况下会出现卡死的现象(卡30s)\n### 总结：\n以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地LocalDns破坏会卡死的问题看来是无法避免，不过开发者可以自行通过ping等方式来判断LocalDns的正确性，在被破坏的情况下使用httpDns来进行解析即可。具体的demo可以到[这里](https://github.com/zhangninghao/LocalDns)查看\n","slug":"IOS下三种DNS解析方式分析（LocalDns）","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2k80000a04w8pavn7z6","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近在做iOS的DNS解析，顺便研究了下iOS端本地的DNS解析方式（localDNS）,也就是不依赖Http请求，而是用原始的API进行解析，虽然有HttpDNS但是考虑到成本、第三方服务稳定性的问题，LocalDNS仍然是一个很重要的部分，在iOS系统下，localDNS的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。</p>\n<h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>这个也是我一开始在项目中使用的方式。<br><figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>：<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span>\t*gethostbyname(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span> *);</span><br><span class=\"line\"><span class=\"number\">2</span>：<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span>\t*gethostbyname2(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span> *, int);</span><br></pre></td></tr></table></figure></p>\n<p>两个函数作用完全一样，返回值一样，但是第一个只能用于IPV4的网络环境，而第二个则IPV4和IPV6都可使用，可以通过第二个参数传入当前的网络环境。<br><a id=\"more\"></a></p>\n<h6 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">char</span>   *ptr, **pptr;</span><br><span class=\"line\">   <span class=\"keyword\">struct</span> hostent *hptr;</span><br><span class=\"line\">   <span class=\"keyword\">char</span>   str[<span class=\"number\">32</span>];</span><br><span class=\"line\">   ptr = <span class=\"string\">\"www.meitu.com\"</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSMutableArray</span> * ips = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hptr = gethostbyname(ptr)) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(pptr=hptr-&gt;h_addr_list; *pptr!=<span class=\"literal\">NULL</span>; pptr++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * ipStr = [<span class=\"built_in\">NSString</span> stringWithCString:inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class=\"keyword\">sizeof</span>(str)) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">        [ips addObject:ipStr?:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"22222 === ip === %@ === time cost: %0.3fs\"</span>, ips,end - start);</span><br></pre></td></tr></table></figure>\n<p>使用gethostbyname方法后会得到一个struct,也就是上文的struct hostent *hptr：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>\t*h_name;\t<span class=\"comment\">/* official name of host */</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>\t**h_aliases;\t<span class=\"comment\">/* alias list */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\th_addrtype;\t<span class=\"comment\">/* host address type */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\th_length;\t<span class=\"comment\">/* length of address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>\t**h_addr_list;\t<span class=\"comment\">/* list of addresses from name server */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>\th_addr\th_addr_list[0]\t<span class=\"comment\">/* address, for backward compatibility */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析：\"><a href=\"#参数解析：\" class=\"headerlink\" title=\"参数解析：\"></a>参数解析：</h6><ul>\n<li><p>hostent-&gt;h_name<br>表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。</p>\n</li>\n<li><p>hostent-&gt;h_aliases<br>表示的是主机的别名www.baidu.com的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。</p>\n</li>\n<li><p>hostent-&gt;h_addrtype<br>表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)</p>\n</li>\n<li><p>hostent-&gt;h_length<br>表示的是主机ip地址的长度</p>\n</li>\n<li><p>hostent-&gt;h_addr_lisst<br>表示的是主机的ip地址，注意，这个是以网络字节序存储的。不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用<code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt)</code>，来把它转成char。详细使用见上文</p>\n<h6 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h6><ul>\n<li>在进行网络切换的时候小概率卡死，自测十次有一两次左右。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>在本地的LocalDns被破坏的时候会必卡死30秒，然后返回nil 。</p>\n</li>\n<li><p>缓存是个玄学东西，他会对自己解析出来的IP进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的IP，</p>\n</li>\n<li><p>网上说的比较多的问题</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6myoq10ej30po01w0tb.jpg\" alt=\"image.png\"></p>\n</li>\n</ul>\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>除了经常用到的gethostbyname(3)和gethostbyaddr(3)函数以外, Linux(以及其它UNIX/UNIX-like系统)还提供了一套用于在底层处理DNS相关问题的函数(这里所说的底层仅是相对gethostbyname和gethostbyaddr两个函数而言). 这套函数被称为地址解析函数(resolver functions)。曾经尝试过这个方式…<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>\t\tres_query __P((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>, u_char *, <span class=\"keyword\">int</span>));</span><br><span class=\"line\">函数原型为：</span><br><span class=\"line\"><span class=\"keyword\">int</span> res_query(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *dname, <span class=\"keyword\">int</span> <span class=\"keyword\">class</span>, <span class=\"keyword\">int</span> type, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *answer, <span class=\"keyword\">int</span> anslen)</span><br></pre></td></tr></table></figure></p>\n<p>这个方式需要在项目中添加<code>libresolv.tbd</code>库，因为要依赖于库中的函数去解析。<code>res_query</code>用来发出一个指定类(由参数class指定)和类型(由参数type指定)的DNS询问. dname是要查询的主机名. 返回信息被存储在answser指向的内存区域中. 信息的长度不能大于anslen个字节. 这个函数会创建一个DNS查询报文并把它发送到指定的DNS服务器。</p>\n<h6 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> auResult[<span class=\"number\">512</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    nBytesRead = res_query(<span class=\"string\">\"www.meitu.com\"</span>, ns_c_in, ns_t_a, auResult, <span class=\"keyword\">sizeof</span>(auResult));</span><br><span class=\"line\"></span><br><span class=\"line\">    ns_msg handle;</span><br><span class=\"line\">    ns_initparse(auResult, nBytesRead, &amp;handle);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *ipList = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg_count = ns_msg_count(handle, ns_s_an);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg_count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ipList = [[<span class=\"built_in\">NSMutableArray</span> alloc] initWithCapacity:msg_count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> rrnum = <span class=\"number\">0</span>; rrnum &lt; msg_count; rrnum++) &#123;</span><br><span class=\"line\">            ns_rr rr;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ns_parserr(&amp;handle, ns_s_an, rrnum, &amp;rr) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> ip1[<span class=\"number\">16</span>];</span><br><span class=\"line\">                strcpy(ip1, inet_ntoa(*(<span class=\"keyword\">struct</span> in_addr *)ns_rr_rdata(rr)));</span><br><span class=\"line\">                <span class=\"built_in\">NSString</span> *ipString = [[<span class=\"built_in\">NSString</span> alloc] initWithCString:ip1 encoding:<span class=\"built_in\">NSASCIIStringEncoding</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (![ipString isEqualToString:<span class=\"string\">@\"\"</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//将提取到的IP地址放到数组中</span></span><br><span class=\"line\">                    [ipList addObject:ipString];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"11111 === ip === %@ === time cost: %0.3fs\"</span>, ipList,end - start);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h6><p>由于该逻辑是Linux底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对Linux内核的理解，这里放一篇<a href=\"https://www.cnblogs.com/renhao/archive/2011/11/14/2248528.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h6 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h6><ul>\n<li>在LocalDns被破坏掉的情况下能及时响应不会延迟。</li>\n<li>没有缓存，缓存由开发者控制<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6></li>\n<li>在进行网络切换时候3G/4G切wify高概率出现卡死<br>这一个缺点是比较致命的，所以没有再继续使用。</li>\n</ul>\n<h3 id=\"方式三\"><a href=\"#方式三\" class=\"headerlink\" title=\"方式三\"></a>方式三</h3><p>苹果原生的DNS解析</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">Boolean <span class=\"built_in\">CFHostStartInfoResolution</span> (<span class=\"built_in\">CFHostRef</span> theHost, <span class=\"built_in\">CFHostInfoType</span> info, <span class=\"built_in\">CFStreamError</span> *error);</span><br></pre></td></tr></table></figure>\n<h6 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">Boolean result,bResolved;</span><br><span class=\"line\"><span class=\"built_in\">CFHostRef</span> hostRef;</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> addresses = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> * ipsArr = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFStringRef</span> hostNameRef = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllocatorDefault, <span class=\"string\">\"www.meitu.com\"</span>, kCFStringEncodingASCII);</span><br><span class=\"line\"></span><br><span class=\"line\">hostRef = <span class=\"built_in\">CFHostCreateWithName</span>(kCFAllocatorDefault, hostNameRef);</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">result = <span class=\"built_in\">CFHostStartInfoResolution</span>(hostRef, kCFHostAddresses, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"literal\">TRUE</span>) &#123;</span><br><span class=\"line\">    addresses = <span class=\"built_in\">CFHostGetAddressing</span>(hostRef, &amp;result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bResolved = result == <span class=\"literal\">TRUE</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(bResolved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> sockaddr_in* remoteAddr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">CFArrayGetCount</span>(addresses); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFDataRef</span> saData = (<span class=\"built_in\">CFDataRef</span>)<span class=\"built_in\">CFArrayGetValueAtIndex</span>(addresses, i);</span><br><span class=\"line\">        remoteAddr = (<span class=\"keyword\">struct</span> sockaddr_in*)<span class=\"built_in\">CFDataGetBytePtr</span>(saData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(remoteAddr != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取IP地址</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> ip[<span class=\"number\">16</span>];</span><br><span class=\"line\">            strcpy(ip, inet_ntoa(remoteAddr-&gt;sin_addr));</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> * ipStr = [<span class=\"built_in\">NSString</span> stringWithCString:ip encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">            [ipsArr addObject:ipStr];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"33333 === ip === %@ === time cost: %0.3fs\"</span>, ipsArr,end - start);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(hostNameRef);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(hostRef);</span><br></pre></td></tr></table></figure>\n<h6 id=\"参数解析：-1\"><a href=\"#参数解析：-1\" class=\"headerlink\" title=\"参数解析：\"></a>参数解析：</h6><figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  CFHostStartInfoResolution()</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Discussion:</span><br><span class=\"line\"> *\tPerforms a lookup <span class=\"keyword\">for</span> the given host.  It will search <span class=\"keyword\">for</span> the</span><br><span class=\"line\"> *\trequested information <span class=\"keyword\">if</span> there <span class=\"keyword\">is</span> no other active request.</span><br><span class=\"line\"> *\tPreviously cached information <span class=\"keyword\">of</span> the given <span class=\"keyword\">type</span> <span class=\"type\">will </span>be released.</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Mac OS X threading:</span><br><span class=\"line\"> *\tThread safe</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Parameters:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *\ttheHost:  //需要被解决的CFHostRef的对象</span><br><span class=\"line\"> *\t  The CFHostRef which should be resolved. Must be non-NULL. <span class=\"keyword\">If</span></span><br><span class=\"line\"> *\t  this reference <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> a valid CFHostRef, the behavior <span class=\"keyword\">is</span></span><br><span class=\"line\"> *\t  undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *\tinfo: 返回值的类型 数组/Data/string..</span><br><span class=\"line\"> *\t  The enum representing the <span class=\"keyword\">type</span> <span class=\"type\">of </span>information to be retrieved.</span><br><span class=\"line\"> *\t  <span class=\"keyword\">If</span> the value <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> a valid <span class=\"keyword\">type</span>, the behavior <span class=\"keyword\">is</span> undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *\terror: 错误</span><br><span class=\"line\"> *\t  A reference to a CFStreamError structure which will be filled</span><br><span class=\"line\"> *\t  <span class=\"keyword\">with</span> any error information should an error occur.  May be set</span><br><span class=\"line\"> *\t  to NULL <span class=\"keyword\">if</span> error information <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> wanted.</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Result: 解析结果成功还是失败</span><br><span class=\"line\"> *\tReturns <span class=\"literal\">TRUE</span> on success <span class=\"keyword\">and</span> <span class=\"literal\">FALSE</span> on failure.  <span class=\"keyword\">In</span> asynchronous</span><br><span class=\"line\"> *\tmode, this <span class=\"keyword\">function</span> <span class=\"title\">will</span> <span class=\"keyword\">return</span> <span class=\"type\">immediately.</span>  <span class=\"keyword\">In</span> synchronous</span><br><span class=\"line\"> *\tmode, it will block until the resolve has completed <span class=\"keyword\">or</span> until the</span><br><span class=\"line\"> *\tresolve <span class=\"keyword\">is</span> cancelled.</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> */</span><br><span class=\"line\">CFN_EXPORT __nullable CFArrayRef</span><br><span class=\"line\">CFHostGetAddressing(CFHostRef theHost, Boolean * __nullable hasBeenResolved) CF_AVAILABLE(<span class=\"number\">10_3</span>, <span class=\"number\">2_0</span>);</span><br></pre></td></tr></table></figure>\n<h6 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h6><ul>\n<li>在网络切换时候不会卡顿。<h6 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h6></li>\n<li>在本地DNS被破坏的情况下会出现卡死的现象(卡30s)<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3>以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地LocalDns破坏会卡死的问题看来是无法避免，不过开发者可以自行通过ping等方式来判断LocalDns的正确性，在被破坏的情况下使用httpDns来进行解析即可。具体的demo可以到<a href=\"https://github.com/zhangninghao/LocalDns\" target=\"_blank\" rel=\"noopener\">这里</a>查看</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近在做iOS的DNS解析，顺便研究了下iOS端本地的DNS解析方式（localDNS）,也就是不依赖Http请求，而是用原始的API进行解析，虽然有HttpDNS但是考虑到成本、第三方服务稳定性的问题，LocalDNS仍然是一个很重要的部分，在iOS系统下，localDNS的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。</p>\n<h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>这个也是我一开始在项目中使用的方式。<br><figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>：<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span>\t*gethostbyname(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span> *);</span><br><span class=\"line\"><span class=\"number\">2</span>：<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span>\t*gethostbyname2(<span class=\"keyword\">const</span> <span class=\"built_in\">char</span> *, int);</span><br></pre></td></tr></table></figure></p>\n<p>两个函数作用完全一样，返回值一样，但是第一个只能用于IPV4的网络环境，而第二个则IPV4和IPV6都可使用，可以通过第二个参数传入当前的网络环境。<br>","more":"</p>\n<h6 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">char</span>   *ptr, **pptr;</span><br><span class=\"line\">   <span class=\"keyword\">struct</span> hostent *hptr;</span><br><span class=\"line\">   <span class=\"keyword\">char</span>   str[<span class=\"number\">32</span>];</span><br><span class=\"line\">   ptr = <span class=\"string\">\"www.meitu.com\"</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSMutableArray</span> * ips = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((hptr = gethostbyname(ptr)) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(pptr=hptr-&gt;h_addr_list; *pptr!=<span class=\"literal\">NULL</span>; pptr++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * ipStr = [<span class=\"built_in\">NSString</span> stringWithCString:inet_ntop(hptr-&gt;h_addrtype, *pptr, str, <span class=\"keyword\">sizeof</span>(str)) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">        [ips addObject:ipStr?:<span class=\"string\">@\"\"</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"22222 === ip === %@ === time cost: %0.3fs\"</span>, ips,end - start);</span><br></pre></td></tr></table></figure>\n<p>使用gethostbyname方法后会得到一个struct,也就是上文的struct hostent *hptr：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>\t*h_name;\t<span class=\"comment\">/* official name of host */</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>\t**h_aliases;\t<span class=\"comment\">/* alias list */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\th_addrtype;\t<span class=\"comment\">/* host address type */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\th_length;\t<span class=\"comment\">/* length of address */</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>\t**h_addr_list;\t<span class=\"comment\">/* list of addresses from name server */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>\th_addr\th_addr_list[0]\t<span class=\"comment\">/* address, for backward compatibility */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"参数解析：\"><a href=\"#参数解析：\" class=\"headerlink\" title=\"参数解析：\"></a>参数解析：</h6><ul>\n<li><p>hostent-&gt;h_name<br>表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。</p>\n</li>\n<li><p>hostent-&gt;h_aliases<br>表示的是主机的别名www.baidu.com的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。</p>\n</li>\n<li><p>hostent-&gt;h_addrtype<br>表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)</p>\n</li>\n<li><p>hostent-&gt;h_length<br>表示的是主机ip地址的长度</p>\n</li>\n<li><p>hostent-&gt;h_addr_lisst<br>表示的是主机的ip地址，注意，这个是以网络字节序存储的。不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用<code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt)</code>，来把它转成char。详细使用见上文</p>\n<h6 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h6><ul>\n<li>在进行网络切换的时候小概率卡死，自测十次有一两次左右。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>在本地的LocalDns被破坏的时候会必卡死30秒，然后返回nil 。</p>\n</li>\n<li><p>缓存是个玄学东西，他会对自己解析出来的IP进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的IP，</p>\n</li>\n<li><p>网上说的比较多的问题</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6myoq10ej30po01w0tb.jpg\" alt=\"image.png\"></p>\n</li>\n</ul>\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>除了经常用到的gethostbyname(3)和gethostbyaddr(3)函数以外, Linux(以及其它UNIX/UNIX-like系统)还提供了一套用于在底层处理DNS相关问题的函数(这里所说的底层仅是相对gethostbyname和gethostbyaddr两个函数而言). 这套函数被称为地址解析函数(resolver functions)。曾经尝试过这个方式…<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>\t\tres_query __P((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>, u_char *, <span class=\"keyword\">int</span>));</span><br><span class=\"line\">函数原型为：</span><br><span class=\"line\"><span class=\"keyword\">int</span> res_query(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *dname, <span class=\"keyword\">int</span> <span class=\"keyword\">class</span>, <span class=\"keyword\">int</span> type, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *answer, <span class=\"keyword\">int</span> anslen)</span><br></pre></td></tr></table></figure></p>\n<p>这个方式需要在项目中添加<code>libresolv.tbd</code>库，因为要依赖于库中的函数去解析。<code>res_query</code>用来发出一个指定类(由参数class指定)和类型(由参数type指定)的DNS询问. dname是要查询的主机名. 返回信息被存储在answser指向的内存区域中. 信息的长度不能大于anslen个字节. 这个函数会创建一个DNS查询报文并把它发送到指定的DNS服务器。</p>\n<h6 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> auResult[<span class=\"number\">512</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    nBytesRead = res_query(<span class=\"string\">\"www.meitu.com\"</span>, ns_c_in, ns_t_a, auResult, <span class=\"keyword\">sizeof</span>(auResult));</span><br><span class=\"line\"></span><br><span class=\"line\">    ns_msg handle;</span><br><span class=\"line\">    ns_initparse(auResult, nBytesRead, &amp;handle);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *ipList = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg_count = ns_msg_count(handle, ns_s_an);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg_count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ipList = [[<span class=\"built_in\">NSMutableArray</span> alloc] initWithCapacity:msg_count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> rrnum = <span class=\"number\">0</span>; rrnum &lt; msg_count; rrnum++) &#123;</span><br><span class=\"line\">            ns_rr rr;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ns_parserr(&amp;handle, ns_s_an, rrnum, &amp;rr) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> ip1[<span class=\"number\">16</span>];</span><br><span class=\"line\">                strcpy(ip1, inet_ntoa(*(<span class=\"keyword\">struct</span> in_addr *)ns_rr_rdata(rr)));</span><br><span class=\"line\">                <span class=\"built_in\">NSString</span> *ipString = [[<span class=\"built_in\">NSString</span> alloc] initWithCString:ip1 encoding:<span class=\"built_in\">NSASCIIStringEncoding</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (![ipString isEqualToString:<span class=\"string\">@\"\"</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//将提取到的IP地址放到数组中</span></span><br><span class=\"line\">                    [ipList addObject:ipString];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"11111 === ip === %@ === time cost: %0.3fs\"</span>, ipList,end - start);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h6><p>由于该逻辑是Linux底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对Linux内核的理解，这里放一篇<a href=\"https://www.cnblogs.com/renhao/archive/2011/11/14/2248528.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h6 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h6><ul>\n<li>在LocalDns被破坏掉的情况下能及时响应不会延迟。</li>\n<li>没有缓存，缓存由开发者控制<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6></li>\n<li>在进行网络切换时候3G/4G切wify高概率出现卡死<br>这一个缺点是比较致命的，所以没有再继续使用。</li>\n</ul>\n<h3 id=\"方式三\"><a href=\"#方式三\" class=\"headerlink\" title=\"方式三\"></a>方式三</h3><p>苹果原生的DNS解析</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">Boolean <span class=\"built_in\">CFHostStartInfoResolution</span> (<span class=\"built_in\">CFHostRef</span> theHost, <span class=\"built_in\">CFHostInfoType</span> info, <span class=\"built_in\">CFStreamError</span> *error);</span><br></pre></td></tr></table></figure>\n<h6 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">Boolean result,bResolved;</span><br><span class=\"line\"><span class=\"built_in\">CFHostRef</span> hostRef;</span><br><span class=\"line\"><span class=\"built_in\">CFArrayRef</span> addresses = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> * ipsArr = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFStringRef</span> hostNameRef = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllocatorDefault, <span class=\"string\">\"www.meitu.com\"</span>, kCFStringEncodingASCII);</span><br><span class=\"line\"></span><br><span class=\"line\">hostRef = <span class=\"built_in\">CFHostCreateWithName</span>(kCFAllocatorDefault, hostNameRef);</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">result = <span class=\"built_in\">CFHostStartInfoResolution</span>(hostRef, kCFHostAddresses, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (result == <span class=\"literal\">TRUE</span>) &#123;</span><br><span class=\"line\">    addresses = <span class=\"built_in\">CFHostGetAddressing</span>(hostRef, &amp;result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bResolved = result == <span class=\"literal\">TRUE</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(bResolved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> sockaddr_in* remoteAddr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">CFArrayGetCount</span>(addresses); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFDataRef</span> saData = (<span class=\"built_in\">CFDataRef</span>)<span class=\"built_in\">CFArrayGetValueAtIndex</span>(addresses, i);</span><br><span class=\"line\">        remoteAddr = (<span class=\"keyword\">struct</span> sockaddr_in*)<span class=\"built_in\">CFDataGetBytePtr</span>(saData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(remoteAddr != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取IP地址</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> ip[<span class=\"number\">16</span>];</span><br><span class=\"line\">            strcpy(ip, inet_ntoa(remoteAddr-&gt;sin_addr));</span><br><span class=\"line\">            <span class=\"built_in\">NSString</span> * ipStr = [<span class=\"built_in\">NSString</span> stringWithCString:ip encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">            [ipsArr addObject:ipStr];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"33333 === ip === %@ === time cost: %0.3fs\"</span>, ipsArr,end - start);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(hostNameRef);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(hostRef);</span><br></pre></td></tr></table></figure>\n<h6 id=\"参数解析：-1\"><a href=\"#参数解析：-1\" class=\"headerlink\" title=\"参数解析：\"></a>参数解析：</h6><figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  CFHostStartInfoResolution()</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Discussion:</span><br><span class=\"line\"> *\tPerforms a lookup <span class=\"keyword\">for</span> the given host.  It will search <span class=\"keyword\">for</span> the</span><br><span class=\"line\"> *\trequested information <span class=\"keyword\">if</span> there <span class=\"keyword\">is</span> no other active request.</span><br><span class=\"line\"> *\tPreviously cached information <span class=\"keyword\">of</span> the given <span class=\"keyword\">type</span> <span class=\"type\">will </span>be released.</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Mac OS X threading:</span><br><span class=\"line\"> *\tThread safe</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Parameters:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *\ttheHost:  //需要被解决的CFHostRef的对象</span><br><span class=\"line\"> *\t  The CFHostRef which should be resolved. Must be non-NULL. <span class=\"keyword\">If</span></span><br><span class=\"line\"> *\t  this reference <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> a valid CFHostRef, the behavior <span class=\"keyword\">is</span></span><br><span class=\"line\"> *\t  undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *\tinfo: 返回值的类型 数组/Data/string..</span><br><span class=\"line\"> *\t  The enum representing the <span class=\"keyword\">type</span> <span class=\"type\">of </span>information to be retrieved.</span><br><span class=\"line\"> *\t  <span class=\"keyword\">If</span> the value <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> a valid <span class=\"keyword\">type</span>, the behavior <span class=\"keyword\">is</span> undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *\terror: 错误</span><br><span class=\"line\"> *\t  A reference to a CFStreamError structure which will be filled</span><br><span class=\"line\"> *\t  <span class=\"keyword\">with</span> any error information should an error occur.  May be set</span><br><span class=\"line\"> *\t  to NULL <span class=\"keyword\">if</span> error information <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> wanted.</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> *  Result: 解析结果成功还是失败</span><br><span class=\"line\"> *\tReturns <span class=\"literal\">TRUE</span> on success <span class=\"keyword\">and</span> <span class=\"literal\">FALSE</span> on failure.  <span class=\"keyword\">In</span> asynchronous</span><br><span class=\"line\"> *\tmode, this <span class=\"keyword\">function</span> <span class=\"title\">will</span> <span class=\"keyword\">return</span> <span class=\"type\">immediately.</span>  <span class=\"keyword\">In</span> synchronous</span><br><span class=\"line\"> *\tmode, it will block until the resolve has completed <span class=\"keyword\">or</span> until the</span><br><span class=\"line\"> *\tresolve <span class=\"keyword\">is</span> cancelled.</span><br><span class=\"line\"> *  </span><br><span class=\"line\"> */</span><br><span class=\"line\">CFN_EXPORT __nullable CFArrayRef</span><br><span class=\"line\">CFHostGetAddressing(CFHostRef theHost, Boolean * __nullable hasBeenResolved) CF_AVAILABLE(<span class=\"number\">10_3</span>, <span class=\"number\">2_0</span>);</span><br></pre></td></tr></table></figure>\n<h6 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h6><ul>\n<li>在网络切换时候不会卡顿。<h6 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h6></li>\n<li>在本地DNS被破坏的情况下会出现卡死的现象(卡30s)<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3>以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地LocalDns破坏会卡死的问题看来是无法避免，不过开发者可以自行通过ping等方式来判断LocalDns的正确性，在被破坏的情况下使用httpDns来进行解析即可。具体的demo可以到<a href=\"https://github.com/zhangninghao/LocalDns\" target=\"_blank\" rel=\"noopener\">这里</a>查看</li>\n</ul>"},{"title":"在iOS11下app图标变空白的问题解决","date":"2018-01-23T10:07:50.000Z","comments":1,"_content":"## 背景：\n\n最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有iPhone X，然后就是iPhone 8，慢慢的变成不管是模拟器还是真机，所有iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。\n<!--more-->\n\n## 尝试：\n\n1：一开始想到的是可能有人误改了图标文件，于是删除了images.xcassest中的AppIcon文件，从新生成→添加图标，但是依然未解决。（✘）\n\n2：想到是图片格式/尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘）\n\n3：因为设置图标的方法除了在images.xcassest中的AppIcon文件中设置还可以在info.plist设置、或者直接在工程里面放一个icon.png的图片来设\n\n置，所以都检查了一便发现也不是这个原因（✘）\n\n3：重置手机。(✘)\n\n## 解决：\n\ngoogle了下发现好多国外的开发遇到这个问题，并且都是使用xcode9.X.X版本，所以怀疑是苹果的BUG\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mw7fbitj30yg0b0dip.jpg)\n\n不过这个问题并不是谁都会出现也不是所有使用xcode9 + iOS11的设备都会出现\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mwjg45nj30yg09kq41.jpg)\n\n\n后来经过大家的讨论终于有人说这个其实是cocoapods的BUG，暂时并不能通过更新cocoapods更新来解决，因为最新版的cocoapods\n\n也存在这个问题，解决方法如下：\n\n![image.png](https://ws1.sinaimg.cn/large/006tNc79gy1fo6mwrgqg2j30yg0bqdl4.jpg)\n\n\n在你的podfile中加入以下代码就可以了\n\n```\npost_install do |installer|\n    copy_pods_resources_path = \"Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh\"\n    string_to_replace = '--compile \"${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}\"'\n    assets_compile_with_app_icon_arguments = '--compile \"${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}\" --app-icon \"${ASSETCATALOG_COMPILER_APPICON_NAME}\" --output-partial-info-plist \"${BUILD_DIR}/assetcatalog_generated_info.plist\"'\n    text = File.read(copy_pods_resources_path)\n    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)\n    File.open(copy_pods_resources_path, \"w\") {|file| file.puts new_contents }\nend\n```\n\n像这样：\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6mx84vaxj30yg07f42t.jpg)\n","source":"_posts/2018-01-23-在iOS11下app图标变空白的问题解决.md","raw":"---\ntitle: 在iOS11下app图标变空白的问题解决\ndate: 2018-01-23 18:07:50\ntags:\n - xcode\n - cocoapods\n - podfile\ncategories: iOS开发\ncomments:\n---\n## 背景：\n\n最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有iPhone X，然后就是iPhone 8，慢慢的变成不管是模拟器还是真机，所有iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。\n<!--more-->\n\n## 尝试：\n\n1：一开始想到的是可能有人误改了图标文件，于是删除了images.xcassest中的AppIcon文件，从新生成→添加图标，但是依然未解决。（✘）\n\n2：想到是图片格式/尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘）\n\n3：因为设置图标的方法除了在images.xcassest中的AppIcon文件中设置还可以在info.plist设置、或者直接在工程里面放一个icon.png的图片来设\n\n置，所以都检查了一便发现也不是这个原因（✘）\n\n3：重置手机。(✘)\n\n## 解决：\n\ngoogle了下发现好多国外的开发遇到这个问题，并且都是使用xcode9.X.X版本，所以怀疑是苹果的BUG\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mw7fbitj30yg0b0dip.jpg)\n\n不过这个问题并不是谁都会出现也不是所有使用xcode9 + iOS11的设备都会出现\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mwjg45nj30yg09kq41.jpg)\n\n\n后来经过大家的讨论终于有人说这个其实是cocoapods的BUG，暂时并不能通过更新cocoapods更新来解决，因为最新版的cocoapods\n\n也存在这个问题，解决方法如下：\n\n![image.png](https://ws1.sinaimg.cn/large/006tNc79gy1fo6mwrgqg2j30yg0bqdl4.jpg)\n\n\n在你的podfile中加入以下代码就可以了\n\n```\npost_install do |installer|\n    copy_pods_resources_path = \"Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh\"\n    string_to_replace = '--compile \"${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}\"'\n    assets_compile_with_app_icon_arguments = '--compile \"${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}\" --app-icon \"${ASSETCATALOG_COMPILER_APPICON_NAME}\" --output-partial-info-plist \"${BUILD_DIR}/assetcatalog_generated_info.plist\"'\n    text = File.read(copy_pods_resources_path)\n    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)\n    File.open(copy_pods_resources_path, \"w\") {|file| file.puts new_contents }\nend\n```\n\n像这样：\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6mx84vaxj30yg07f42t.jpg)\n","slug":"在iOS11下app图标变空白的问题解决","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2kf0002a04wpvronjp2","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有iPhone X，然后就是iPhone 8，慢慢的变成不管是模拟器还是真机，所有iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。<br><a id=\"more\"></a></p>\n<h2 id=\"尝试：\"><a href=\"#尝试：\" class=\"headerlink\" title=\"尝试：\"></a>尝试：</h2><p>1：一开始想到的是可能有人误改了图标文件，于是删除了images.xcassest中的AppIcon文件，从新生成→添加图标，但是依然未解决。（✘）</p>\n<p>2：想到是图片格式/尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘）</p>\n<p>3：因为设置图标的方法除了在images.xcassest中的AppIcon文件中设置还可以在info.plist设置、或者直接在工程里面放一个icon.png的图片来设</p>\n<p>置，所以都检查了一便发现也不是这个原因（✘）</p>\n<p>3：重置手机。(✘)</p>\n<h2 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h2><p>google了下发现好多国外的开发遇到这个问题，并且都是使用xcode9.X.X版本，所以怀疑是苹果的BUG</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mw7fbitj30yg0b0dip.jpg\" alt=\"image.png\"></p>\n<p>不过这个问题并不是谁都会出现也不是所有使用xcode9 + iOS11的设备都会出现</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mwjg45nj30yg09kq41.jpg\" alt=\"image.png\"></p>\n<p>后来经过大家的讨论终于有人说这个其实是cocoapods的BUG，暂时并不能通过更新cocoapods更新来解决，因为最新版的cocoapods</p>\n<p>也存在这个问题，解决方法如下：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6mwrgqg2j30yg0bqdl4.jpg\" alt=\"image.png\"></p>\n<p>在你的podfile中加入以下代码就可以了</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">post_install do |installer|</span><br><span class=\"line\">    <span class=\"attr\">copy_pods_resources_path</span> = <span class=\"string\">\"Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh\"</span></span><br><span class=\"line\">    <span class=\"attr\">string_to_replace</span> = '--compile <span class=\"string\">\"<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>\"</span>'</span><br><span class=\"line\">    <span class=\"attr\">assets_compile_with_app_icon_arguments</span> = '--compile <span class=\"string\">\"<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>\"</span> --app-icon <span class=\"string\">\"<span class=\"subst\">$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;</span>\"</span> --output-partial-info-plist <span class=\"string\">\"<span class=\"subst\">$&#123;BUILD_DIR&#125;</span>/assetcatalog_generated_info.plist\"</span>'</span><br><span class=\"line\">    <span class=\"attr\">text</span> = File.read(copy_pods_resources_path)</span><br><span class=\"line\">    <span class=\"attr\">new_contents</span> = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)</span><br><span class=\"line\">    File.open(copy_pods_resources_path, <span class=\"string\">\"w\"</span>) &#123;|file| file.puts new_contents &#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>像这样：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6mx84vaxj30yg07f42t.jpg\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有iPhone X，然后就是iPhone 8，慢慢的变成不管是模拟器还是真机，所有iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。<br>","more":"</p>\n<h2 id=\"尝试：\"><a href=\"#尝试：\" class=\"headerlink\" title=\"尝试：\"></a>尝试：</h2><p>1：一开始想到的是可能有人误改了图标文件，于是删除了images.xcassest中的AppIcon文件，从新生成→添加图标，但是依然未解决。（✘）</p>\n<p>2：想到是图片格式/尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘）</p>\n<p>3：因为设置图标的方法除了在images.xcassest中的AppIcon文件中设置还可以在info.plist设置、或者直接在工程里面放一个icon.png的图片来设</p>\n<p>置，所以都检查了一便发现也不是这个原因（✘）</p>\n<p>3：重置手机。(✘)</p>\n<h2 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h2><p>google了下发现好多国外的开发遇到这个问题，并且都是使用xcode9.X.X版本，所以怀疑是苹果的BUG</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mw7fbitj30yg0b0dip.jpg\" alt=\"image.png\"></p>\n<p>不过这个问题并不是谁都会出现也不是所有使用xcode9 + iOS11的设备都会出现</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mwjg45nj30yg09kq41.jpg\" alt=\"image.png\"></p>\n<p>后来经过大家的讨论终于有人说这个其实是cocoapods的BUG，暂时并不能通过更新cocoapods更新来解决，因为最新版的cocoapods</p>\n<p>也存在这个问题，解决方法如下：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6mwrgqg2j30yg0bqdl4.jpg\" alt=\"image.png\"></p>\n<p>在你的podfile中加入以下代码就可以了</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">post_install do |installer|</span><br><span class=\"line\">    <span class=\"attr\">copy_pods_resources_path</span> = <span class=\"string\">\"Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh\"</span></span><br><span class=\"line\">    <span class=\"attr\">string_to_replace</span> = '--compile <span class=\"string\">\"<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>\"</span>'</span><br><span class=\"line\">    <span class=\"attr\">assets_compile_with_app_icon_arguments</span> = '--compile <span class=\"string\">\"<span class=\"subst\">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class=\"subst\">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>\"</span> --app-icon <span class=\"string\">\"<span class=\"subst\">$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;</span>\"</span> --output-partial-info-plist <span class=\"string\">\"<span class=\"subst\">$&#123;BUILD_DIR&#125;</span>/assetcatalog_generated_info.plist\"</span>'</span><br><span class=\"line\">    <span class=\"attr\">text</span> = File.read(copy_pods_resources_path)</span><br><span class=\"line\">    <span class=\"attr\">new_contents</span> = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)</span><br><span class=\"line\">    File.open(copy_pods_resources_path, <span class=\"string\">\"w\"</span>) &#123;|file| file.puts new_contents &#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>像这样：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6mx84vaxj30yg07f42t.jpg\" alt=\"image.png\"></p>"},{"title":"CFNetwork的介绍和使用","date":"2018-01-23T13:04:15.000Z","comments":1,"_content":"### CFNetwork背景简介\nCFNetwork是ISO中一个比较底层的网络框架，C语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket通讯等，我们通常使用的NSURL则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。CFNetwork已经接近于UNIX系统的socket通信了，使用CFHttpMessageRef进行HTTP连接的好处就是控制的粒度更细了，例如你可以设置SSL连接的PeerName，证书验证的方式，还可以控制每个响应包的接收。不过CFNetwork本质上还是应用层上的封装的通用API。使用者可以不用关心底层协议的实际细节。下图是CFNetwork在iOS系统中的位置(图片来源于官方文档)。\n\n<!--more-->\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg)\n\n由上图可以看出目前iOS的网络编程分四层：\n* WebKit：属于Cocoa层，苹果很多地方用到的页面渲染引擎WKWebview；\n\n* NSURL：也属于Cocoa层，对各类URL请求的封装(NSURLRequest)；\n\n* CFNetwork：属于Core Foundation层，基于C的封装，同样的还有CFNetServices(write/readstream)；\n\n* BSD sockets：属于OS层，也是基于C的封装；\n\n### CFNetwork结构\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg)\n上图也是官方文档的图片，描述了CFNetwork的结构，下面逐一讲解。\n\n##### CFSocket API\n\nSocket是网络通讯的底层基础，两个socket端口可以互发数据。我们通常使用的是BSD socket，CFSocket则是BSD socket的抽象，基本上实现了几乎所有BSD socket的功能，并且还融入了run loop。\n\n##### CFStream API\nCFStream API提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用socket）的数据建立stream，我们进行网络请求就是对数据的读写，CFStream提供API对两种CFType对象提供抽象：CFReadStream and CFWriteStream。它同时也是CFHTTP和CFFTP的基础。stream有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样\n\n```\nuint8_t d[1024] = {0};\n//循环条件：流中是否有可用数据(被读过的数据不可用了)\nwhile ([self.inputStream hasBytesAvailable]) {\n    //读取相应长度的数据数据\n    NSInteger len = [self.inputStream read:d maxLength:1024];\n    //如果读取到数据，便将数据快拼接\n    if (len > 0 && !self.inputStream.streamError) {\n        [data appendBytes:(void *)d length:len];\n    } else {\n        break;\n    }\n}\n```\n\n##### CFFTP API\n对用FTP协议通信的封装，能下载、上传文件和目录到FTP服务器。CFFTP建立的连接可以是同步或者异步，此次不做详解。\n\n##### CFHTTP API\n是HTTP协议的抽象，主要对象是CFHTTPMessageRef(类似于我们通常的NSURLRequest)我们需要像构建NSURLRequest那样来构建CFHTTPMessageRef，同样包含一下几个元素\n* 必须元素\n\n   * 请求方法 (类型为CFStringRef)：POST、GET、DELETE等..\n\n   * 请求的URL地址 (类型为CFURLRef)：https://www.baidu.com\n\n   * 请求的HTTP版本(类型为CFStringRef)：通常使用kCFHTTPVersion1_1\n\n   * kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。\n\n* 可选参数\n   * body体(类型为CFDataRef)\n\n```\n\nCFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData) CF_AVAILABLE(10_1, 2_0);\n```\n   * 消息头部，如User-Agent等；\n\n```\nCFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef __nullable value) CF_AVAILABLE(10_1, 2_0);\n\n```\n### CFNetwork请求过程\n##### 1：构造并创建CFHTTPMessageRef对象\n```\n//构造的方式上一步已讲\nCFHTTPMessageCreateRequest(CFAllocatorRef __nullable alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion) CF_AVAILABLE(10_1, 2_0);\n```\n##### 2：使用CFHTTPMessageRef对象创建输入流\n```\n//第一个参数传默认\nCFReadStreamCreateForHTTPRequest(CFAllocatorRef __nullable alloc, CFHTTPMessageRef request) CF_DEPRECATED(10_2, 10_11, 2_0, 9_0, \"Use NSURLSession API for http requests\");\n```\n##### 3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）\n因为配置sni环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理sni，像这样\n```\n[self.inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];\n//请求的URL的Host\nNSDictionary *sslProperties = @{ (__bridge id) kCFStreamSSLPeerName : host };\n[self.inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];\n```\n##### 4：打开输入流\n打开输入流分为两步\n* 设置代理：[self.inputStream setDelegate:weakSelf]\n* 加入当前的runloop：        \n```\n[_inputStream removeFromRunLoop:self.runloop forMode:[self runloopMode]];\n```\n* 调用Open方法\n\n##### 5：收到代理数据回调\n```\n- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;\n```\n其中分为几个状态\n```\ntypedef NS_OPTIONS(NSUInteger, NSStreamEvent) {\n    NSStreamEventNone = 0,\n    NSStreamEventOpenCompleted = 1UL << 0,\n    NSStreamEventHasBytesAvailable = 1UL << 1,\n    NSStreamEventHasSpaceAvailable = 1UL << 2,\n    NSStreamEventErrorOccurred = 1UL << 3,\n    NSStreamEventEndEncountered = 1UL << 4\n};\n```\n通常我们会关心NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、\n由于数据是以流的形式回来，我们需要在在NSStreamEventHasBytesAvailable下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样\n```\n case NSStreamEventHasBytesAvailable:\n{\n    UInt8 buffer[BUFFER_SIZE]; //设置缓存区\n    NSInteger numBytesRead = 0;\n    NSInputStream *inputstream = (NSInputStream *) aStream;\n    // Read data\n    do {\n        numBytesRead = [inputstream read:buffer maxLength:sizeof(buffer)];\n        if (numBytesRead > 0) {\n            [self.resultData appendBytes:buffer length:numBytesRead];\n        }\n    } while (numBytesRead > 0);\n}\nbreak;\n```\n循环结束后我们的resultData就是完整的返回数据了。\n","source":"_posts/2018-01-23-CFNetwork的介绍和使用.md","raw":"---\ntitle: CFNetwork的介绍和使用\ncategories: iOS开发\ndate: 2018-01-23 21:04:15\ntags:\n  - 网络\n  - 底层\ncomments:\n---\n### CFNetwork背景简介\nCFNetwork是ISO中一个比较底层的网络框架，C语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket通讯等，我们通常使用的NSURL则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。CFNetwork已经接近于UNIX系统的socket通信了，使用CFHttpMessageRef进行HTTP连接的好处就是控制的粒度更细了，例如你可以设置SSL连接的PeerName，证书验证的方式，还可以控制每个响应包的接收。不过CFNetwork本质上还是应用层上的封装的通用API。使用者可以不用关心底层协议的实际细节。下图是CFNetwork在iOS系统中的位置(图片来源于官方文档)。\n\n<!--more-->\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg)\n\n由上图可以看出目前iOS的网络编程分四层：\n* WebKit：属于Cocoa层，苹果很多地方用到的页面渲染引擎WKWebview；\n\n* NSURL：也属于Cocoa层，对各类URL请求的封装(NSURLRequest)；\n\n* CFNetwork：属于Core Foundation层，基于C的封装，同样的还有CFNetServices(write/readstream)；\n\n* BSD sockets：属于OS层，也是基于C的封装；\n\n### CFNetwork结构\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg)\n上图也是官方文档的图片，描述了CFNetwork的结构，下面逐一讲解。\n\n##### CFSocket API\n\nSocket是网络通讯的底层基础，两个socket端口可以互发数据。我们通常使用的是BSD socket，CFSocket则是BSD socket的抽象，基本上实现了几乎所有BSD socket的功能，并且还融入了run loop。\n\n##### CFStream API\nCFStream API提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用socket）的数据建立stream，我们进行网络请求就是对数据的读写，CFStream提供API对两种CFType对象提供抽象：CFReadStream and CFWriteStream。它同时也是CFHTTP和CFFTP的基础。stream有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样\n\n```\nuint8_t d[1024] = {0};\n//循环条件：流中是否有可用数据(被读过的数据不可用了)\nwhile ([self.inputStream hasBytesAvailable]) {\n    //读取相应长度的数据数据\n    NSInteger len = [self.inputStream read:d maxLength:1024];\n    //如果读取到数据，便将数据快拼接\n    if (len > 0 && !self.inputStream.streamError) {\n        [data appendBytes:(void *)d length:len];\n    } else {\n        break;\n    }\n}\n```\n\n##### CFFTP API\n对用FTP协议通信的封装，能下载、上传文件和目录到FTP服务器。CFFTP建立的连接可以是同步或者异步，此次不做详解。\n\n##### CFHTTP API\n是HTTP协议的抽象，主要对象是CFHTTPMessageRef(类似于我们通常的NSURLRequest)我们需要像构建NSURLRequest那样来构建CFHTTPMessageRef，同样包含一下几个元素\n* 必须元素\n\n   * 请求方法 (类型为CFStringRef)：POST、GET、DELETE等..\n\n   * 请求的URL地址 (类型为CFURLRef)：https://www.baidu.com\n\n   * 请求的HTTP版本(类型为CFStringRef)：通常使用kCFHTTPVersion1_1\n\n   * kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。\n\n* 可选参数\n   * body体(类型为CFDataRef)\n\n```\n\nCFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData) CF_AVAILABLE(10_1, 2_0);\n```\n   * 消息头部，如User-Agent等；\n\n```\nCFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef __nullable value) CF_AVAILABLE(10_1, 2_0);\n\n```\n### CFNetwork请求过程\n##### 1：构造并创建CFHTTPMessageRef对象\n```\n//构造的方式上一步已讲\nCFHTTPMessageCreateRequest(CFAllocatorRef __nullable alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion) CF_AVAILABLE(10_1, 2_0);\n```\n##### 2：使用CFHTTPMessageRef对象创建输入流\n```\n//第一个参数传默认\nCFReadStreamCreateForHTTPRequest(CFAllocatorRef __nullable alloc, CFHTTPMessageRef request) CF_DEPRECATED(10_2, 10_11, 2_0, 9_0, \"Use NSURLSession API for http requests\");\n```\n##### 3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）\n因为配置sni环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理sni，像这样\n```\n[self.inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];\n//请求的URL的Host\nNSDictionary *sslProperties = @{ (__bridge id) kCFStreamSSLPeerName : host };\n[self.inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];\n```\n##### 4：打开输入流\n打开输入流分为两步\n* 设置代理：[self.inputStream setDelegate:weakSelf]\n* 加入当前的runloop：        \n```\n[_inputStream removeFromRunLoop:self.runloop forMode:[self runloopMode]];\n```\n* 调用Open方法\n\n##### 5：收到代理数据回调\n```\n- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;\n```\n其中分为几个状态\n```\ntypedef NS_OPTIONS(NSUInteger, NSStreamEvent) {\n    NSStreamEventNone = 0,\n    NSStreamEventOpenCompleted = 1UL << 0,\n    NSStreamEventHasBytesAvailable = 1UL << 1,\n    NSStreamEventHasSpaceAvailable = 1UL << 2,\n    NSStreamEventErrorOccurred = 1UL << 3,\n    NSStreamEventEndEncountered = 1UL << 4\n};\n```\n通常我们会关心NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、\n由于数据是以流的形式回来，我们需要在在NSStreamEventHasBytesAvailable下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样\n```\n case NSStreamEventHasBytesAvailable:\n{\n    UInt8 buffer[BUFFER_SIZE]; //设置缓存区\n    NSInteger numBytesRead = 0;\n    NSInputStream *inputstream = (NSInputStream *) aStream;\n    // Read data\n    do {\n        numBytesRead = [inputstream read:buffer maxLength:sizeof(buffer)];\n        if (numBytesRead > 0) {\n            [self.resultData appendBytes:buffer length:numBytesRead];\n        }\n    } while (numBytesRead > 0);\n}\nbreak;\n```\n循环结束后我们的resultData就是完整的返回数据了。\n","slug":"CFNetwork的介绍和使用","published":1,"updated":"2019-02-02T03:22:53.073Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2km0006a04wp269hgj8","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h3 id=\"CFNetwork背景简介\"><a href=\"#CFNetwork背景简介\" class=\"headerlink\" title=\"CFNetwork背景简介\"></a>CFNetwork背景简介</h3><p>CFNetwork是ISO中一个比较底层的网络框架，C语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket通讯等，我们通常使用的NSURL则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。CFNetwork已经接近于UNIX系统的socket通信了，使用CFHttpMessageRef进行HTTP连接的好处就是控制的粒度更细了，例如你可以设置SSL连接的PeerName，证书验证的方式，还可以控制每个响应包的接收。不过CFNetwork本质上还是应用层上的封装的通用API。使用者可以不用关心底层协议的实际细节。下图是CFNetwork在iOS系统中的位置(图片来源于官方文档)。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg\" alt=\"image.png\"></p>\n<p>由上图可以看出目前iOS的网络编程分四层：</p>\n<ul>\n<li><p>WebKit：属于Cocoa层，苹果很多地方用到的页面渲染引擎WKWebview；</p>\n</li>\n<li><p>NSURL：也属于Cocoa层，对各类URL请求的封装(NSURLRequest)；</p>\n</li>\n<li><p>CFNetwork：属于Core Foundation层，基于C的封装，同样的还有CFNetServices(write/readstream)；</p>\n</li>\n<li><p>BSD sockets：属于OS层，也是基于C的封装；</p>\n</li>\n</ul>\n<h3 id=\"CFNetwork结构\"><a href=\"#CFNetwork结构\" class=\"headerlink\" title=\"CFNetwork结构\"></a>CFNetwork结构</h3><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg\" alt=\"image.png\"><br>上图也是官方文档的图片，描述了CFNetwork的结构，下面逐一讲解。</p>\n<h5 id=\"CFSocket-API\"><a href=\"#CFSocket-API\" class=\"headerlink\" title=\"CFSocket API\"></a>CFSocket API</h5><p>Socket是网络通讯的底层基础，两个socket端口可以互发数据。我们通常使用的是BSD socket，CFSocket则是BSD socket的抽象，基本上实现了几乎所有BSD socket的功能，并且还融入了run loop。</p>\n<h5 id=\"CFStream-API\"><a href=\"#CFStream-API\" class=\"headerlink\" title=\"CFStream API\"></a>CFStream API</h5><p>CFStream API提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用socket）的数据建立stream，我们进行网络请求就是对数据的读写，CFStream提供API对两种CFType对象提供抽象：CFReadStream and CFWriteStream。它同时也是CFHTTP和CFFTP的基础。stream有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//循环条件：流中是否有可用数据(被读过的数据不可用了)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ([self.inputStream hasBytesAvailable]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取相应长度的数据数据</span></span><br><span class=\"line\">    NSInteger len = [self.inputStream <span class=\"string\">read:</span>d <span class=\"string\">maxLength:</span><span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">//如果读取到数据，便将数据快拼接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; !self.inputStream.streamError) &#123;</span><br><span class=\"line\">        [data <span class=\"string\">appendBytes:</span>(<span class=\"keyword\">void</span> *)d <span class=\"string\">length:</span>len];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"CFFTP-API\"><a href=\"#CFFTP-API\" class=\"headerlink\" title=\"CFFTP API\"></a>CFFTP API</h5><p>对用FTP协议通信的封装，能下载、上传文件和目录到FTP服务器。CFFTP建立的连接可以是同步或者异步，此次不做详解。</p>\n<h5 id=\"CFHTTP-API\"><a href=\"#CFHTTP-API\" class=\"headerlink\" title=\"CFHTTP API\"></a>CFHTTP API</h5><p>是HTTP协议的抽象，主要对象是CFHTTPMessageRef(类似于我们通常的NSURLRequest)我们需要像构建NSURLRequest那样来构建CFHTTPMessageRef，同样包含一下几个元素</p>\n<ul>\n<li><p>必须元素</p>\n<ul>\n<li><p>请求方法 (类型为CFStringRef)：POST、GET、DELETE等..</p>\n</li>\n<li><p>请求的URL地址 (类型为CFURLRef)：<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a></p>\n</li>\n<li><p>请求的HTTP版本(类型为CFStringRef)：通常使用kCFHTTPVersion1_1</p>\n</li>\n<li><p>kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。</p>\n</li>\n</ul>\n</li>\n<li><p>可选参数</p>\n<ul>\n<li>body体(类型为CFDataRef)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetBody</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFDataRef</span> bodyData) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>消息头部，如User-Agent等；</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetHeaderFieldValue</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFStringRef</span> headerField, <span class=\"built_in\">CFStringRef</span> __<span class=\"keyword\">nullable</span> value) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure>\n<h3 id=\"CFNetwork请求过程\"><a href=\"#CFNetwork请求过程\" class=\"headerlink\" title=\"CFNetwork请求过程\"></a>CFNetwork请求过程</h3><h5 id=\"1：构造并创建CFHTTPMessageRef对象\"><a href=\"#1：构造并创建CFHTTPMessageRef对象\" class=\"headerlink\" title=\"1：构造并创建CFHTTPMessageRef对象\"></a>1：构造并创建CFHTTPMessageRef对象</h5><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造的方式上一步已讲</span></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageCreateRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFStringRef</span> requestMethod, <span class=\"built_in\">CFURLRef</span> url, <span class=\"built_in\">CFStringRef</span> httpVersion) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2：使用CFHTTPMessageRef对象创建输入流\"><a href=\"#2：使用CFHTTPMessageRef对象创建输入流\" class=\"headerlink\" title=\"2：使用CFHTTPMessageRef对象创建输入流\"></a>2：使用CFHTTPMessageRef对象创建输入流</h5><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数传默认</span></span><br><span class=\"line\"><span class=\"built_in\">CFReadStreamCreateForHTTPRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFHTTPMessageRef</span> request) <span class=\"built_in\">CF_DEPRECATED</span>(<span class=\"number\">10</span>_2, <span class=\"number\">10</span>_11, <span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">\"Use NSURLSession API for http requests\"</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"3：适配SNI环境（一个-IP-地址上可以为不同域名分配使用不同的-SSL-证书；这同时意味着，共享-IP-的虚拟主机也可实现-SSL-TLS-连接。）\"><a href=\"#3：适配SNI环境（一个-IP-地址上可以为不同域名分配使用不同的-SSL-证书；这同时意味着，共享-IP-的虚拟主机也可实现-SSL-TLS-连接。）\" class=\"headerlink\" title=\"3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）\"></a>3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）</h5><p>因为配置sni环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理sni，像这样<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:<span class=\"built_in\">NSStreamSocketSecurityLevelNegotiatedSSL</span> forKey:<span class=\"built_in\">NSStreamSocketSecurityLevelKey</span>];</span><br><span class=\"line\"><span class=\"comment\">//请求的URL的Host</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *sslProperties = @&#123; (__bridge <span class=\"keyword\">id</span>) kCFStreamSSLPeerName : host &#125;;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:sslProperties forKey:(__bridge_transfer <span class=\"built_in\">NSString</span> *) kCFStreamPropertySSLSettings];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4：打开输入流\"><a href=\"#4：打开输入流\" class=\"headerlink\" title=\"4：打开输入流\"></a>4：打开输入流</h5><p>打开输入流分为两步</p>\n<ul>\n<li>设置代理：[self.inputStream setDelegate:weakSelf]</li>\n<li><p>加入当前的runloop：        </p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">_inputStream</span> removeFromRunLoop:self.runloop forMode:[<span class=\"name\">self</span> runloopMode]]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用Open方法</p>\n</li>\n</ul>\n<h5 id=\"5：收到代理数据回调\"><a href=\"#5：收到代理数据回调\" class=\"headerlink\" title=\"5：收到代理数据回调\"></a>5：收到代理数据回调</h5><figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>stream:<span class=\"params\">(NSStream *)</span>aStream handleEvent:<span class=\"params\">(NSStreamEvent)</span>eventCode;</span><br></pre></td></tr></table></figure>\n<p>其中分为几个状态<br><figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSStreamEvent</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventNone</span> = 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventOpenCompleted</span> = 1UL &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasBytesAvailable</span> = 1UL &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasSpaceAvailable</span> = 1UL &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventErrorOccurred</span> = 1UL &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventEndEncountered</span> = 1UL &lt;&lt; 4</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通常我们会关心NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、<br>由于数据是以流的形式回来，我们需要在在NSStreamEventHasBytesAvailable下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UInt8</span> buffer[BUFFER_SIZE]; <span class=\"comment\">//设置缓存区</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> numBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSInputStream</span> *inputstream = (<span class=\"built_in\">NSInputStream</span> *) aStream;</span><br><span class=\"line\">    <span class=\"comment\">// Read data</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        numBytesRead = [inputstream read:buffer maxLength:<span class=\"keyword\">sizeof</span>(buffer)];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numBytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.resultData appendBytes:buffer length:numBytesRead];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (numBytesRead &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure></p>\n<p>循环结束后我们的resultData就是完整的返回数据了。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"CFNetwork背景简介\"><a href=\"#CFNetwork背景简介\" class=\"headerlink\" title=\"CFNetwork背景简介\"></a>CFNetwork背景简介</h3><p>CFNetwork是ISO中一个比较底层的网络框架，C语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket通讯等，我们通常使用的NSURL则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。CFNetwork已经接近于UNIX系统的socket通信了，使用CFHttpMessageRef进行HTTP连接的好处就是控制的粒度更细了，例如你可以设置SSL连接的PeerName，证书验证的方式，还可以控制每个响应包的接收。不过CFNetwork本质上还是应用层上的封装的通用API。使用者可以不用关心底层协议的实际细节。下图是CFNetwork在iOS系统中的位置(图片来源于官方文档)。</p>","more":"<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mit8tsij30bn06lwen.jpg\" alt=\"image.png\"></p>\n<p>由上图可以看出目前iOS的网络编程分四层：</p>\n<ul>\n<li><p>WebKit：属于Cocoa层，苹果很多地方用到的页面渲染引擎WKWebview；</p>\n</li>\n<li><p>NSURL：也属于Cocoa层，对各类URL请求的封装(NSURLRequest)；</p>\n</li>\n<li><p>CFNetwork：属于Core Foundation层，基于C的封装，同样的还有CFNetServices(write/readstream)；</p>\n</li>\n<li><p>BSD sockets：属于OS层，也是基于C的封装；</p>\n</li>\n</ul>\n<h3 id=\"CFNetwork结构\"><a href=\"#CFNetwork结构\" class=\"headerlink\" title=\"CFNetwork结构\"></a>CFNetwork结构</h3><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mlt3gwcj30od0a474w.jpg\" alt=\"image.png\"><br>上图也是官方文档的图片，描述了CFNetwork的结构，下面逐一讲解。</p>\n<h5 id=\"CFSocket-API\"><a href=\"#CFSocket-API\" class=\"headerlink\" title=\"CFSocket API\"></a>CFSocket API</h5><p>Socket是网络通讯的底层基础，两个socket端口可以互发数据。我们通常使用的是BSD socket，CFSocket则是BSD socket的抽象，基本上实现了几乎所有BSD socket的功能，并且还融入了run loop。</p>\n<h5 id=\"CFStream-API\"><a href=\"#CFStream-API\" class=\"headerlink\" title=\"CFStream API\"></a>CFStream API</h5><p>CFStream API提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用socket）的数据建立stream，我们进行网络请求就是对数据的读写，CFStream提供API对两种CFType对象提供抽象：CFReadStream and CFWriteStream。它同时也是CFHTTP和CFFTP的基础。stream有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//循环条件：流中是否有可用数据(被读过的数据不可用了)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ([self.inputStream hasBytesAvailable]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取相应长度的数据数据</span></span><br><span class=\"line\">    NSInteger len = [self.inputStream <span class=\"string\">read:</span>d <span class=\"string\">maxLength:</span><span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">//如果读取到数据，便将数据快拼接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; !self.inputStream.streamError) &#123;</span><br><span class=\"line\">        [data <span class=\"string\">appendBytes:</span>(<span class=\"keyword\">void</span> *)d <span class=\"string\">length:</span>len];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"CFFTP-API\"><a href=\"#CFFTP-API\" class=\"headerlink\" title=\"CFFTP API\"></a>CFFTP API</h5><p>对用FTP协议通信的封装，能下载、上传文件和目录到FTP服务器。CFFTP建立的连接可以是同步或者异步，此次不做详解。</p>\n<h5 id=\"CFHTTP-API\"><a href=\"#CFHTTP-API\" class=\"headerlink\" title=\"CFHTTP API\"></a>CFHTTP API</h5><p>是HTTP协议的抽象，主要对象是CFHTTPMessageRef(类似于我们通常的NSURLRequest)我们需要像构建NSURLRequest那样来构建CFHTTPMessageRef，同样包含一下几个元素</p>\n<ul>\n<li><p>必须元素</p>\n<ul>\n<li><p>请求方法 (类型为CFStringRef)：POST、GET、DELETE等..</p>\n</li>\n<li><p>请求的URL地址 (类型为CFURLRef)：<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a></p>\n</li>\n<li><p>请求的HTTP版本(类型为CFStringRef)：通常使用kCFHTTPVersion1_1</p>\n</li>\n<li><p>kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。</p>\n</li>\n</ul>\n</li>\n<li><p>可选参数</p>\n<ul>\n<li>body体(类型为CFDataRef)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetBody</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFDataRef</span> bodyData) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>消息头部，如User-Agent等；</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFHTTPMessageSetHeaderFieldValue</span>(<span class=\"built_in\">CFHTTPMessageRef</span> message, <span class=\"built_in\">CFStringRef</span> headerField, <span class=\"built_in\">CFStringRef</span> __<span class=\"keyword\">nullable</span> value) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure>\n<h3 id=\"CFNetwork请求过程\"><a href=\"#CFNetwork请求过程\" class=\"headerlink\" title=\"CFNetwork请求过程\"></a>CFNetwork请求过程</h3><h5 id=\"1：构造并创建CFHTTPMessageRef对象\"><a href=\"#1：构造并创建CFHTTPMessageRef对象\" class=\"headerlink\" title=\"1：构造并创建CFHTTPMessageRef对象\"></a>1：构造并创建CFHTTPMessageRef对象</h5><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造的方式上一步已讲</span></span><br><span class=\"line\"><span class=\"built_in\">CFHTTPMessageCreateRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFStringRef</span> requestMethod, <span class=\"built_in\">CFURLRef</span> url, <span class=\"built_in\">CFStringRef</span> httpVersion) <span class=\"built_in\">CF_AVAILABLE</span>(<span class=\"number\">10</span>_1, <span class=\"number\">2</span>_0);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2：使用CFHTTPMessageRef对象创建输入流\"><a href=\"#2：使用CFHTTPMessageRef对象创建输入流\" class=\"headerlink\" title=\"2：使用CFHTTPMessageRef对象创建输入流\"></a>2：使用CFHTTPMessageRef对象创建输入流</h5><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数传默认</span></span><br><span class=\"line\"><span class=\"built_in\">CFReadStreamCreateForHTTPRequest</span>(<span class=\"built_in\">CFAllocatorRef</span> __<span class=\"keyword\">nullable</span> alloc, <span class=\"built_in\">CFHTTPMessageRef</span> request) <span class=\"built_in\">CF_DEPRECATED</span>(<span class=\"number\">10</span>_2, <span class=\"number\">10</span>_11, <span class=\"number\">2</span>_0, <span class=\"number\">9</span>_0, <span class=\"string\">\"Use NSURLSession API for http requests\"</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"3：适配SNI环境（一个-IP-地址上可以为不同域名分配使用不同的-SSL-证书；这同时意味着，共享-IP-的虚拟主机也可实现-SSL-TLS-连接。）\"><a href=\"#3：适配SNI环境（一个-IP-地址上可以为不同域名分配使用不同的-SSL-证书；这同时意味着，共享-IP-的虚拟主机也可实现-SSL-TLS-连接。）\" class=\"headerlink\" title=\"3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）\"></a>3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）</h5><p>因为配置sni环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理sni，像这样<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:<span class=\"built_in\">NSStreamSocketSecurityLevelNegotiatedSSL</span> forKey:<span class=\"built_in\">NSStreamSocketSecurityLevelKey</span>];</span><br><span class=\"line\"><span class=\"comment\">//请求的URL的Host</span></span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *sslProperties = @&#123; (__bridge <span class=\"keyword\">id</span>) kCFStreamSSLPeerName : host &#125;;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.inputStream setProperty:sslProperties forKey:(__bridge_transfer <span class=\"built_in\">NSString</span> *) kCFStreamPropertySSLSettings];</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4：打开输入流\"><a href=\"#4：打开输入流\" class=\"headerlink\" title=\"4：打开输入流\"></a>4：打开输入流</h5><p>打开输入流分为两步</p>\n<ul>\n<li>设置代理：[self.inputStream setDelegate:weakSelf]</li>\n<li><p>加入当前的runloop：        </p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">_inputStream</span> removeFromRunLoop:self.runloop forMode:[<span class=\"name\">self</span> runloopMode]]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用Open方法</p>\n</li>\n</ul>\n<h5 id=\"5：收到代理数据回调\"><a href=\"#5：收到代理数据回调\" class=\"headerlink\" title=\"5：收到代理数据回调\"></a>5：收到代理数据回调</h5><figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>stream:<span class=\"params\">(NSStream *)</span>aStream handleEvent:<span class=\"params\">(NSStreamEvent)</span>eventCode;</span><br></pre></td></tr></table></figure>\n<p>其中分为几个状态<br><figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSStreamEvent</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventNone</span> = 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventOpenCompleted</span> = 1UL &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasBytesAvailable</span> = 1UL &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventHasSpaceAvailable</span> = 1UL &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventErrorOccurred</span> = 1UL &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">NSStreamEventEndEncountered</span> = 1UL &lt;&lt; 4</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通常我们会关心NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、<br>由于数据是以流的形式回来，我们需要在在NSStreamEventHasBytesAvailable下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"built_in\">NSStreamEventHasBytesAvailable</span>:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UInt8</span> buffer[BUFFER_SIZE]; <span class=\"comment\">//设置缓存区</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> numBytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSInputStream</span> *inputstream = (<span class=\"built_in\">NSInputStream</span> *) aStream;</span><br><span class=\"line\">    <span class=\"comment\">// Read data</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        numBytesRead = [inputstream read:buffer maxLength:<span class=\"keyword\">sizeof</span>(buffer)];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numBytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.resultData appendBytes:buffer length:numBytesRead];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (numBytesRead &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure></p>\n<p>循环结束后我们的resultData就是完整的返回数据了。</p>"},{"title":"关于物理效果的动画引擎UIDynamic介绍","date":"2018-01-23T13:18:42.000Z","comments":1,"_content":"这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配gif的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。\n        为了实现动力UI，需要注册一套UI行为的体系，之后UI便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：\nUIDynamicItem：用来描述一个力学物体的状态，其实就是实现了UIDynamicItem委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。\nUIDynamicBehavior：动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组UIDynamicItem应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。\nUIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；\nReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥..只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。下面看下我们给一个button加一个重力下坠的动画 使用self.View做参考系来建立动画\n<!--more-->\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg)\n\n然后\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg)\n\n你可以吧这里航代码写到button的点击事件中，这样你一点就会下坠。很简单吧。\n        再看下一个碰撞\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg)\n\n我这里写碰撞动画的时候用了两个button，其实大家可以猜到我是让两个button来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系(这里是的self.view)的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕self.view的边框会发生物理的碰撞反弹效果。想这样(点我开始那个按钮)\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif)         \n\n除了重力和碰撞，iOS SDK还预先帮我们实现了一些其他的有用的物理行为，它们包括\n UIAttachmentBehavior 描述一个view和一个锚相连接的情况，也可以描述view和view之间的连接。attachment描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了..有了这些，似乎可以做个老鹰捉小鸡的游戏了- -…\nUISnapBehavior 将UIView通过动画吸附到某个点上。初始化的时候设定一下UISnapBehavior的initWithItem:snapToPoint:就行，因为API非常简单，视觉效果也很棒，估计它是今后非游戏app里会被最常用的效果之一了；\nUIPushBehavior 可以为一个UIView施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。\nUIDynamicItemBehavior 其实是一个辅助的行为，用来在item层级设定一些参数，比如item的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等\n\n其实流程很简单创建animator  然后创建behivator   设置behivator属性 然后animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流\n","source":"_posts/2018-01-23-关于物理效果的动画引擎UIDynamic介绍.md","raw":"---\ntitle: 关于物理效果的动画引擎UIDynamic介绍\ncategories: iOS开发\ndate: 2018-01-23 21:18:42\ntags:\n  - 动画\n  - UI\ncomments:\n---\n这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配gif的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。\n        为了实现动力UI，需要注册一套UI行为的体系，之后UI便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：\nUIDynamicItem：用来描述一个力学物体的状态，其实就是实现了UIDynamicItem委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。\nUIDynamicBehavior：动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组UIDynamicItem应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。\nUIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；\nReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥..只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。下面看下我们给一个button加一个重力下坠的动画 使用self.View做参考系来建立动画\n<!--more-->\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg)\n\n然后\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg)\n\n你可以吧这里航代码写到button的点击事件中，这样你一点就会下坠。很简单吧。\n        再看下一个碰撞\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg)\n\n我这里写碰撞动画的时候用了两个button，其实大家可以猜到我是让两个button来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系(这里是的self.view)的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕self.view的边框会发生物理的碰撞反弹效果。想这样(点我开始那个按钮)\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif)         \n\n除了重力和碰撞，iOS SDK还预先帮我们实现了一些其他的有用的物理行为，它们包括\n UIAttachmentBehavior 描述一个view和一个锚相连接的情况，也可以描述view和view之间的连接。attachment描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了..有了这些，似乎可以做个老鹰捉小鸡的游戏了- -…\nUISnapBehavior 将UIView通过动画吸附到某个点上。初始化的时候设定一下UISnapBehavior的initWithItem:snapToPoint:就行，因为API非常简单，视觉效果也很棒，估计它是今后非游戏app里会被最常用的效果之一了；\nUIPushBehavior 可以为一个UIView施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。\nUIDynamicItemBehavior 其实是一个辅助的行为，用来在item层级设定一些参数，比如item的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等\n\n其实流程很简单创建animator  然后创建behivator   设置behivator属性 然后animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流\n","slug":"关于物理效果的动画引擎UIDynamic介绍","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2ko0008a04wwjmq7m0u","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配gif的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。<br>        为了实现动力UI，需要注册一套UI行为的体系，之后UI便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：<br>UIDynamicItem：用来描述一个力学物体的状态，其实就是实现了UIDynamicItem委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。<br>UIDynamicBehavior：动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组UIDynamicItem应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。<br>UIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；<br>ReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥..只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。下面看下我们给一个button加一个重力下坠的动画 使用self.View做参考系来建立动画<br><a id=\"more\"></a><br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg\" alt=\"\"></p>\n<p>然后</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg\" alt=\"\"></p>\n<p>你可以吧这里航代码写到button的点击事件中，这样你一点就会下坠。很简单吧。<br>        再看下一个碰撞</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg\" alt=\"\"></p>\n<p>我这里写碰撞动画的时候用了两个button，其实大家可以猜到我是让两个button来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系(这里是的self.view)的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕self.view的边框会发生物理的碰撞反弹效果。想这样(点我开始那个按钮)</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif\" alt=\"\">         </p>\n<p>除了重力和碰撞，iOS SDK还预先帮我们实现了一些其他的有用的物理行为，它们包括<br> UIAttachmentBehavior 描述一个view和一个锚相连接的情况，也可以描述view和view之间的连接。attachment描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了..有了这些，似乎可以做个老鹰捉小鸡的游戏了- -…<br>UISnapBehavior 将UIView通过动画吸附到某个点上。初始化的时候设定一下UISnapBehavior的initWithItem:snapToPoint:就行，因为API非常简单，视觉效果也很棒，估计它是今后非游戏app里会被最常用的效果之一了；<br>UIPushBehavior 可以为一个UIView施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。<br>UIDynamicItemBehavior 其实是一个辅助的行为，用来在item层级设定一些参数，比如item的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等</p>\n<p>其实流程很简单创建animator  然后创建behivator   设置behivator属性 然后animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流</p>\n","site":{"data":{}},"excerpt":"<p>这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配gif的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。<br>        为了实现动力UI，需要注册一套UI行为的体系，之后UI便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：<br>UIDynamicItem：用来描述一个力学物体的状态，其实就是实现了UIDynamicItem委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。<br>UIDynamicBehavior：动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组UIDynamicItem应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。<br>UIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；<br>ReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥..只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。下面看下我们给一个button加一个重力下坠的动画 使用self.View做参考系来建立动画<br>","more":"<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6m073lu9j30ft02n74g.jpg\" alt=\"\"></p>\n<p>然后</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6m0h0bvej307900s0si.jpg\" alt=\"\"></p>\n<p>你可以吧这里航代码写到button的点击事件中，这样你一点就会下坠。很简单吧。<br>        再看下一个碰撞</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6m1auc65j30mx02ht92.jpg\" alt=\"\"></p>\n<p>我这里写碰撞动画的时候用了两个button，其实大家可以猜到我是让两个button来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系(这里是的self.view)的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕self.view的边框会发生物理的碰撞反弹效果。想这样(点我开始那个按钮)</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6m1l2ecwg308r0fl75h.gif\" alt=\"\">         </p>\n<p>除了重力和碰撞，iOS SDK还预先帮我们实现了一些其他的有用的物理行为，它们包括<br> UIAttachmentBehavior 描述一个view和一个锚相连接的情况，也可以描述view和view之间的连接。attachment描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了..有了这些，似乎可以做个老鹰捉小鸡的游戏了- -…<br>UISnapBehavior 将UIView通过动画吸附到某个点上。初始化的时候设定一下UISnapBehavior的initWithItem:snapToPoint:就行，因为API非常简单，视觉效果也很棒，估计它是今后非游戏app里会被最常用的效果之一了；<br>UIPushBehavior 可以为一个UIView施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。<br>UIDynamicItemBehavior 其实是一个辅助的行为，用来在item层级设定一些参数，比如item的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等</p>\n<p>其实流程很简单创建animator  然后创建behivator   设置behivator属性 然后animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。    这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流</p>"},{"title":"关于视图在切圆角时候的导致的性能下降的一些探讨","date":"2018-01-23T13:08:48.000Z","comments":1,"_content":"iOS中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  ->  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像tableView那样如果每一个cell上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png图片UIImageView处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）。这里先说下离屏渲染：\n ###### iOS的渲染机制：\n   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU屏幕渲染有以下两种方式：\nOn-Screen Rendering\n意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。\nOff-Screen Rendering\n意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n<!--more-->\n由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。\n通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：\nshouldRasterize（光栅化）\nmasks（遮罩）\nshadows（阴影）\nedge antialiasing（抗锯齿）\ngroup opacity（不透明）\n复杂形状设置圆角等\n渐变\n我用一个现有的小DEMO来测试下，因为这个demo中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在tableView中的自定义cell类中我设置了阴影如图：\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg)\n\n使用Instruments测试得到当前帧数在二三十左右\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg)\n\n同时屏幕是也出现了黄色图层\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg)\n\n所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对APP的体验。\n###### 如何避免离屏渲染：\n* 方法一：使用光栅化，.layer.shouldRasterize = YES;   ->  .layer.rasterizationScale=[UIScreen mainScreen].scale;设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。\n\n* 方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的\n\n* 方法三：Core Graphics绘制圆角。这种方式GPU损耗最低，可以用UIimageView添加个点击手势当做UIButton使用。\nUIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);\n[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];\navatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();\n这段方法可以写在SDWebImage的completed回调里，在主线程异步绘制。也可以封装到UIImageView里，写了个DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在imageView上，其他地方呢不知道怎么用，不过这种方法会耗费大量的CPU资源和占用内存，本人不太建议使用。\n\n最后给大家测试下，因为我之前的demo没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg)\n\n然后运行，打开Instruments，然后看屏幕\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg)\n\n图层都是绿色没问题，我们再来看帧数，几乎到60 ，效果很明显。![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg)\n\n由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。\n","source":"_posts/2018-01-23-关于视图在切圆角时候的导致的性能下降的一些探讨.md","raw":"---\ntitle: 关于视图在切圆角时候的导致的性能下降的一些探讨\ncategories: iOS开发\ndate: 2018-01-23 21:08:48\ntags:\n  - 性能优化\n  - UI\ncomments:\n---\niOS中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  ->  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像tableView那样如果每一个cell上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png图片UIImageView处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）。这里先说下离屏渲染：\n ###### iOS的渲染机制：\n   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU屏幕渲染有以下两种方式：\nOn-Screen Rendering\n意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。\nOff-Screen Rendering\n意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n<!--more-->\n由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。\n通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：\nshouldRasterize（光栅化）\nmasks（遮罩）\nshadows（阴影）\nedge antialiasing（抗锯齿）\ngroup opacity（不透明）\n复杂形状设置圆角等\n渐变\n我用一个现有的小DEMO来测试下，因为这个demo中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在tableView中的自定义cell类中我设置了阴影如图：\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg)\n\n使用Instruments测试得到当前帧数在二三十左右\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg)\n\n同时屏幕是也出现了黄色图层\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg)\n\n所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对APP的体验。\n###### 如何避免离屏渲染：\n* 方法一：使用光栅化，.layer.shouldRasterize = YES;   ->  .layer.rasterizationScale=[UIScreen mainScreen].scale;设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。\n\n* 方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的\n\n* 方法三：Core Graphics绘制圆角。这种方式GPU损耗最低，可以用UIimageView添加个点击手势当做UIButton使用。\nUIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);\n[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];\navatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();\n这段方法可以写在SDWebImage的completed回调里，在主线程异步绘制。也可以封装到UIImageView里，写了个DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在imageView上，其他地方呢不知道怎么用，不过这种方法会耗费大量的CPU资源和占用内存，本人不太建议使用。\n\n最后给大家测试下，因为我之前的demo没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg)\n\n然后运行，打开Instruments，然后看屏幕\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg)\n\n图层都是绿色没问题，我们再来看帧数，几乎到60 ，效果很明显。![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg)\n\n由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。\n","slug":"关于视图在切圆角时候的导致的性能下降的一些探讨","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2kq000aa04wvnuo3mns","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>iOS中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  -&gt;  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像tableView那样如果每一个cell上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png图片UIImageView处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）。这里先说下离屏渲染：</p>\n<h6 id=\"iOS的渲染机制：\"><a href=\"#iOS的渲染机制：\" class=\"headerlink\" title=\"iOS的渲染机制：\"></a>iOS的渲染机制：</h6><p>   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU屏幕渲染有以下两种方式：<br>On-Screen Rendering<br>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br>Off-Screen Rendering<br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br><a id=\"more\"></a><br>由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。<br>通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：<br>shouldRasterize（光栅化）<br>masks（遮罩）<br>shadows（阴影）<br>edge antialiasing（抗锯齿）<br>group opacity（不透明）<br>复杂形状设置圆角等<br>渐变<br>我用一个现有的小DEMO来测试下，因为这个demo中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在tableView中的自定义cell类中我设置了阴影如图：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg\" alt=\"\"></p>\n<p>使用Instruments测试得到当前帧数在二三十左右</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg\" alt=\"\"></p>\n<p>同时屏幕是也出现了黄色图层</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg\" alt=\"\"></p>\n<p>所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对APP的体验。</p>\n<h6 id=\"如何避免离屏渲染：\"><a href=\"#如何避免离屏渲染：\" class=\"headerlink\" title=\"如何避免离屏渲染：\"></a>如何避免离屏渲染：</h6><ul>\n<li><p>方法一：使用光栅化，.layer.shouldRasterize = YES;   -&gt;  .layer.rasterizationScale=[UIScreen mainScreen].scale;设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>\n</li>\n<li><p>方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的</p>\n</li>\n<li><p>方法三：Core Graphics绘制圆角。这种方式GPU损耗最低，可以用UIimageView添加个点击手势当做UIButton使用。<br>UIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);<br>[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];<br>avatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();<br>这段方法可以写在SDWebImage的completed回调里，在主线程异步绘制。也可以封装到UIImageView里，写了个DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在imageView上，其他地方呢不知道怎么用，不过这种方法会耗费大量的CPU资源和占用内存，本人不太建议使用。</p>\n</li>\n</ul>\n<p>最后给大家测试下，因为我之前的demo没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg\" alt=\"\"></p>\n<p>然后运行，打开Instruments，然后看屏幕</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg\" alt=\"\"></p>\n<p>图层都是绿色没问题，我们再来看帧数，几乎到60 ，效果很明显。<img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg\" alt=\"\"></p>\n<p>由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。</p>\n","site":{"data":{}},"excerpt":"<p>iOS中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius  -&gt;  clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像tableView那样如果每一个cell上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png图片UIImageView处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）。这里先说下离屏渲染：</p>\n<h6 id=\"iOS的渲染机制：\"><a href=\"#iOS的渲染机制：\" class=\"headerlink\" title=\"iOS的渲染机制：\"></a>iOS的渲染机制：</h6><p>   CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU屏幕渲染有以下两种方式：<br>On-Screen Rendering<br>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br>Off-Screen Rendering<br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br>","more":"<br>由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。<br>通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：<br>shouldRasterize（光栅化）<br>masks（遮罩）<br>shadows（阴影）<br>edge antialiasing（抗锯齿）<br>group opacity（不透明）<br>复杂形状设置圆角等<br>渐变<br>我用一个现有的小DEMO来测试下，因为这个demo中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在tableView中的自定义cell类中我设置了阴影如图：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6makjj7sj30f2025aac.jpg\" alt=\"\"></p>\n<p>使用Instruments测试得到当前帧数在二三十左右</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6maqxgt6j30uf03874d.jpg\" alt=\"\"></p>\n<p>同时屏幕是也出现了黄色图层</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6mb1epsnj30dx0ou40r.jpg\" alt=\"\"></p>\n<p>所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对APP的体验。</p>\n<h6 id=\"如何避免离屏渲染：\"><a href=\"#如何避免离屏渲染：\" class=\"headerlink\" title=\"如何避免离屏渲染：\"></a>如何避免离屏渲染：</h6><ul>\n<li><p>方法一：使用光栅化，.layer.shouldRasterize = YES;   -&gt;  .layer.rasterizationScale=[UIScreen mainScreen].scale;设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>\n</li>\n<li><p>方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的</p>\n</li>\n<li><p>方法三：Core Graphics绘制圆角。这种方式GPU损耗最低，可以用UIimageView添加个点击手势当做UIButton使用。<br>UIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);<br>[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];<br>avatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();<br>这段方法可以写在SDWebImage的completed回调里，在主线程异步绘制。也可以封装到UIImageView里，写了个DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在imageView上，其他地方呢不知道怎么用，不过这种方法会耗费大量的CPU资源和占用内存，本人不太建议使用。</p>\n</li>\n</ul>\n<p>最后给大家测试下，因为我之前的demo没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbdmx1bj30lu04ywfj.jpg\" alt=\"\"></p>\n<p>然后运行，打开Instruments，然后看屏幕</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mbm7cn6j30e40ox76i.jpg\" alt=\"\"></p>\n<p>图层都是绿色没问题，我们再来看帧数，几乎到60 ，效果很明显。<img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6mbsz37rj30j602k747.jpg\" alt=\"\"></p>\n<p>由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。</p>"},{"title":"Welcome To My Site","date":"2018-01-19T06:37:12.000Z","comments":1,"top":100,"_content":"{% cq %}Today<br>you'll view the world differently{% endcq %}\n![你好](https://ws2.sinaimg.cn/large/006tNc79ly1fnygnuhm3rj31kw0zk1ky.jpg)\nwelcome !!!\n<!--more-->\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"大鱼\",\n            \"author\": \"周深\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/2018-01-19-test-source.md","raw":"---\ntitle: Welcome To My Site\ndate: 2018-01-19 14:37:12\ntags: 欢迎页\ncategories: 其他\ncomments:\ntop: 100\n---\n{% cq %}Today<br>you'll view the world differently{% endcq %}\n![你好](https://ws2.sinaimg.cn/large/006tNc79ly1fnygnuhm3rj31kw0zk1ky.jpg)\nwelcome !!!\n<!--more-->\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"大鱼\",\n            \"author\": \"周深\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"test-source","published":1,"updated":"2019-02-02T03:22:53.073Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2kt000da04wxx9mfrfo","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><blockquote class=\"blockquote-center\"><p>Today<br>you’ll view the world differently</p>\n</blockquote>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fnygnuhm3rj31kw0zk1ky.jpg\" alt=\"你好\"><br>welcome !!!<br><a id=\"more\"></a></p>\n\n\t\t\t<div id=\"aplayer0\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"大鱼\",\"author\":\"周深\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer0\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>Today<br>you’ll view the world differently</p>\n</blockquote>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fnygnuhm3rj31kw0zk1ky.jpg\" alt=\"你好\"><br>welcome !!!<br>","more":"</p>\n\n\t\t\t<div id=\"aplayer0\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"大鱼\",\"author\":\"周深\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer0\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>"},{"title":"iOS中使用OpenGL实现增高功能","date":"2018-01-23T13:23:49.000Z","comments":1,"_content":"### 功能效果\n\n![demo示例](https://ws3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif)\n<!--more-->\n\n### 功能分析  \n* 功能：渲染一张传入的图片 -> 手动选择编辑区域 -> 通过滑块来编辑区域的增高或者缩短\n\n* OpenGL原理：\n  * 因为OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。\n\n  * OpenGL里面坐标是以左下角为原点X轴向上为正，Y轴向右为正\n\n### 功能实现\n\n* 渲染图片拆分图片：\n   * 拆分方法1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用GL渲染出图片。\n\n![拆分三角形](https://ws4.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg)\n\n  这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。\n  * 拆分方法2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到6个三角形，8个顶点，如下图：\n\n![拆分2](https://ws1.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg)\n\n这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个DEMO中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组\n```\n//顶点数组\nGLfloat vertices[] = {   \n    -1.2, -1.2,     //左下\n    1.2, -1.2,      //右下\n    -1.2, -0.4,     //小矩形左下\n    1.2, -0.4,      //小矩形右下\n    -1.2,  0.4,     //小矩形左上\n    1.2,  0.4,      //小矩形右上\n    -1.2,  1.2,     //左上\n    1.2,  1.2,      //右上\n};\n\n //填充纹理的数组\nGLfloat texCoords[] = {     \n    0, 0,        //左下                  //下标为 0 1\n    1, 0,        //右下                  //下标为2 3\n    0, 1.0/3.0,  //小矩形左下             //下标为4 5\n    1, 1.0/3.0,  //小矩形右下             //下标为6 7\n    0, 2.0/3.0,  //小矩形左上角           //下标为8 9\n    1, 2.0/3.0,  //小矩形右上角           //下标为10 11\n    0, 1,        //左上                  //下标为12 13\n    1, 1,        //右上                  //下标为14 15\n};\n\n```\n\n* 手动选择区域：通过添加带有自定义手势的UIView 来实现拖动修改选择区域。\n\n```\n*****************CustomPanView代码******************\n#import <UIKit/UIKit.h>\n\n@protocol CustomPanViewDelegate <NSObject>\n\n/**\n *  开始拖拽\n *\n *  @param customPanView 自身\n *  @param centerY       自身所在的y坐标\n */\n- (void)beginDragWithCoustomPanView:(UIView *)customPanView centerY:(CGFloat)centerY;\n\n@end\n\n@interface CustomPanView : UIView\n\n@property (nonatomic, assign) id<CustomPanViewDelegate> delegate;\n\n@end\n\n```\n```\n*****************CustomPanViewDelegate代码******************\n\n#pragma mark -\n#pragma mark 拖拽View的代理方法\n-(void)beginDragWithCoustomPanView:(UIView *)customPanView centerY:(CGFloat)centerY {\n\n    // 限制范围：裁剪区不能大于图片区域\n    if (customPanView.center.y >= imageBottom) {\n        customPanView.center = CGPointMake(customPanView.center.x, imageBottom);\n    }\n    if (customPanView.center.y <= imageTop) {\n        customPanView.center = CGPointMake(customPanView.center.x, imageTop);\n    }\n\n//    获取两条线的坐标\n    CGFloat topY = _topView.center.y;\n\n    CGFloat bottomY = _bottomView.center.y;\n\n//    根据两条线的坐标刷新裁剪区域UI\n    [_cutLabel setFrame:CGRectMake(0, topY < bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];\n\n//    算出裁剪起始坐标和结束坐标\n    CGFloat fromPoint = topY < bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;\n\n    CGFloat toPoint = topY < bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;\n\n   //将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。\n    [self sendFromePoint:fromPoint endPoint:toPoint];\n\n\n\n    if (_cutLabel.frame.size.height < 30) {  //隐藏文字\n        _cutLabel.text = @\"\";\n    } else {\n        _cutLabel.text = @\"编辑区域\";\n    }\n\n    [self.slider setValue:0.0 animated:YES];\n\n    tmpHeight = 0.0f;\n\n}\n```\n使用一个Delegate将拖移后的Y坐标返回，因为是竖直运动的所以我们只关心Y轴坐标。\n\n* 改变大小：通过将UISliderBar的ValueChange和顶点坐标关联来实现改变顶点坐标，之后调用GLKView 的display的方法来刷新UI，将变化的过程展现出来。\n\n```\n- (void)action:(UISlider *)sender {\n    //判断是否是向右滑动\n    isRightDirection = sender.value >= judgeDirection ? YES : NO;\n    //所改变的高度\n    changeHeight = sender.value - tmpHeight;\n\n    //遍历数组\n    for (int i = 0; i < 16; i ++) {\n        //将Y坐标筛选出来\n        if (i % 2 != 0) {\n            //下半部分矩形\n            if (i <= 7) {\n                //下半部分矩形Y轴做减法减去变化的高度\n                vertices[i] = verticesCopy[i] - changeHeight;\n                //上半部分矩形\n            } else if (i >= 9) {\n                //上半部分矩形Y轴做加法加上变化的高度\n                vertices[i] = verticesCopy[i] + changeHeight;\n\n            }\n\n        }\n\n    }\n    //缩小时候如果编辑区域已经成为一条线了就不能在缩小了\n    if (vertices[11] > vertices[7]) {\n\n        [self.glView display];\n\n    }\n\n}\n\n```\n\n* 通过glReadPixels来从内存中读取像素数据，GLubyte -> CGImageRef -> UIimage 然后最相关的保存或者其他操作。\n\n```\n#pragma mark -\n#pragma mark 获取处理后的图片\n- (UIImage *) createImage {\n\n    int imageY = 0;\n\n    int imgHeight = 0;\n\n    if (isRightDirection) { // 判断slider滑动方向\n\n        imageY = fabs(imageTop - fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n        imgHeight = fabs(imageHeight + 2 * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n    } else {\n\n        imageY = fabs(imageTop + fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n        imgHeight = fabs(imageHeight - 2 * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n    }\n\n\n    int imageWidth = SCREEN_WIDTH * screenScale;\n\n    int dataLength = imageWidth * imgHeight * 4;\n\n    GLubyte *data = (GLubyte*)malloc(dataLength * sizeof(GLubyte));\n\n    glPixelStorei(GL_PACK_ALIGNMENT, 4);\n\n    glReadPixels(0, imageY, imageWidth, imgHeight, GL_RGBA, GL_UNSIGNED_BYTE, data);  //从内存中读取像素\n    CGDataProviderRef ref = CGDataProviderCreateWithData(NULL, data, dataLength, NULL);\n    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();\n    CGImageRef iref = CGImageCreate(imageWidth, imgHeight, 8, 32, imageWidth * 4, colorspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast,ref, NULL, true, kCGRenderingIntentDefault);\n\n    UIGraphicsBeginImageContext(CGSizeMake(imageWidth, imgHeight));\n    CGContextRef cgcontext = UIGraphicsGetCurrentContext();\n    CGContextSetBlendMode(cgcontext, kCGBlendModeCopy);\n    CGContextDrawImage(cgcontext, CGRectMake(0, 0, imageWidth, imgHeight), iref);\n\n    CGImageRef imageMasked = CGBitmapContextCreateImage(cgcontext);\n    UIImage * image = [UIImage imageWithCGImage:imageMasked scale:screenScale orientation:UIImageOrientationUp];\n    UIGraphicsEndImageContext();\n\n    free(data);\n    CFRelease(ref);\n    CFRelease(colorspace);\n    CGImageRelease(iref);\n\n    return image;\n\n}\n\n```\n","source":"_posts/2018-01-23-iOS中使用OpenGL实现增高功能.md","raw":"---\ntitle: iOS中使用OpenGL实现增高功能\ncategories: iOS开发\ndate: 2018-01-23 21:23:49\ntags:\n  - OpenGL\n  - 底层\n  - UI\ncomments:\n---\n### 功能效果\n\n![demo示例](https://ws3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif)\n<!--more-->\n\n### 功能分析  \n* 功能：渲染一张传入的图片 -> 手动选择编辑区域 -> 通过滑块来编辑区域的增高或者缩短\n\n* OpenGL原理：\n  * 因为OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。\n\n  * OpenGL里面坐标是以左下角为原点X轴向上为正，Y轴向右为正\n\n### 功能实现\n\n* 渲染图片拆分图片：\n   * 拆分方法1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用GL渲染出图片。\n\n![拆分三角形](https://ws4.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg)\n\n  这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。\n  * 拆分方法2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到6个三角形，8个顶点，如下图：\n\n![拆分2](https://ws1.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg)\n\n这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个DEMO中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组\n```\n//顶点数组\nGLfloat vertices[] = {   \n    -1.2, -1.2,     //左下\n    1.2, -1.2,      //右下\n    -1.2, -0.4,     //小矩形左下\n    1.2, -0.4,      //小矩形右下\n    -1.2,  0.4,     //小矩形左上\n    1.2,  0.4,      //小矩形右上\n    -1.2,  1.2,     //左上\n    1.2,  1.2,      //右上\n};\n\n //填充纹理的数组\nGLfloat texCoords[] = {     \n    0, 0,        //左下                  //下标为 0 1\n    1, 0,        //右下                  //下标为2 3\n    0, 1.0/3.0,  //小矩形左下             //下标为4 5\n    1, 1.0/3.0,  //小矩形右下             //下标为6 7\n    0, 2.0/3.0,  //小矩形左上角           //下标为8 9\n    1, 2.0/3.0,  //小矩形右上角           //下标为10 11\n    0, 1,        //左上                  //下标为12 13\n    1, 1,        //右上                  //下标为14 15\n};\n\n```\n\n* 手动选择区域：通过添加带有自定义手势的UIView 来实现拖动修改选择区域。\n\n```\n*****************CustomPanView代码******************\n#import <UIKit/UIKit.h>\n\n@protocol CustomPanViewDelegate <NSObject>\n\n/**\n *  开始拖拽\n *\n *  @param customPanView 自身\n *  @param centerY       自身所在的y坐标\n */\n- (void)beginDragWithCoustomPanView:(UIView *)customPanView centerY:(CGFloat)centerY;\n\n@end\n\n@interface CustomPanView : UIView\n\n@property (nonatomic, assign) id<CustomPanViewDelegate> delegate;\n\n@end\n\n```\n```\n*****************CustomPanViewDelegate代码******************\n\n#pragma mark -\n#pragma mark 拖拽View的代理方法\n-(void)beginDragWithCoustomPanView:(UIView *)customPanView centerY:(CGFloat)centerY {\n\n    // 限制范围：裁剪区不能大于图片区域\n    if (customPanView.center.y >= imageBottom) {\n        customPanView.center = CGPointMake(customPanView.center.x, imageBottom);\n    }\n    if (customPanView.center.y <= imageTop) {\n        customPanView.center = CGPointMake(customPanView.center.x, imageTop);\n    }\n\n//    获取两条线的坐标\n    CGFloat topY = _topView.center.y;\n\n    CGFloat bottomY = _bottomView.center.y;\n\n//    根据两条线的坐标刷新裁剪区域UI\n    [_cutLabel setFrame:CGRectMake(0, topY < bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];\n\n//    算出裁剪起始坐标和结束坐标\n    CGFloat fromPoint = topY < bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;\n\n    CGFloat toPoint = topY < bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;\n\n   //将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。\n    [self sendFromePoint:fromPoint endPoint:toPoint];\n\n\n\n    if (_cutLabel.frame.size.height < 30) {  //隐藏文字\n        _cutLabel.text = @\"\";\n    } else {\n        _cutLabel.text = @\"编辑区域\";\n    }\n\n    [self.slider setValue:0.0 animated:YES];\n\n    tmpHeight = 0.0f;\n\n}\n```\n使用一个Delegate将拖移后的Y坐标返回，因为是竖直运动的所以我们只关心Y轴坐标。\n\n* 改变大小：通过将UISliderBar的ValueChange和顶点坐标关联来实现改变顶点坐标，之后调用GLKView 的display的方法来刷新UI，将变化的过程展现出来。\n\n```\n- (void)action:(UISlider *)sender {\n    //判断是否是向右滑动\n    isRightDirection = sender.value >= judgeDirection ? YES : NO;\n    //所改变的高度\n    changeHeight = sender.value - tmpHeight;\n\n    //遍历数组\n    for (int i = 0; i < 16; i ++) {\n        //将Y坐标筛选出来\n        if (i % 2 != 0) {\n            //下半部分矩形\n            if (i <= 7) {\n                //下半部分矩形Y轴做减法减去变化的高度\n                vertices[i] = verticesCopy[i] - changeHeight;\n                //上半部分矩形\n            } else if (i >= 9) {\n                //上半部分矩形Y轴做加法加上变化的高度\n                vertices[i] = verticesCopy[i] + changeHeight;\n\n            }\n\n        }\n\n    }\n    //缩小时候如果编辑区域已经成为一条线了就不能在缩小了\n    if (vertices[11] > vertices[7]) {\n\n        [self.glView display];\n\n    }\n\n}\n\n```\n\n* 通过glReadPixels来从内存中读取像素数据，GLubyte -> CGImageRef -> UIimage 然后最相关的保存或者其他操作。\n\n```\n#pragma mark -\n#pragma mark 获取处理后的图片\n- (UIImage *) createImage {\n\n    int imageY = 0;\n\n    int imgHeight = 0;\n\n    if (isRightDirection) { // 判断slider滑动方向\n\n        imageY = fabs(imageTop - fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n        imgHeight = fabs(imageHeight + 2 * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n    } else {\n\n        imageY = fabs(imageTop + fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n        imgHeight = fabs(imageHeight - 2 * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;\n\n    }\n\n\n    int imageWidth = SCREEN_WIDTH * screenScale;\n\n    int dataLength = imageWidth * imgHeight * 4;\n\n    GLubyte *data = (GLubyte*)malloc(dataLength * sizeof(GLubyte));\n\n    glPixelStorei(GL_PACK_ALIGNMENT, 4);\n\n    glReadPixels(0, imageY, imageWidth, imgHeight, GL_RGBA, GL_UNSIGNED_BYTE, data);  //从内存中读取像素\n    CGDataProviderRef ref = CGDataProviderCreateWithData(NULL, data, dataLength, NULL);\n    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();\n    CGImageRef iref = CGImageCreate(imageWidth, imgHeight, 8, 32, imageWidth * 4, colorspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast,ref, NULL, true, kCGRenderingIntentDefault);\n\n    UIGraphicsBeginImageContext(CGSizeMake(imageWidth, imgHeight));\n    CGContextRef cgcontext = UIGraphicsGetCurrentContext();\n    CGContextSetBlendMode(cgcontext, kCGBlendModeCopy);\n    CGContextDrawImage(cgcontext, CGRectMake(0, 0, imageWidth, imgHeight), iref);\n\n    CGImageRef imageMasked = CGBitmapContextCreateImage(cgcontext);\n    UIImage * image = [UIImage imageWithCGImage:imageMasked scale:screenScale orientation:UIImageOrientationUp];\n    UIGraphicsEndImageContext();\n\n    free(data);\n    CFRelease(ref);\n    CFRelease(colorspace);\n    CGImageRelease(iref);\n\n    return image;\n\n}\n\n```\n","slug":"iOS中使用OpenGL实现增高功能","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2kw000ea04wg2ivuv8f","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h3 id=\"功能效果\"><a href=\"#功能效果\" class=\"headerlink\" title=\"功能效果\"></a>功能效果</h3><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif\" alt=\"demo示例\"><br><a id=\"more\"></a></p>\n<h3 id=\"功能分析\"><a href=\"#功能分析\" class=\"headerlink\" title=\"功能分析\"></a>功能分析</h3><ul>\n<li><p>功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短</p>\n</li>\n<li><p>OpenGL原理：</p>\n<ul>\n<li><p>因为OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。</p>\n</li>\n<li><p>OpenGL里面坐标是以左下角为原点X轴向上为正，Y轴向右为正</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><ul>\n<li>渲染图片拆分图片：<ul>\n<li>拆分方法1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用GL渲染出图片。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg\" alt=\"拆分三角形\"></p>\n<p>  这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。</p>\n<ul>\n<li>拆分方法2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到6个三角形，8个顶点，如下图：</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg\" alt=\"拆分2\"></p>\n<p>这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个DEMO中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组<br><figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;   </span><br><span class=\"line\">    <span class=\"number\">-1.2</span>, <span class=\"number\">-1.2</span>,     <span class=\"comment\">//左下</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>, <span class=\"number\">-1.2</span>,      <span class=\"comment\">//右下</span></span><br><span class=\"line\">    <span class=\"number\">-1.2</span>, <span class=\"number\">-0.4</span>,     <span class=\"comment\">//小矩形左下</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>, <span class=\"number\">-0.4</span>,      <span class=\"comment\">//小矩形右下</span></span><br><span class=\"line\">    <span class=\"number\">-1.2</span>,  <span class=\"number\">0.4</span>,     <span class=\"comment\">//小矩形左上</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>,  <span class=\"number\">0.4</span>,      <span class=\"comment\">//小矩形右上</span></span><br><span class=\"line\">    <span class=\"number\">-1.2</span>,  <span class=\"number\">1.2</span>,     <span class=\"comment\">//左上</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>,  <span class=\"number\">1.2</span>,      <span class=\"comment\">//右上</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//填充纹理的数组</span></span><br><span class=\"line\">GLfloat texCoords[] = &#123;     </span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">0</span>,        <span class=\"comment\">//左下                  //下标为 0 1</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">0</span>,        <span class=\"comment\">//右下                  //下标为2 3</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形左下             //下标为4 5</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形右下             //下标为6 7</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">2.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形左上角           //下标为8 9</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">2.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形右上角           //下标为10 11</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>,        <span class=\"comment\">//左上                  //下标为12 13</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">1</span>,        <span class=\"comment\">//右上                  //下标为14 15</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>手动选择区域：通过添加带有自定义手势的UIView 来实现拖动修改选择区域。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">*****************CustomPanView代码******************</span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CustomPanViewDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  开始拖拽</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param customPanView 自身</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param centerY       自身所在的y坐标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomPanView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">id</span>&lt;CustomPanViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">*****************CustomPanViewDelegate代码******************</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 拖拽View的代理方法</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制范围：裁剪区不能大于图片区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &gt;= imageBottom) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &lt;= imageTop) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageTop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    获取两条线的坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> topY = _topView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> bottomY = _bottomView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    根据两条线的坐标刷新裁剪区域UI</span></span><br><span class=\"line\">    [_cutLabel setFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    算出裁剪起始坐标和结束坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendFromePoint:fromPoint endPoint:toPoint];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cutLabel.frame.size.height &lt; <span class=\"number\">30</span>) &#123;  <span class=\"comment\">//隐藏文字</span></span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@\"编辑区域\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.slider setValue:<span class=\"number\">0.0</span> animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpHeight = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用一个Delegate将拖移后的Y坐标返回，因为是竖直运动的所以我们只关心Y轴坐标。</p>\n<ul>\n<li>改变大小：通过将UISliderBar的ValueChange和顶点坐标关联来实现改变顶点坐标，之后调用GLKView 的display的方法来刷新UI，将变化的过程展现出来。</li>\n</ul>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)action:(UISlider *)sender &#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否是向右滑动</span></span><br><span class=\"line\">    isRightDirection = sender.value &gt;= judgeDirection ? YES : NO;</span><br><span class=\"line\">    <span class=\"comment\">//所改变的高度</span></span><br><span class=\"line\">    changeHeight = sender.value - tmpHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i ++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将Y坐标筛选出来</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//下半部分矩形</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//下半部分矩形Y轴做减法减去变化的高度</span></span><br><span class=\"line\">                <span class=\"keyword\">vertices</span>[i] = verticesCopy[i] - changeHeight;</span><br><span class=\"line\">                <span class=\"comment\">//上半部分矩形</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//上半部分矩形Y轴做加法加上变化的高度</span></span><br><span class=\"line\">                <span class=\"keyword\">vertices</span>[i] = verticesCopy[i] + changeHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//缩小时候如果编辑区域已经成为一条线了就不能在缩小了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">vertices</span>[<span class=\"number\">11</span>] &gt; <span class=\"keyword\">vertices</span>[<span class=\"number\">7</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [self.glView display];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过glReadPixels来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 获取处理后的图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *) createImage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> imageY = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> imgHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRightDirection) &#123; <span class=\"comment\">// 判断slider滑动方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop - fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight + <span class=\"number\">2</span> * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop + fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight - <span class=\"number\">2</span> * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> imageWidth = SCREEN_WIDTH * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dataLength = imageWidth * imgHeight * <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLubyte *data = (GLubyte*)malloc(dataLength * <span class=\"keyword\">sizeof</span>(GLubyte));</span><br><span class=\"line\"></span><br><span class=\"line\">    glPixelStorei(GL_PACK_ALIGNMENT, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    glReadPixels(<span class=\"number\">0</span>, imageY, imageWidth, imgHeight, GL_RGBA, GL_UNSIGNED_BYTE, data);  <span class=\"comment\">//从内存中读取像素</span></span><br><span class=\"line\">    <span class=\"built_in\">CGDataProviderRef</span> ref = <span class=\"built_in\">CGDataProviderCreateWithData</span>(<span class=\"literal\">NULL</span>, data, dataLength, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorspace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> iref = <span class=\"built_in\">CGImageCreate</span>(imageWidth, imgHeight, <span class=\"number\">8</span>, <span class=\"number\">32</span>, imageWidth * <span class=\"number\">4</span>, colorspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast,ref, <span class=\"literal\">NULL</span>, <span class=\"literal\">true</span>, kCGRenderingIntentDefault);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContext</span>(<span class=\"built_in\">CGSizeMake</span>(imageWidth, imgHeight));</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> cgcontext = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetBlendMode</span>(cgcontext, kCGBlendModeCopy);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(cgcontext, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, imageWidth, imgHeight), iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> imageMasked = <span class=\"built_in\">CGBitmapContextCreateImage</span>(cgcontext);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> * image = [<span class=\"built_in\">UIImage</span> imageWithCGImage:imageMasked scale:screenScale orientation:<span class=\"built_in\">UIImageOrientationUp</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    free(data);</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(ref);</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(colorspace);</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"功能效果\"><a href=\"#功能效果\" class=\"headerlink\" title=\"功能效果\"></a>功能效果</h3><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6lpd4q64g308u0fqnpe.gif\" alt=\"demo示例\"><br>","more":"</p>\n<h3 id=\"功能分析\"><a href=\"#功能分析\" class=\"headerlink\" title=\"功能分析\"></a>功能分析</h3><ul>\n<li><p>功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短</p>\n</li>\n<li><p>OpenGL原理：</p>\n<ul>\n<li><p>因为OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。</p>\n</li>\n<li><p>OpenGL里面坐标是以左下角为原点X轴向上为正，Y轴向右为正</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><ul>\n<li>渲染图片拆分图片：<ul>\n<li>拆分方法1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用GL渲染出图片。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6lpjw6g3j30dw0ee7ft.jpg\" alt=\"拆分三角形\"></p>\n<p>  这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。</p>\n<ul>\n<li>拆分方法2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到6个三角形，8个顶点，如下图：</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6lprpvrrj30dw0eddrh.jpg\" alt=\"拆分2\"></p>\n<p>这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个DEMO中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组<br><figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;   </span><br><span class=\"line\">    <span class=\"number\">-1.2</span>, <span class=\"number\">-1.2</span>,     <span class=\"comment\">//左下</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>, <span class=\"number\">-1.2</span>,      <span class=\"comment\">//右下</span></span><br><span class=\"line\">    <span class=\"number\">-1.2</span>, <span class=\"number\">-0.4</span>,     <span class=\"comment\">//小矩形左下</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>, <span class=\"number\">-0.4</span>,      <span class=\"comment\">//小矩形右下</span></span><br><span class=\"line\">    <span class=\"number\">-1.2</span>,  <span class=\"number\">0.4</span>,     <span class=\"comment\">//小矩形左上</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>,  <span class=\"number\">0.4</span>,      <span class=\"comment\">//小矩形右上</span></span><br><span class=\"line\">    <span class=\"number\">-1.2</span>,  <span class=\"number\">1.2</span>,     <span class=\"comment\">//左上</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span>,  <span class=\"number\">1.2</span>,      <span class=\"comment\">//右上</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//填充纹理的数组</span></span><br><span class=\"line\">GLfloat texCoords[] = &#123;     </span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">0</span>,        <span class=\"comment\">//左下                  //下标为 0 1</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">0</span>,        <span class=\"comment\">//右下                  //下标为2 3</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形左下             //下标为4 5</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形右下             //下标为6 7</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">2.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形左上角           //下标为8 9</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">2.0</span>/<span class=\"number\">3.0</span>,  <span class=\"comment\">//小矩形右上角           //下标为10 11</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>,        <span class=\"comment\">//左上                  //下标为12 13</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">1</span>,        <span class=\"comment\">//右上                  //下标为14 15</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>手动选择区域：通过添加带有自定义手势的UIView 来实现拖动修改选择区域。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">*****************CustomPanView代码******************</span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CustomPanViewDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  开始拖拽</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param customPanView 自身</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param centerY       自身所在的y坐标</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomPanView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"keyword\">id</span>&lt;CustomPanViewDelegate&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">*****************CustomPanViewDelegate代码******************</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 拖拽View的代理方法</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)beginDragWithCoustomPanView:(<span class=\"built_in\">UIView</span> *)customPanView centerY:(<span class=\"built_in\">CGFloat</span>)centerY &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 限制范围：裁剪区不能大于图片区域</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &gt;= imageBottom) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customPanView.center.y &lt;= imageTop) &#123;</span><br><span class=\"line\">        customPanView.center = <span class=\"built_in\">CGPointMake</span>(customPanView.center.x, imageTop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    获取两条线的坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> topY = _topView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> bottomY = _bottomView.center.y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    根据两条线的坐标刷新裁剪区域UI</span></span><br><span class=\"line\">    [_cutLabel setFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    算出裁剪起始坐标和结束坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sendFromePoint:fromPoint endPoint:toPoint];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cutLabel.frame.size.height &lt; <span class=\"number\">30</span>) &#123;  <span class=\"comment\">//隐藏文字</span></span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _cutLabel.text = <span class=\"string\">@\"编辑区域\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.slider setValue:<span class=\"number\">0.0</span> animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpHeight = <span class=\"number\">0.0</span>f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用一个Delegate将拖移后的Y坐标返回，因为是竖直运动的所以我们只关心Y轴坐标。</p>\n<ul>\n<li>改变大小：通过将UISliderBar的ValueChange和顶点坐标关联来实现改变顶点坐标，之后调用GLKView 的display的方法来刷新UI，将变化的过程展现出来。</li>\n</ul>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)action:(UISlider *)sender &#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否是向右滑动</span></span><br><span class=\"line\">    isRightDirection = sender.value &gt;= judgeDirection ? YES : NO;</span><br><span class=\"line\">    <span class=\"comment\">//所改变的高度</span></span><br><span class=\"line\">    changeHeight = sender.value - tmpHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i ++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将Y坐标筛选出来</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//下半部分矩形</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//下半部分矩形Y轴做减法减去变化的高度</span></span><br><span class=\"line\">                <span class=\"keyword\">vertices</span>[i] = verticesCopy[i] - changeHeight;</span><br><span class=\"line\">                <span class=\"comment\">//上半部分矩形</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//上半部分矩形Y轴做加法加上变化的高度</span></span><br><span class=\"line\">                <span class=\"keyword\">vertices</span>[i] = verticesCopy[i] + changeHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//缩小时候如果编辑区域已经成为一条线了就不能在缩小了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">vertices</span>[<span class=\"number\">11</span>] &gt; <span class=\"keyword\">vertices</span>[<span class=\"number\">7</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [self.glView display];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过glReadPixels来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 获取处理后的图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *) createImage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> imageY = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> imgHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRightDirection) &#123; <span class=\"comment\">// 判断slider滑动方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop - fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight + <span class=\"number\">2</span> * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        imageY = fabs(imageTop + fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">        imgHeight = fabs(imageHeight - <span class=\"number\">2</span> * fabs(changeHeight * perOpengleseCoordinate)) * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> imageWidth = SCREEN_WIDTH * screenScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dataLength = imageWidth * imgHeight * <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    GLubyte *data = (GLubyte*)malloc(dataLength * <span class=\"keyword\">sizeof</span>(GLubyte));</span><br><span class=\"line\"></span><br><span class=\"line\">    glPixelStorei(GL_PACK_ALIGNMENT, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    glReadPixels(<span class=\"number\">0</span>, imageY, imageWidth, imgHeight, GL_RGBA, GL_UNSIGNED_BYTE, data);  <span class=\"comment\">//从内存中读取像素</span></span><br><span class=\"line\">    <span class=\"built_in\">CGDataProviderRef</span> ref = <span class=\"built_in\">CGDataProviderCreateWithData</span>(<span class=\"literal\">NULL</span>, data, dataLength, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorspace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> iref = <span class=\"built_in\">CGImageCreate</span>(imageWidth, imgHeight, <span class=\"number\">8</span>, <span class=\"number\">32</span>, imageWidth * <span class=\"number\">4</span>, colorspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast,ref, <span class=\"literal\">NULL</span>, <span class=\"literal\">true</span>, kCGRenderingIntentDefault);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContext</span>(<span class=\"built_in\">CGSizeMake</span>(imageWidth, imgHeight));</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> cgcontext = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGContextSetBlendMode</span>(cgcontext, kCGBlendModeCopy);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(cgcontext, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, imageWidth, imgHeight), iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> imageMasked = <span class=\"built_in\">CGBitmapContextCreateImage</span>(cgcontext);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> * image = [<span class=\"built_in\">UIImage</span> imageWithCGImage:imageMasked scale:screenScale orientation:<span class=\"built_in\">UIImageOrientationUp</span>];</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    free(data);</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(ref);</span><br><span class=\"line\">    <span class=\"built_in\">CFRelease</span>(colorspace);</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(iref);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"NSURLProtocol对WKWebView的处理","date":"2018-01-24T04:24:06.000Z","comments":1,"_content":"之前写过一篇[文章](http://www.jianshu.com/p/cd4c1bf1fd5f)是关于基于NSURLProtocol做的DNS解析，其中对NSURLProtocol也有了简单的介绍，我们都知道他可以拦截所有基于URL Loading System 中的请求，但是对于WKWebview里面所发出的请求即使他是http/https 也无能为力，先来简单的了解下WKWebView.\n<!--more-->\n##### WKWebview\n  iOS8以后，苹果推出了新框架Webkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说WKWebview的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载163的首页\n\n![使用UIWebView的内存](https://ws2.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg)\n![使用WKWebview的内存](https://ws2.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg)\n\n从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃UIWebView也一定有他的道理，就拿本文要讲的NSURLProtocol拦截请求来说，WKWebview的兼容并不UIWebView好，还需要开发者做一些操作。\n##### WebKit源码分析\n  由于WKWebview是基于webkit内核来做的，所以我们在使用的时候需要导入一个这样的东西。\n    #import <WebKit/WebKit.h>\n通过这个我们可以猜到WKWebview中所有的请求以及一些逻辑肯定走的都是webkit里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的URL Loading System，这么说来他的请求不能被NSURLProtocol拦截也是理所当然的了。不过WKWebview是否真的和NSURLProtocol一点关系都没有还需要去研究，幸好webkit是开源的，github上很容易找到[源码](https://github.com/WebKit/webkit)（大小大概是1G多点的zip，花了我将近一天时间来看）。拉下代码直接搜索NSURLProtocol，看看有没有有关的信息\n![搜索结果](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg)\n\n看来的确是有和NSURLProtocol有关系，后面通过断点的调用栈中也找到了\n    + [NSURLProtocol canInitWithRequest:]\n这样的字样，再通过网上查一些资料也证实了我的猜想，其实WKWebview在一开始时候是会调用到NSURLProtocol中的入口方法canInitWithRequest的，但是就没有然后了，也就是说WKWebview是和NSURLProtocol有一定关联，只是在NSURLProtocol的入口处返回NO所以导致NSURLProtocol不接管WKWebview的请求。我们点进webkit源码中的CustomProtocol可以看到，整体的结构我们都差不多，但是我注意到每个CustomProtocol的入口函数都有这样一个判断：\n![入口函数1](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg)\n\n![入口函数2](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg)\n(粉色的可以暂时认定为是它内部的一个custom字符串)通过这个可以猜想，WKWebview并不是不走NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回YES来给你放行，这个规则便是你所请求的URL的Scheme要和它内部配置的CustomScheme相同。不过这里有一个疑问，苹果在使用webkit时候为什么会把http/https这样大众化的scheme过滤掉，看来他是不建议开发者来使用NSURLProtocol。接下来我们来看这个CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的scheme，实在不行就hook嘛。通过翻他的源码发现最终都指向一句代码    \n\n    [WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n方法实现为\n    + (void)registerSchemeForCustomProtocol:(NSString *)scheme\n    {\n        WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);\n    }\n```\nvoid WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(const String& urlScheme)\n{\n    if (!urlScheme)\n        return;\n\n    globalURLSchemesWithCustomProtocolHandlers().add(urlScheme);\n    for (auto* processPool : allProcessPools())\n        processPool->registerSchemeForCustomProtocol(urlScheme);\n}\n```\n通过方法名字可以看出这个就是那个向webkit注册CustomScheme的方法，只要我们在注册完我们自己的CustomProtocol之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想(他也是这么写的)\n![webkit源码](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg)\n##### 具体实施\n  找到了方法就要去实施，不过因为registerSchemeForCustomProtocol是WKBrowsingContextController的类方法，所以只能用WKBrowsingContextController去调用，但是在webkit的头文件发现WKBrowsingContextController并没有开放出来，所以我们采用NSClassFromString和NSSelectorFromString方法来拿到类和对应的方法，整体代码如下\n```\n    //注册自己的protocol\n    [NSURLProtocol registerClass:[CustomProtocol class]];\n\n    //创建WKWebview\n    WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init];\n    WKWebView * wkWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) configuration:config];\n    [wkWebView loadRequest:webViewReq];\n    [self.view addSubview:wkWebView];\n\n    //注册scheme\n    Class cls = NSClassFromString(@\"WKBrowsingContextController\");\n    SEL sel = NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");\n    if ([cls respondsToSelector:sel]) {\n        // 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System\n        [cls performSelector:sel withObject:@\"http\"];\n        [cls performSelector:sel withObject:@\"https\"];\n    }\n```\n  实现效果。我将网页中所有的图片替换成了柴犬图片\n\n![效果](https://ws1.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif)\n\n##### 值得注意\n   * 关于私有API\n\n  因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。\n\n* 关于post请求\n大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在之前的[文章](http://www.jianshu.com/p/cd4c1bf1fd5f)也有提过\n\n```  \n#pragma mark -\n#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体\n- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request {\n    NSMutableURLRequest * req = [request mutableCopy];\n    if ([request.HTTPMethod isEqualToString:@\"POST\"]) {\n        if (!request.HTTPBody) {\n            uint8_t d[1024] = {0};\n            NSInputStream *stream = request.HTTPBodyStream;\n            NSMutableData *data = [[NSMutableData alloc] init];\n            [stream open];\n            while ([stream hasBytesAvailable]) {\n                NSInteger len = [stream read:d maxLength:1024];\n                if (len > 0 && stream.streamError == nil) {\n                    [data appendBytes:(void *)d length:len];\n                }\n            }\n            req.HTTPBody = [data copy];\n            [stream close];\n        }\n    }\n    return req;\n}\n```\n","source":"_posts/2018-01-24-NSURLProtocol对WKWebView的处理.md","raw":"---\ntitle: NSURLProtocol对WKWebView的处理\ncategories: iOS开发\ndate: 2018-01-24 12:24:06\ntags:\n  - webview\n  - hook\ncomments:\n---\n之前写过一篇[文章](http://www.jianshu.com/p/cd4c1bf1fd5f)是关于基于NSURLProtocol做的DNS解析，其中对NSURLProtocol也有了简单的介绍，我们都知道他可以拦截所有基于URL Loading System 中的请求，但是对于WKWebview里面所发出的请求即使他是http/https 也无能为力，先来简单的了解下WKWebView.\n<!--more-->\n##### WKWebview\n  iOS8以后，苹果推出了新框架Webkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说WKWebview的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载163的首页\n\n![使用UIWebView的内存](https://ws2.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg)\n![使用WKWebview的内存](https://ws2.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg)\n\n从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃UIWebView也一定有他的道理，就拿本文要讲的NSURLProtocol拦截请求来说，WKWebview的兼容并不UIWebView好，还需要开发者做一些操作。\n##### WebKit源码分析\n  由于WKWebview是基于webkit内核来做的，所以我们在使用的时候需要导入一个这样的东西。\n    #import <WebKit/WebKit.h>\n通过这个我们可以猜到WKWebview中所有的请求以及一些逻辑肯定走的都是webkit里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的URL Loading System，这么说来他的请求不能被NSURLProtocol拦截也是理所当然的了。不过WKWebview是否真的和NSURLProtocol一点关系都没有还需要去研究，幸好webkit是开源的，github上很容易找到[源码](https://github.com/WebKit/webkit)（大小大概是1G多点的zip，花了我将近一天时间来看）。拉下代码直接搜索NSURLProtocol，看看有没有有关的信息\n![搜索结果](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg)\n\n看来的确是有和NSURLProtocol有关系，后面通过断点的调用栈中也找到了\n    + [NSURLProtocol canInitWithRequest:]\n这样的字样，再通过网上查一些资料也证实了我的猜想，其实WKWebview在一开始时候是会调用到NSURLProtocol中的入口方法canInitWithRequest的，但是就没有然后了，也就是说WKWebview是和NSURLProtocol有一定关联，只是在NSURLProtocol的入口处返回NO所以导致NSURLProtocol不接管WKWebview的请求。我们点进webkit源码中的CustomProtocol可以看到，整体的结构我们都差不多，但是我注意到每个CustomProtocol的入口函数都有这样一个判断：\n![入口函数1](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg)\n\n![入口函数2](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg)\n(粉色的可以暂时认定为是它内部的一个custom字符串)通过这个可以猜想，WKWebview并不是不走NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回YES来给你放行，这个规则便是你所请求的URL的Scheme要和它内部配置的CustomScheme相同。不过这里有一个疑问，苹果在使用webkit时候为什么会把http/https这样大众化的scheme过滤掉，看来他是不建议开发者来使用NSURLProtocol。接下来我们来看这个CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的scheme，实在不行就hook嘛。通过翻他的源码发现最终都指向一句代码    \n\n    [WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n方法实现为\n    + (void)registerSchemeForCustomProtocol:(NSString *)scheme\n    {\n        WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);\n    }\n```\nvoid WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(const String& urlScheme)\n{\n    if (!urlScheme)\n        return;\n\n    globalURLSchemesWithCustomProtocolHandlers().add(urlScheme);\n    for (auto* processPool : allProcessPools())\n        processPool->registerSchemeForCustomProtocol(urlScheme);\n}\n```\n通过方法名字可以看出这个就是那个向webkit注册CustomScheme的方法，只要我们在注册完我们自己的CustomProtocol之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想(他也是这么写的)\n![webkit源码](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg)\n##### 具体实施\n  找到了方法就要去实施，不过因为registerSchemeForCustomProtocol是WKBrowsingContextController的类方法，所以只能用WKBrowsingContextController去调用，但是在webkit的头文件发现WKBrowsingContextController并没有开放出来，所以我们采用NSClassFromString和NSSelectorFromString方法来拿到类和对应的方法，整体代码如下\n```\n    //注册自己的protocol\n    [NSURLProtocol registerClass:[CustomProtocol class]];\n\n    //创建WKWebview\n    WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init];\n    WKWebView * wkWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) configuration:config];\n    [wkWebView loadRequest:webViewReq];\n    [self.view addSubview:wkWebView];\n\n    //注册scheme\n    Class cls = NSClassFromString(@\"WKBrowsingContextController\");\n    SEL sel = NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");\n    if ([cls respondsToSelector:sel]) {\n        // 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System\n        [cls performSelector:sel withObject:@\"http\"];\n        [cls performSelector:sel withObject:@\"https\"];\n    }\n```\n  实现效果。我将网页中所有的图片替换成了柴犬图片\n\n![效果](https://ws1.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif)\n\n##### 值得注意\n   * 关于私有API\n\n  因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。\n\n* 关于post请求\n大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在之前的[文章](http://www.jianshu.com/p/cd4c1bf1fd5f)也有提过\n\n```  \n#pragma mark -\n#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体\n- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request {\n    NSMutableURLRequest * req = [request mutableCopy];\n    if ([request.HTTPMethod isEqualToString:@\"POST\"]) {\n        if (!request.HTTPBody) {\n            uint8_t d[1024] = {0};\n            NSInputStream *stream = request.HTTPBodyStream;\n            NSMutableData *data = [[NSMutableData alloc] init];\n            [stream open];\n            while ([stream hasBytesAvailable]) {\n                NSInteger len = [stream read:d maxLength:1024];\n                if (len > 0 && stream.streamError == nil) {\n                    [data appendBytes:(void *)d length:len];\n                }\n            }\n            req.HTTPBody = [data copy];\n            [stream close];\n        }\n    }\n    return req;\n}\n```\n","slug":"NSURLProtocol对WKWebView的处理","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2ky000ia04w4pllyeq6","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>之前写过一篇<a href=\"http://www.jianshu.com/p/cd4c1bf1fd5f\" target=\"_blank\" rel=\"noopener\">文章</a>是关于基于NSURLProtocol做的DNS解析，其中对NSURLProtocol也有了简单的介绍，我们都知道他可以拦截所有基于URL Loading System 中的请求，但是对于WKWebview里面所发出的请求即使他是http/https 也无能为力，先来简单的了解下WKWebView.<br><a id=\"more\"></a></p>\n<h5 id=\"WKWebview\"><a href=\"#WKWebview\" class=\"headerlink\" title=\"WKWebview\"></a>WKWebview</h5><p>  iOS8以后，苹果推出了新框架Webkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说WKWebview的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载163的首页</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg\" alt=\"使用UIWebView的内存\"><br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg\" alt=\"使用WKWebview的内存\"></p>\n<p>从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃UIWebView也一定有他的道理，就拿本文要讲的NSURLProtocol拦截请求来说，WKWebview的兼容并不UIWebView好，还需要开发者做一些操作。</p>\n<h5 id=\"WebKit源码分析\"><a href=\"#WebKit源码分析\" class=\"headerlink\" title=\"WebKit源码分析\"></a>WebKit源码分析</h5><p>  由于WKWebview是基于webkit内核来做的，所以我们在使用的时候需要导入一个这样的东西。</p>\n<pre><code>#import &lt;WebKit/WebKit.h&gt;\n</code></pre><p>通过这个我们可以猜到WKWebview中所有的请求以及一些逻辑肯定走的都是webkit里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的URL Loading System，这么说来他的请求不能被NSURLProtocol拦截也是理所当然的了。不过WKWebview是否真的和NSURLProtocol一点关系都没有还需要去研究，幸好webkit是开源的，github上很容易找到<a href=\"https://github.com/WebKit/webkit\" target=\"_blank\" rel=\"noopener\">源码</a>（大小大概是1G多点的zip，花了我将近一天时间来看）。拉下代码直接搜索NSURLProtocol，看看有没有有关的信息<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg\" alt=\"搜索结果\"></p>\n<p>看来的确是有和NSURLProtocol有关系，后面通过断点的调用栈中也找到了</p>\n<pre><code>+ [NSURLProtocol canInitWithRequest:]\n</code></pre><p>这样的字样，再通过网上查一些资料也证实了我的猜想，其实WKWebview在一开始时候是会调用到NSURLProtocol中的入口方法canInitWithRequest的，但是就没有然后了，也就是说WKWebview是和NSURLProtocol有一定关联，只是在NSURLProtocol的入口处返回NO所以导致NSURLProtocol不接管WKWebview的请求。我们点进webkit源码中的CustomProtocol可以看到，整体的结构我们都差不多，但是我注意到每个CustomProtocol的入口函数都有这样一个判断：<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg\" alt=\"入口函数1\"></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg\" alt=\"入口函数2\"><br>(粉色的可以暂时认定为是它内部的一个custom字符串)通过这个可以猜想，WKWebview并不是不走NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回YES来给你放行，这个规则便是你所请求的URL的Scheme要和它内部配置的CustomScheme相同。不过这里有一个疑问，苹果在使用webkit时候为什么会把http/https这样大众化的scheme过滤掉，看来他是不建议开发者来使用NSURLProtocol。接下来我们来看这个CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的scheme，实在不行就hook嘛。通过翻他的源码发现最终都指向一句代码    </p>\n<pre><code>[WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n</code></pre><p>方法实现为</p>\n<pre><code>+ (void)registerSchemeForCustomProtocol:(NSString *)scheme\n{\n    WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);\n}\n</code></pre><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(<span class=\"keyword\">const</span> String&amp; urlScheme)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!urlScheme)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    globalURLSchemesWithCustomProtocolHandlers().add(urlScheme);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>* processPool : allProcessPools())</span><br><span class=\"line\">        processPool-&gt;registerSchemeForCustomProtocol(urlScheme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过方法名字可以看出这个就是那个向webkit注册CustomScheme的方法，只要我们在注册完我们自己的CustomProtocol之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想(他也是这么写的)<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg\" alt=\"webkit源码\"></p>\n<h5 id=\"具体实施\"><a href=\"#具体实施\" class=\"headerlink\" title=\"具体实施\"></a>具体实施</h5><p>  找到了方法就要去实施，不过因为registerSchemeForCustomProtocol是WKBrowsingContextController的类方法，所以只能用WKBrowsingContextController去调用，但是在webkit的头文件发现WKBrowsingContextController并没有开放出来，所以我们采用NSClassFromString和NSSelectorFromString方法来拿到类和对应的方法，整体代码如下<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册自己的protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建WKWebview</span></span><br><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> * config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKWebView</span> * wkWebView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height) configuration:config];</span><br><span class=\"line\">[wkWebView loadRequest:webViewReq];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:wkWebView];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册scheme</span></span><br><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"WKBrowsingContextController\"</span>);</span><br><span class=\"line\">SEL sel = <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"registerSchemeForCustomProtocol:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System</span></span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@\"http\"</span>];</span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@\"https\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  实现效果。我将网页中所有的图片替换成了柴犬图片</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif\" alt=\"效果\"></p>\n<h5 id=\"值得注意\"><a href=\"#值得注意\" class=\"headerlink\" title=\"值得注意\"></a>值得注意</h5><ul>\n<li>关于私有API</li>\n</ul>\n<p>  因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。</p>\n<ul>\n<li>关于post请求<br>大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在之前的<a href=\"http://www.jianshu.com/p/cd4c1bf1fd5f\" target=\"_blank\" rel=\"noopener\">文章</a>也有提过</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@\"POST\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"keyword\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>之前写过一篇<a href=\"http://www.jianshu.com/p/cd4c1bf1fd5f\" target=\"_blank\" rel=\"noopener\">文章</a>是关于基于NSURLProtocol做的DNS解析，其中对NSURLProtocol也有了简单的介绍，我们都知道他可以拦截所有基于URL Loading System 中的请求，但是对于WKWebview里面所发出的请求即使他是http/https 也无能为力，先来简单的了解下WKWebView.<br>","more":"</p>\n<h5 id=\"WKWebview\"><a href=\"#WKWebview\" class=\"headerlink\" title=\"WKWebview\"></a>WKWebview</h5><p>  iOS8以后，苹果推出了新框架Webkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说WKWebview的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载163的首页</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6k80vn82j3087036wem.jpg\" alt=\"使用UIWebView的内存\"><br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6k8agxuoj308002smx3.jpg\" alt=\"使用WKWebview的内存\"></p>\n<p>从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃UIWebView也一定有他的道理，就拿本文要讲的NSURLProtocol拦截请求来说，WKWebview的兼容并不UIWebView好，还需要开发者做一些操作。</p>\n<h5 id=\"WebKit源码分析\"><a href=\"#WebKit源码分析\" class=\"headerlink\" title=\"WebKit源码分析\"></a>WebKit源码分析</h5><p>  由于WKWebview是基于webkit内核来做的，所以我们在使用的时候需要导入一个这样的东西。</p>\n<pre><code>#import &lt;WebKit/WebKit.h&gt;\n</code></pre><p>通过这个我们可以猜到WKWebview中所有的请求以及一些逻辑肯定走的都是webkit里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的URL Loading System，这么说来他的请求不能被NSURLProtocol拦截也是理所当然的了。不过WKWebview是否真的和NSURLProtocol一点关系都没有还需要去研究，幸好webkit是开源的，github上很容易找到<a href=\"https://github.com/WebKit/webkit\" target=\"_blank\" rel=\"noopener\">源码</a>（大小大概是1G多点的zip，花了我将近一天时间来看）。拉下代码直接搜索NSURLProtocol，看看有没有有关的信息<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k8kigkxj30i80t0tg8.jpg\" alt=\"搜索结果\"></p>\n<p>看来的确是有和NSURLProtocol有关系，后面通过断点的调用栈中也找到了</p>\n<pre><code>+ [NSURLProtocol canInitWithRequest:]\n</code></pre><p>这样的字样，再通过网上查一些资料也证实了我的猜想，其实WKWebview在一开始时候是会调用到NSURLProtocol中的入口方法canInitWithRequest的，但是就没有然后了，也就是说WKWebview是和NSURLProtocol有一定关联，只是在NSURLProtocol的入口处返回NO所以导致NSURLProtocol不接管WKWebview的请求。我们点进webkit源码中的CustomProtocol可以看到，整体的结构我们都差不多，但是我注意到每个CustomProtocol的入口函数都有这样一个判断：<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k8wgu6tj30yg04x40p.jpg\" alt=\"入口函数1\"></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k93edfij30rw05ijsb.jpg\" alt=\"入口函数2\"><br>(粉色的可以暂时认定为是它内部的一个custom字符串)通过这个可以猜想，WKWebview并不是不走NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回YES来给你放行，这个规则便是你所请求的URL的Scheme要和它内部配置的CustomScheme相同。不过这里有一个疑问，苹果在使用webkit时候为什么会把http/https这样大众化的scheme过滤掉，看来他是不建议开发者来使用NSURLProtocol。接下来我们来看这个CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的scheme，实在不行就hook嘛。通过翻他的源码发现最终都指向一句代码    </p>\n<pre><code>[WKBrowsingContextController registerSchemeForCustomProtocol:testScheme];\n</code></pre><p>方法实现为</p>\n<pre><code>+ (void)registerSchemeForCustomProtocol:(NSString *)scheme\n{\n    WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme);\n}\n</code></pre><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(<span class=\"keyword\">const</span> String&amp; urlScheme)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!urlScheme)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    globalURLSchemesWithCustomProtocolHandlers().add(urlScheme);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>* processPool : allProcessPools())</span><br><span class=\"line\">        processPool-&gt;registerSchemeForCustomProtocol(urlScheme);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过方法名字可以看出这个就是那个向webkit注册CustomScheme的方法，只要我们在注册完我们自己的CustomProtocol之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想(他也是这么写的)<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k9nobq7j30yg04tmzt.jpg\" alt=\"webkit源码\"></p>\n<h5 id=\"具体实施\"><a href=\"#具体实施\" class=\"headerlink\" title=\"具体实施\"></a>具体实施</h5><p>  找到了方法就要去实施，不过因为registerSchemeForCustomProtocol是WKBrowsingContextController的类方法，所以只能用WKBrowsingContextController去调用，但是在webkit的头文件发现WKBrowsingContextController并没有开放出来，所以我们采用NSClassFromString和NSSelectorFromString方法来拿到类和对应的方法，整体代码如下<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册自己的protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建WKWebview</span></span><br><span class=\"line\"><span class=\"built_in\">WKWebViewConfiguration</span> * config = [[<span class=\"built_in\">WKWebViewConfiguration</span> alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">WKWebView</span> * wkWebView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.height) configuration:config];</span><br><span class=\"line\">[wkWebView loadRequest:webViewReq];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:wkWebView];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册scheme</span></span><br><span class=\"line\">Class cls = <span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"WKBrowsingContextController\"</span>);</span><br><span class=\"line\">SEL sel = <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"registerSchemeForCustomProtocol:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System</span></span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@\"http\"</span>];</span><br><span class=\"line\">    [cls performSelector:sel withObject:<span class=\"string\">@\"https\"</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  实现效果。我将网页中所有的图片替换成了柴犬图片</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6ka7rv18g307o0ds7wl.gif\" alt=\"效果\"></p>\n<h5 id=\"值得注意\"><a href=\"#值得注意\" class=\"headerlink\" title=\"值得注意\"></a>值得注意</h5><ul>\n<li>关于私有API</li>\n</ul>\n<p>  因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。</p>\n<ul>\n<li>关于post请求<br>大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在之前的<a href=\"http://www.jianshu.com/p/cd4c1bf1fd5f\" target=\"_blank\" rel=\"noopener\">文章</a>也有提过</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@\"POST\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"keyword\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iOS Runtime简单介绍，以及不同类的Method Swizzling","date":"2018-01-24T04:18:50.000Z","comments":1,"_content":"##### Runtime介绍：\n runtime顾名思义就是运行时，其实我们的App从你按下command+R开始一直到App运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg)\n\n这里给大家解释下：首先， * testObject 是告诉编译器，testObject是一个指向某个Objective-C对象的指针。因为不管指向的是什么类型的对象，\n<!--more-->\n一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把testObject当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告。接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在testObject里。那么运行时(从这段代码执行开始，到程序结束)，testObject指向的内存空间就是一个NSData对象。你可以把testObject当做一个NSData对象来用。 所以编译时是NSString，运行时是NSData。\nruntime是什么：\n在runtime中，所有的类在OC中都会被定义成一个结构体，像这样\n类在runtime中的表示\nstruct objc_class {\n    Class isa;//指针，顾名思义，表示是一个什么，  //实例的isa指向类对象，类对象的isa指向元类\n```\n#if !__OBJC2__\n        Class super_class;  //指向父类\n        const char *name;  //类名\n        long version;     //类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。\n        long info;   /*供运行期使用的一些位标识。有如下一些位掩码：\n                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；\n                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；\n                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；\n                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；\n                      CLS_MAPPED (0x10L) 为ObjC运行期所使用\n                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用\n                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用\n                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用\n                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/\n        long instance_size  //该类的实例变量大小（包括从父类继承下来的实例变量）；\n        struct objc_ivar_list *ivars //成员变量列表\n        struct objc_method_list **methodLists; //方法列表\n        struct objc_cache *cache;//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存\n        struct objc_protocol_list *protocols //协议列表\n        #endif\n} OBJC2_UNAVAILABLE;\n```\n相关的定义\n/// 描述类中的一个方法\ntypedef struct objc_method *Method;\n\n/// 实例变量\ntypedef struct objc_ivar *Ivar;\n\n/// 类别Category\ntypedef struct objc_category *Category;\n\n/// 类中声明的属性\ntypedef struct objc_property *objc_property_t;\n\nObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。\n\n##### runtime能干什么：\n* ：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取public和private的。\n\n```\nunsigned int count;\n    Class clas = [WKWebViewController class]; //是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了\n\n    objc_property_t * propertyList = class_copyPropertyList(clas, &count);\n    for (int i = 0; i < count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"  %@  属性(包括私有) -------->>>>>    %@\",clas,[NSString stringWithUTF8String:propertyName]);\n    }\n    NSLog(@\"-------------------------------------------------------------------------------------------------------------- \");\n\n    Method * methodList = class_copyMethodList(clas, &count);\n    for (int i = 0; i < count; i++) {\n        Method methodName = methodList[i];\n        NSLog(@\"  %@ 方法(包括私有)  -------->>>>>    %@\",clas,NSStringFromSelector(method_getName(methodName)));\n    }\n    NSLog(@\"-------------------------------------------------------------------------------------------------------------- \");\n\n\n    Ivar *ivarList = class_copyIvarList(clas, &count);\n    for (int i = 0; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"%@ 成员变量(包括私有) -------->>>>> %@\",clas, [NSString stringWithUTF8String:ivarName]);\n    }\n    NSLog(@\"-------------------------------------------------------------------------------------------------------------- \");\n\n\n    //获取协议列表\n    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (int i = 0; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"%@ 协议 -------->>>>> %@\",clas, [NSString stringWithUTF8String:protocolName]);\n    }\n```\n输出后的结果是\n![image.png](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg)\n其中也包括了私有方法。\n\n* 2：拦截方法调用\n有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！\n![image.png](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg)\n\n这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时runtime会将这段代码转换为objc_msgSend(obj, [@selector]);（本质就是发送消息）然后obj会通过其中isa指针去该类的缓存中(cache)查找对应函数的Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过method中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。\n\n```\n/**\n    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理\n */\n+(BOOL)resolveInstanceMethod:(SEL)sel {\n    return YES;\n}\n\n/**\n 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理\n */\n+(BOOL)resolveClassMethod:(SEL)sel {\n    return YES;\n}\n\n/**\n 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的\n 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃\n */\n-(id)forwardingTargetForSelector:(SEL)aSelector {\n\n}\n\n/**\n 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后\n 调用invokeWithTarget让某个target来处理该方法\n */\n-(void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:self];\n}\n```\n\n* 3：动态添加方法\n因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示\n\n```\n- (void) errorMethod {\n    NSLog(@\"no method!!!!!!!\");\n}\n```\n如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个error1：，那么一旦调用了没有的方法就会走这个。我们来看代码\n\n```\n+(BOOL)resolveInstanceMethod:(SEL)sel {\n    Method errorMethod =  class_getInstanceMethod([self class], @selector(errorMethod));\n    if ([NSStringFromSelector(sel) isEqualToString:@\"testMethod\"]) {\n        BOOL isAdd =  class_addMethod([self class], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod));\n        NSLog(@\"tinajia  = %d\",isAdd);\n    }\n    //Do something\n    return YES;\n}\n```\n\n主要用到\n\n```\n/**\n    添加方法\n     @param class] 在哪个类里添加\n     @param sel 添加的方法的名字\n     @param errorMethod 添加的方法的实现IMP指\n     @param types 方法的标示符\n     @return 是否添加成功\n         */\nBOOL isAdd =  class_addMethod([self class], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod));\n\n```\n\n然后运行下：\n\n```\nWKWebViewController * vc= [[WKWebViewController alloc] init];\n[vc performSelector:@selector(testMethod)];\n\n```\n\n我调用了并不存在的testMethod方法并没有崩溃并且方法已经成功添加了\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg)\n\n* 4：动态交换方法（也叫iOS黑魔法，慎用）\n没什么好例子，用一个网上说的例子(引用别人的东西，懒得复制了，就截了图)\n\n  ![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg)\n\n  其实本质即使SEL和IMP的交换，原理是这样的：在iOS中每一个类中都有一个叫dispatch table的东西，里面存放在SEL 和他所对应的IMP指针，之前也说过方法调用就是通过sel找IMP指针然后指针定位调用方法。方法交换就是对这个dispatch table进行操作。让A的SEL去对应B的IMP，B的SEL对应A的IMP，如图\n\n  ![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg)\n\n  这样就达到方法交换的目的，下面看代码：\n\n```\n+ (void)changeMethod {\n    //  如果是类方法 要使用 !\n    //  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet\n    //  Class  class = NSClassFromString(@\"__NSSetM\");\n    //  Class metaClass = objc_getMetaClass([NSStringFromClass(class) UTF8String]);\n    Class systemClass = NSClassFromString(__NSSetM);\n\n    SEL sel_System = NSSelectorFromString(addObject:);\n    SEL sel_Custom = @selector(swizzle_addObject:);\n\n    Method method_System = class_getInstanceMethod(systemClass, sel_System);\n    Method method_Custom = class_getInstanceMethod([self class], sel_Custom);\n\n    IMP imp_System = method_getImplementation(method_System);\n    IMP imp_Custom = method_getImplementation(method_Custom);\n\n    method_exchangeImplementations(method_System, method_Custom);\n}\n\n- (void)swizzle_addObject:(id) obj {\n    if (obj) {\n        [self swizzle_addObject:obj];\n    }\n}\n\n```\n\n主要代码  method_exchangeImplementations(method1, method2); 这两个参数很简单，就是两个需要交换的方法。\n最后我调用了m1但是实际上走了m2。\n\n##### 动态交换方法的原理以及交换过程中指针的变化\n\n在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个category，然后hook的方法会写在category中。另一种是自己创建一个Tool类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要hook的类非常多的(我实际项目中就遇到这样的问题)那你就需要针对不同的类创建category，就会导致文件过多，且每一个文件中只有一个hook方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg)\n\n我要hook的是ViewController中的viewDidLoad方法，我建立了两个类一个是ViewController的category，另一个是Tool类，为了一会区别演示不同类hook的不同(两个类中hook的代码完全一样)\n* ViewController中将要被替换的系统方法\n\n![被替换的方法(系统方法)](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg)\n\n\n* Category中将要用来替换的自定义方法\n\n![用来替换的方法(自定义方法)](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg)\n* 然后在ViewController中的load中做方法替换\n\n![进行方法替换](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg)\n\n运行一下的输出结果想必大家已经猜到了先执行custom再执行system，这是通常情况下大家的做法。\n![结果](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg)\n\n下面再来看下如果我将替换方法写在不同类中会怎样，调用Tool中的交换方法\n\n![执行Tool中的交换方法](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg)\n\n然后直接看结果了，因为代码都是一模一样的我直接复制过去的\n\n![结果](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg)\n\n发生了crash，原因是ViewController中没有swizzel_viewDidLoad_custom这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg)\n\n解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把customMethod添加到SystemClass中，但是注意要把customMethod的实现指向syetemMethod的实现。这样一来就可以达到SystemClass调用customMethod却执行systemMethod的代码的效果，实现以上要求我们需要在交换之前执行这个方法。\n\n```\nclass_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))\n```\n\n其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样\n\n```\n.\n.\n之前的都一样就省略\n.\n.\nif (class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))) {\n        class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System));\n    } else {\n        method_exchangeImplementations(method_System, method_Custom);\n    }\n\n```\n\n我们来看下执行完add操作之后此时的方法和类的对应关系(红色的为add的修改)\n\n\n![关系](https://ws4.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg)\n\n\n因为SystemClass中本身不包含customMethod所以add一定是成功的，也就是说会进入判断执行replace方法。\n\n```\nclass_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System));\n\n```\n\n第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完replace之后的类与方法名以及他们实现的关系(红色的为replace的修改)。\n\n![关系](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg)\n\n此时大家已经看出来了，虽然没有执行exchange方法，但是我已经达到了方法交换的目的。系统执行systemMethod时候会走customMethod的实现但是因为在customMethod方法中我会递归执行[self customMethod]，所以又会走到systemMethod的实现，因为之前进行了方法添加，所以此时A类中有了customMethod方法，不会再发生之前的crash。达到一个不同类进行Method Swizzling的目的。\n\n##### 综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\n\n```\n+ (void)changeMethod {\n\n    Class systemClass = NSClassFromString(@\"你的类\");\n\n    SEL sel_System = @selector(系统方法);\n    SEL sel_Custom = @selector(你自己的方法);\n\n    Method method_System = class_getInstanceMethod(systemClass, sel_System);\n    Method method_Custom = class_getInstanceMethod([self class], sel_Custom);\n\n    IMP imp_System = method_getImplementation(method_System);\n    IMP imp_Custom = method_getImplementation(method_Custom);\n\n    if (class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))) {\n        class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System));\n    } else {\n        method_exchangeImplementations(method_System, method_Custom);\n    }\n}\n\n```\n\n##### 以上代码无论是写在工具类中还是category中都是没有问题的。\n","source":"_posts/2018-01-24-iOS-Runtime简单介绍，以及不同类的Method-Swizzling.md","raw":"---\ntitle: iOS Runtime简单介绍，以及不同类的Method Swizzling\ncategories: iOS开发\ndate: 2018-01-24 12:18:50\ntags:\n  - runtime\n  - 底层\ncomments:\n---\n##### Runtime介绍：\n runtime顾名思义就是运行时，其实我们的App从你按下command+R开始一直到App运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg)\n\n这里给大家解释下：首先， * testObject 是告诉编译器，testObject是一个指向某个Objective-C对象的指针。因为不管指向的是什么类型的对象，\n<!--more-->\n一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把testObject当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告。接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在testObject里。那么运行时(从这段代码执行开始，到程序结束)，testObject指向的内存空间就是一个NSData对象。你可以把testObject当做一个NSData对象来用。 所以编译时是NSString，运行时是NSData。\nruntime是什么：\n在runtime中，所有的类在OC中都会被定义成一个结构体，像这样\n类在runtime中的表示\nstruct objc_class {\n    Class isa;//指针，顾名思义，表示是一个什么，  //实例的isa指向类对象，类对象的isa指向元类\n```\n#if !__OBJC2__\n        Class super_class;  //指向父类\n        const char *name;  //类名\n        long version;     //类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。\n        long info;   /*供运行期使用的一些位标识。有如下一些位掩码：\n                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；\n                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；\n                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；\n                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；\n                      CLS_MAPPED (0x10L) 为ObjC运行期所使用\n                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用\n                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用\n                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用\n                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/\n        long instance_size  //该类的实例变量大小（包括从父类继承下来的实例变量）；\n        struct objc_ivar_list *ivars //成员变量列表\n        struct objc_method_list **methodLists; //方法列表\n        struct objc_cache *cache;//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存\n        struct objc_protocol_list *protocols //协议列表\n        #endif\n} OBJC2_UNAVAILABLE;\n```\n相关的定义\n/// 描述类中的一个方法\ntypedef struct objc_method *Method;\n\n/// 实例变量\ntypedef struct objc_ivar *Ivar;\n\n/// 类别Category\ntypedef struct objc_category *Category;\n\n/// 类中声明的属性\ntypedef struct objc_property *objc_property_t;\n\nObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。\n\n##### runtime能干什么：\n* ：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取public和private的。\n\n```\nunsigned int count;\n    Class clas = [WKWebViewController class]; //是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了\n\n    objc_property_t * propertyList = class_copyPropertyList(clas, &count);\n    for (int i = 0; i < count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"  %@  属性(包括私有) -------->>>>>    %@\",clas,[NSString stringWithUTF8String:propertyName]);\n    }\n    NSLog(@\"-------------------------------------------------------------------------------------------------------------- \");\n\n    Method * methodList = class_copyMethodList(clas, &count);\n    for (int i = 0; i < count; i++) {\n        Method methodName = methodList[i];\n        NSLog(@\"  %@ 方法(包括私有)  -------->>>>>    %@\",clas,NSStringFromSelector(method_getName(methodName)));\n    }\n    NSLog(@\"-------------------------------------------------------------------------------------------------------------- \");\n\n\n    Ivar *ivarList = class_copyIvarList(clas, &count);\n    for (int i = 0; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"%@ 成员变量(包括私有) -------->>>>> %@\",clas, [NSString stringWithUTF8String:ivarName]);\n    }\n    NSLog(@\"-------------------------------------------------------------------------------------------------------------- \");\n\n\n    //获取协议列表\n    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (int i = 0; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"%@ 协议 -------->>>>> %@\",clas, [NSString stringWithUTF8String:protocolName]);\n    }\n```\n输出后的结果是\n![image.png](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg)\n其中也包括了私有方法。\n\n* 2：拦截方法调用\n有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！\n![image.png](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg)\n\n这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时runtime会将这段代码转换为objc_msgSend(obj, [@selector]);（本质就是发送消息）然后obj会通过其中isa指针去该类的缓存中(cache)查找对应函数的Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过method中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。\n\n```\n/**\n    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理\n */\n+(BOOL)resolveInstanceMethod:(SEL)sel {\n    return YES;\n}\n\n/**\n 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理\n */\n+(BOOL)resolveClassMethod:(SEL)sel {\n    return YES;\n}\n\n/**\n 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的\n 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃\n */\n-(id)forwardingTargetForSelector:(SEL)aSelector {\n\n}\n\n/**\n 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后\n 调用invokeWithTarget让某个target来处理该方法\n */\n-(void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:self];\n}\n```\n\n* 3：动态添加方法\n因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示\n\n```\n- (void) errorMethod {\n    NSLog(@\"no method!!!!!!!\");\n}\n```\n如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个error1：，那么一旦调用了没有的方法就会走这个。我们来看代码\n\n```\n+(BOOL)resolveInstanceMethod:(SEL)sel {\n    Method errorMethod =  class_getInstanceMethod([self class], @selector(errorMethod));\n    if ([NSStringFromSelector(sel) isEqualToString:@\"testMethod\"]) {\n        BOOL isAdd =  class_addMethod([self class], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod));\n        NSLog(@\"tinajia  = %d\",isAdd);\n    }\n    //Do something\n    return YES;\n}\n```\n\n主要用到\n\n```\n/**\n    添加方法\n     @param class] 在哪个类里添加\n     @param sel 添加的方法的名字\n     @param errorMethod 添加的方法的实现IMP指\n     @param types 方法的标示符\n     @return 是否添加成功\n         */\nBOOL isAdd =  class_addMethod([self class], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod));\n\n```\n\n然后运行下：\n\n```\nWKWebViewController * vc= [[WKWebViewController alloc] init];\n[vc performSelector:@selector(testMethod)];\n\n```\n\n我调用了并不存在的testMethod方法并没有崩溃并且方法已经成功添加了\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg)\n\n* 4：动态交换方法（也叫iOS黑魔法，慎用）\n没什么好例子，用一个网上说的例子(引用别人的东西，懒得复制了，就截了图)\n\n  ![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg)\n\n  其实本质即使SEL和IMP的交换，原理是这样的：在iOS中每一个类中都有一个叫dispatch table的东西，里面存放在SEL 和他所对应的IMP指针，之前也说过方法调用就是通过sel找IMP指针然后指针定位调用方法。方法交换就是对这个dispatch table进行操作。让A的SEL去对应B的IMP，B的SEL对应A的IMP，如图\n\n  ![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg)\n\n  这样就达到方法交换的目的，下面看代码：\n\n```\n+ (void)changeMethod {\n    //  如果是类方法 要使用 !\n    //  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet\n    //  Class  class = NSClassFromString(@\"__NSSetM\");\n    //  Class metaClass = objc_getMetaClass([NSStringFromClass(class) UTF8String]);\n    Class systemClass = NSClassFromString(__NSSetM);\n\n    SEL sel_System = NSSelectorFromString(addObject:);\n    SEL sel_Custom = @selector(swizzle_addObject:);\n\n    Method method_System = class_getInstanceMethod(systemClass, sel_System);\n    Method method_Custom = class_getInstanceMethod([self class], sel_Custom);\n\n    IMP imp_System = method_getImplementation(method_System);\n    IMP imp_Custom = method_getImplementation(method_Custom);\n\n    method_exchangeImplementations(method_System, method_Custom);\n}\n\n- (void)swizzle_addObject:(id) obj {\n    if (obj) {\n        [self swizzle_addObject:obj];\n    }\n}\n\n```\n\n主要代码  method_exchangeImplementations(method1, method2); 这两个参数很简单，就是两个需要交换的方法。\n最后我调用了m1但是实际上走了m2。\n\n##### 动态交换方法的原理以及交换过程中指针的变化\n\n在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个category，然后hook的方法会写在category中。另一种是自己创建一个Tool类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要hook的类非常多的(我实际项目中就遇到这样的问题)那你就需要针对不同的类创建category，就会导致文件过多，且每一个文件中只有一个hook方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg)\n\n我要hook的是ViewController中的viewDidLoad方法，我建立了两个类一个是ViewController的category，另一个是Tool类，为了一会区别演示不同类hook的不同(两个类中hook的代码完全一样)\n* ViewController中将要被替换的系统方法\n\n![被替换的方法(系统方法)](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg)\n\n\n* Category中将要用来替换的自定义方法\n\n![用来替换的方法(自定义方法)](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg)\n* 然后在ViewController中的load中做方法替换\n\n![进行方法替换](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg)\n\n运行一下的输出结果想必大家已经猜到了先执行custom再执行system，这是通常情况下大家的做法。\n![结果](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg)\n\n下面再来看下如果我将替换方法写在不同类中会怎样，调用Tool中的交换方法\n\n![执行Tool中的交换方法](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg)\n\n然后直接看结果了，因为代码都是一模一样的我直接复制过去的\n\n![结果](https://ws3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg)\n\n发生了crash，原因是ViewController中没有swizzel_viewDidLoad_custom这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下\n\n![image.png](https://ws3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg)\n\n解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把customMethod添加到SystemClass中，但是注意要把customMethod的实现指向syetemMethod的实现。这样一来就可以达到SystemClass调用customMethod却执行systemMethod的代码的效果，实现以上要求我们需要在交换之前执行这个方法。\n\n```\nclass_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))\n```\n\n其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样\n\n```\n.\n.\n之前的都一样就省略\n.\n.\nif (class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))) {\n        class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System));\n    } else {\n        method_exchangeImplementations(method_System, method_Custom);\n    }\n\n```\n\n我们来看下执行完add操作之后此时的方法和类的对应关系(红色的为add的修改)\n\n\n![关系](https://ws4.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg)\n\n\n因为SystemClass中本身不包含customMethod所以add一定是成功的，也就是说会进入判断执行replace方法。\n\n```\nclass_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System));\n\n```\n\n第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完replace之后的类与方法名以及他们实现的关系(红色的为replace的修改)。\n\n![关系](https://ws1.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg)\n\n此时大家已经看出来了，虽然没有执行exchange方法，但是我已经达到了方法交换的目的。系统执行systemMethod时候会走customMethod的实现但是因为在customMethod方法中我会递归执行[self customMethod]，所以又会走到systemMethod的实现，因为之前进行了方法添加，所以此时A类中有了customMethod方法，不会再发生之前的crash。达到一个不同类进行Method Swizzling的目的。\n\n##### 综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\n\n```\n+ (void)changeMethod {\n\n    Class systemClass = NSClassFromString(@\"你的类\");\n\n    SEL sel_System = @selector(系统方法);\n    SEL sel_Custom = @selector(你自己的方法);\n\n    Method method_System = class_getInstanceMethod(systemClass, sel_System);\n    Method method_Custom = class_getInstanceMethod([self class], sel_Custom);\n\n    IMP imp_System = method_getImplementation(method_System);\n    IMP imp_Custom = method_getImplementation(method_Custom);\n\n    if (class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))) {\n        class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System));\n    } else {\n        method_exchangeImplementations(method_System, method_Custom);\n    }\n}\n\n```\n\n##### 以上代码无论是写在工具类中还是category中都是没有问题的。\n","slug":"iOS-Runtime简单介绍，以及不同类的Method-Swizzling","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2l1000la04wzo4gshr8","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h5 id=\"Runtime介绍：\"><a href=\"#Runtime介绍：\" class=\"headerlink\" title=\"Runtime介绍：\"></a>Runtime介绍：</h5><p> runtime顾名思义就是运行时，其实我们的App从你按下command+R开始一直到App运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题<br><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg\" alt=\"\"></p>\n<p>这里给大家解释下：首先， * testObject 是告诉编译器，testObject是一个指向某个Objective-C对象的指针。因为不管指向的是什么类型的对象，<br><a id=\"more\"></a><br>一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把testObject当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告。接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在testObject里。那么运行时(从这段代码执行开始，到程序结束)，testObject指向的内存空间就是一个NSData对象。你可以把testObject当做一个NSData对象来用。 所以编译时是NSString，运行时是NSData。<br>runtime是什么：<br>在runtime中，所有的类在OC中都会被定义成一个结构体，像这样<br>类在runtime中的表示<br>struct objc_class {<br>    Class isa;//指针，顾名思义，表示是一个什么，  //实例的isa指向类对象，类对象的isa指向元类<br><figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">        Class super_class;  <span class=\"comment\">//指向父类</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;  <span class=\"comment\">//类名</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> version;     <span class=\"comment\">//类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> info;   <span class=\"comment\">/*供运行期使用的一些位标识。有如下一些位掩码：</span></span><br><span class=\"line\"><span class=\"comment\">                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_MAPPED (0x10L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> instance_size  <span class=\"comment\">//该类的实例变量大小（包括从父类继承下来的实例变量）；</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_ivar_list *ivars <span class=\"comment\">//成员变量列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_method_list **methodLists; <span class=\"comment\">//方法列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_cache *cache;<span class=\"comment\">//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_protocol_list *protocols <span class=\"comment\">//协议列表</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>\n<p>相关的定义<br>/// 描述类中的一个方法<br>typedef struct objc_method *Method;</p>\n<p>/// 实例变量<br>typedef struct objc_ivar *Ivar;</p>\n<p>/// 类别Category<br>typedef struct objc_category *Category;</p>\n<p>/// 类中声明的属性<br>typedef struct objc_property *objc_property_t;</p>\n<p>ObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。</p>\n<h5 id=\"runtime能干什么：\"><a href=\"#runtime能干什么：\" class=\"headerlink\" title=\"runtime能干什么：\"></a>runtime能干什么：</h5><ul>\n<li>：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取public和private的。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    Class clas = [<span class=\"built_in\">WKWebViewController</span> <span class=\"keyword\">class</span>]; <span class=\"comment\">//是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_property_t * propertyList = class_copyPropertyList(clas, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *propertyName = property_getName(propertyList[i]);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"  %@  属性(包括私有) --------&gt;&gt;&gt;&gt;&gt;    %@\"</span>,clas,[<span class=\"built_in\">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-------------------------------------------------------------------------------------------------------------- \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method * methodList = class_copyMethodList(clas, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        Method methodName = methodList[i];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"  %@ 方法(包括私有)  --------&gt;&gt;&gt;&gt;&gt;    %@\"</span>,clas,<span class=\"built_in\">NSStringFromSelector</span>(method_getName(methodName)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-------------------------------------------------------------------------------------------------------------- \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Ivar *ivarList = class_copyIvarList(clas, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Ivar myIvar = ivarList[i];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ivarName = ivar_getName(myIvar);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ 成员变量(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@\"</span>,clas, [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-------------------------------------------------------------------------------------------------------------- \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取协议列表</span></span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Protocol *myProtocal = protocolList[i];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *protocolName = protocol_getName(myProtocal);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ 协议 --------&gt;&gt;&gt;&gt;&gt; %@\"</span>,clas, [<span class=\"built_in\">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>输出后的结果是<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg\" alt=\"image.png\"><br>其中也包括了私有方法。</p>\n<ul>\n<li>2：拦截方法调用<br>有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg\" alt=\"image.png\"></li>\n</ul>\n<p>这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时runtime会将这段代码转换为objc_msgSend(obj, [@selector]);（本质就是发送消息）然后obj会通过其中isa指针去该类的缓存中(cache)查找对应函数的Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过method中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的</span></span><br><span class=\"line\"><span class=\"comment\"> 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后</span></span><br><span class=\"line\"><span class=\"comment\"> 调用invokeWithTarget让某个target来处理该方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3：动态添加方法<br>因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示</li>\n</ul>\n<figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span> errorMethod &#123;</span><br><span class=\"line\">    NSLog<span class=\"params\">(@<span class=\"string\">\"no method!!!!!!!\"</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个error1：，那么一旦调用了没有的方法就会走这个。我们来看代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    Method errorMethod =  class_getInstanceMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(errorMethod));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"built_in\">NSStringFromSelector</span>(sel) isEqualToString:<span class=\"string\">@\"testMethod\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> isAdd =  class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"tinajia  = %d\"</span>,isAdd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要用到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    添加方法</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> class] 在哪个类里添加</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> sel 添加的方法的名字</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> errorMethod 添加的方法的实现IMP指</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> types 方法的标示符</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@return</span> 是否添加成功</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">BOOL isAdd =  class_addMethod([self <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">sel</span>, <span class=\"type\">method_getImplementation</span></span>(errorMethod), method_getTypeEncoding(errorMethod));</span><br></pre></td></tr></table></figure>\n<p>然后运行下：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"code\"><pre><span class=\"line\">WKWebViewController * vc= <span class=\"comment\">[<span class=\"comment\">[WKWebViewController alloc]</span> init]</span>;</span><br><span class=\"line\"><span class=\"comment\">[vc performSelector:@selector(testMethod)]</span>;</span><br></pre></td></tr></table></figure>\n<p>我调用了并不存在的testMethod方法并没有崩溃并且方法已经成功添加了</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg\" alt=\"image.png\"></p>\n<ul>\n<li><p>4：动态交换方法（也叫iOS黑魔法，慎用）<br>没什么好例子，用一个网上说的例子(引用别人的东西，懒得复制了，就截了图)</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg\" alt=\"\"></p>\n<p>其实本质即使SEL和IMP的交换，原理是这样的：在iOS中每一个类中都有一个叫dispatch table的东西，里面存放在SEL 和他所对应的IMP指针，之前也说过方法调用就是通过sel找IMP指针然后指针定位调用方法。方法交换就是对这个dispatch table进行操作。让A的SEL去对应B的IMP，B的SEL对应A的IMP，如图</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg\" alt=\"\"></p>\n<p>这样就达到方法交换的目的，下面看代码：</p>\n</li>\n</ul>\n<figure class=\"highlight monkey\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\">    //  如果是类方法 要使用 !</span><br><span class=\"line\">    //  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet</span><br><span class=\"line\">    //  <span class=\"class\"><span class=\"keyword\">Class</span>  <span class=\"title\">class</span> = <span class=\"title\">NSClassFromString</span>(@\"<span class=\"title\">__NSSetM</span>\");</span></span><br><span class=\"line\">    //  <span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">metaClass</span> = <span class=\"title\">objc_getMetaClass</span>([<span class=\"title\">NSStringFromClass</span>(<span class=\"title\">class</span>) <span class=\"title\">UTF8String</span>]);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">systemClass</span> = <span class=\"title\">NSClassFromString</span>(<span class=\"title\">__NSSetM</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = NSSelectorFromString(addObject:);</span><br><span class=\"line\">    SEL sel_Custom = @selector(swizzle_addObject:);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method_System</span> =</span> class_getInstanceMethod(systemClass, sel_System);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method_Custom</span> =</span> class_getInstanceMethod([<span class=\"built_in\">self</span> <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"title\">sel_Custom</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = method_getImplementation(method_System);</span><br><span class=\"line\">    IMP imp_Custom = method_getImplementation(method_Custom);</span><br><span class=\"line\"></span><br><span class=\"line\">    method_exchangeImplementations(method_System, method_Custom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzle_addObject:(id) obj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        [<span class=\"built_in\">self</span> swizzle_addObject:obj];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要代码  method_exchangeImplementations(method1, method2); 这两个参数很简单，就是两个需要交换的方法。<br>最后我调用了m1但是实际上走了m2。</p>\n<h5 id=\"动态交换方法的原理以及交换过程中指针的变化\"><a href=\"#动态交换方法的原理以及交换过程中指针的变化\" class=\"headerlink\" title=\"动态交换方法的原理以及交换过程中指针的变化\"></a>动态交换方法的原理以及交换过程中指针的变化</h5><p>在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个category，然后hook的方法会写在category中。另一种是自己创建一个Tool类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要hook的类非常多的(我实际项目中就遇到这样的问题)那你就需要针对不同的类创建category，就会导致文件过多，且每一个文件中只有一个hook方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg\" alt=\"image.png\"></p>\n<p>我要hook的是ViewController中的viewDidLoad方法，我建立了两个类一个是ViewController的category，另一个是Tool类，为了一会区别演示不同类hook的不同(两个类中hook的代码完全一样)</p>\n<ul>\n<li>ViewController中将要被替换的系统方法</li>\n</ul>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg\" alt=\"被替换的方法(系统方法)\"></p>\n<ul>\n<li>Category中将要用来替换的自定义方法</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg\" alt=\"用来替换的方法(自定义方法)\"></p>\n<ul>\n<li>然后在ViewController中的load中做方法替换</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg\" alt=\"进行方法替换\"></p>\n<p>运行一下的输出结果想必大家已经猜到了先执行custom再执行system，这是通常情况下大家的做法。<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg\" alt=\"结果\"></p>\n<p>下面再来看下如果我将替换方法写在不同类中会怎样，调用Tool中的交换方法</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg\" alt=\"执行Tool中的交换方法\"></p>\n<p>然后直接看结果了，因为代码都是一模一样的我直接复制过去的</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg\" alt=\"结果\"></p>\n<p>发生了crash，原因是ViewController中没有swizzel_viewDidLoad_custom这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg\" alt=\"image.png\"></p>\n<p>解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把customMethod添加到SystemClass中，但是注意要把customMethod的实现指向syetemMethod的实现。这样一来就可以达到SystemClass调用customMethod却执行systemMethod的代码的效果，实现以上要求我们需要在交换之前执行这个方法。</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">class_addMethod(<span class=\"name\">systemClass</span>, sel_Custom, imp_System, method_getTypeEncoding(<span class=\"name\">method_System</span>))</span><br></pre></td></tr></table></figure>\n<p>其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">之前的都一样就省略</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">if (class<span class=\"emphasis\">_addMethod(systemClass, sel_</span>Custom, imp<span class=\"emphasis\">_System, method_</span>getTypeEncoding(method<span class=\"emphasis\">_System))) &#123;</span></span><br><span class=\"line\"><span class=\"emphasis\">        class_</span>replaceMethod(systemClass, sel<span class=\"emphasis\">_System, imp_</span>Custom, method<span class=\"emphasis\">_getTypeEncoding(method_</span>System));</span><br><span class=\"line\"><span class=\"code\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"code\">        method_exchangeImplementations(method_System, method_Custom);</span></span><br><span class=\"line\"><span class=\"code\">    &#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们来看下执行完add操作之后此时的方法和类的对应关系(红色的为add的修改)</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg\" alt=\"关系\"></p>\n<p>因为SystemClass中本身不包含customMethod所以add一定是成功的，也就是说会进入判断执行replace方法。</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">class_replaceMethod(<span class=\"name\">systemClass</span>, sel_System, imp_Custom, method_getTypeEncoding(<span class=\"name\">method_System</span>))<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完replace之后的类与方法名以及他们实现的关系(红色的为replace的修改)。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg\" alt=\"关系\"></p>\n<p>此时大家已经看出来了，虽然没有执行exchange方法，但是我已经达到了方法交换的目的。系统执行systemMethod时候会走customMethod的实现但是因为在customMethod方法中我会递归执行[self customMethod]，所以又会走到systemMethod的实现，因为之前进行了方法添加，所以此时A类中有了customMethod方法，不会再发生之前的crash。达到一个不同类进行Method Swizzling的目的。</p>\n<h5 id=\"综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\"><a href=\"#综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\" class=\"headerlink\" title=\"综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\"></a>综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错</h5><figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class systemClass = NSClassFromString(<span class=\"comment\">@\"你的类\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">SEL </span><span class=\"keyword\">sel_System </span>= <span class=\"comment\">@selector(系统方法);</span></span><br><span class=\"line\">    <span class=\"keyword\">SEL </span><span class=\"keyword\">sel_Custom </span>= <span class=\"comment\">@selector(你自己的方法);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = class_getInstanceMethod(systemClass, <span class=\"keyword\">sel_System);</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   Method method_Custom = class_getInstanceMethod([<span class=\"keyword\">self </span>class], <span class=\"keyword\">sel_Custom);</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   IMP imp_System = method_getImplementation(method_System)<span class=\"comment\">;</span></span><br><span class=\"line\">    IMP imp_Custom = method_getImplementation(method_Custom)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">if</span> (class_addMethod(systemClass, <span class=\"keyword\">sel_Custom, </span>imp_System, method_getTypeEncoding(method_System))) &#123;</span><br><span class=\"line\">        class_replaceMethod(systemClass, <span class=\"keyword\">sel_System, </span>imp_Custom, method_getTypeEncoding(method_System))<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125; <span class=\"meta\">else</span> &#123;</span><br><span class=\"line\">        method_exchangeImplementations(method_System, method_Custom)<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"以上代码无论是写在工具类中还是category中都是没有问题的。\"><a href=\"#以上代码无论是写在工具类中还是category中都是没有问题的。\" class=\"headerlink\" title=\"以上代码无论是写在工具类中还是category中都是没有问题的。\"></a>以上代码无论是写在工具类中还是category中都是没有问题的。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"Runtime介绍：\"><a href=\"#Runtime介绍：\" class=\"headerlink\" title=\"Runtime介绍：\"></a>Runtime介绍：</h5><p> runtime顾名思义就是运行时，其实我们的App从你按下command+R开始一直到App运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题<br><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kbsn9yxj30kk03et8z.jpg\" alt=\"\"></p>\n<p>这里给大家解释下：首先， * testObject 是告诉编译器，testObject是一个指向某个Objective-C对象的指针。因为不管指向的是什么类型的对象，<br>","more":"<br>一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把testObject当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告。接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在testObject里。那么运行时(从这段代码执行开始，到程序结束)，testObject指向的内存空间就是一个NSData对象。你可以把testObject当做一个NSData对象来用。 所以编译时是NSString，运行时是NSData。<br>runtime是什么：<br>在runtime中，所有的类在OC中都会被定义成一个结构体，像这样<br>类在runtime中的表示<br>struct objc_class {<br>    Class isa;//指针，顾名思义，表示是一个什么，  //实例的isa指向类对象，类对象的isa指向元类<br><figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">        Class super_class;  <span class=\"comment\">//指向父类</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;  <span class=\"comment\">//类名</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> version;     <span class=\"comment\">//类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> info;   <span class=\"comment\">/*供运行期使用的一些位标识。有如下一些位掩码：</span></span><br><span class=\"line\"><span class=\"comment\">                        CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_MAPPED (0x10L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_NEED_BIND (0x80L) 为ObjC运行期所使用</span></span><br><span class=\"line\"><span class=\"comment\">                      CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> instance_size  <span class=\"comment\">//该类的实例变量大小（包括从父类继承下来的实例变量）；</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_ivar_list *ivars <span class=\"comment\">//成员变量列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_method_list **methodLists; <span class=\"comment\">//方法列表</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_cache *cache;<span class=\"comment\">//缓存   一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_protocol_list *protocols <span class=\"comment\">//协议列表</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>\n<p>相关的定义<br>/// 描述类中的一个方法<br>typedef struct objc_method *Method;</p>\n<p>/// 实例变量<br>typedef struct objc_ivar *Ivar;</p>\n<p>/// 类别Category<br>typedef struct objc_category *Category;</p>\n<p>/// 类中声明的属性<br>typedef struct objc_property *objc_property_t;</p>\n<p>ObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。</p>\n<h5 id=\"runtime能干什么：\"><a href=\"#runtime能干什么：\" class=\"headerlink\" title=\"runtime能干什么：\"></a>runtime能干什么：</h5><ul>\n<li>：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取public和private的。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    Class clas = [<span class=\"built_in\">WKWebViewController</span> <span class=\"keyword\">class</span>]; <span class=\"comment\">//是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    objc_property_t * propertyList = class_copyPropertyList(clas, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *propertyName = property_getName(propertyList[i]);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"  %@  属性(包括私有) --------&gt;&gt;&gt;&gt;&gt;    %@\"</span>,clas,[<span class=\"built_in\">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-------------------------------------------------------------------------------------------------------------- \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Method * methodList = class_copyMethodList(clas, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        Method methodName = methodList[i];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"  %@ 方法(包括私有)  --------&gt;&gt;&gt;&gt;&gt;    %@\"</span>,clas,<span class=\"built_in\">NSStringFromSelector</span>(method_getName(methodName)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-------------------------------------------------------------------------------------------------------------- \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Ivar *ivarList = class_copyIvarList(clas, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Ivar myIvar = ivarList[i];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ivarName = ivar_getName(myIvar);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ 成员变量(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@\"</span>,clas, [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"-------------------------------------------------------------------------------------------------------------- \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取协议列表</span></span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">        Protocol *myProtocal = protocolList[i];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *protocolName = protocol_getName(myProtocal);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ 协议 --------&gt;&gt;&gt;&gt;&gt; %@\"</span>,clas, [<span class=\"built_in\">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>输出后的结果是<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kc7w3zcj30pk0ajdks.jpg\" alt=\"image.png\"><br>其中也包括了私有方法。</p>\n<ul>\n<li>2：拦截方法调用<br>有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kcfrky6j30tr0120sy.jpg\" alt=\"image.png\"></li>\n</ul>\n<p>这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如   [obj aaa]  在运行时runtime会将这段代码转换为objc_msgSend(obj, [@selector]);（本质就是发送消息）然后obj会通过其中isa指针去该类的缓存中(cache)查找对应函数的Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过method中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的</span></span><br><span class=\"line\"><span class=\"comment\"> 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后</span></span><br><span class=\"line\"><span class=\"comment\"> 调用invokeWithTarget让某个target来处理该方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3：动态添加方法<br>因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示</li>\n</ul>\n<figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span> errorMethod &#123;</span><br><span class=\"line\">    NSLog<span class=\"params\">(@<span class=\"string\">\"no method!!!!!!!\"</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个error1：，那么一旦调用了没有的方法就会走这个。我们来看代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    Method errorMethod =  class_getInstanceMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(errorMethod));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"built_in\">NSStringFromSelector</span>(sel) isEqualToString:<span class=\"string\">@\"testMethod\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> isAdd =  class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"tinajia  = %d\"</span>,isAdd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要用到</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    添加方法</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> class] 在哪个类里添加</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> sel 添加的方法的名字</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> errorMethod 添加的方法的实现IMP指</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@param</span> types 方法的标示符</span></span><br><span class=\"line\"><span class=\"comment\">     <span class=\"doctag\">@return</span> 是否添加成功</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">BOOL isAdd =  class_addMethod([self <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">sel</span>, <span class=\"type\">method_getImplementation</span></span>(errorMethod), method_getTypeEncoding(errorMethod));</span><br></pre></td></tr></table></figure>\n<p>然后运行下：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"code\"><pre><span class=\"line\">WKWebViewController * vc= <span class=\"comment\">[<span class=\"comment\">[WKWebViewController alloc]</span> init]</span>;</span><br><span class=\"line\"><span class=\"comment\">[vc performSelector:@selector(testMethod)]</span>;</span><br></pre></td></tr></table></figure>\n<p>我调用了并不存在的testMethod方法并没有崩溃并且方法已经成功添加了</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kexyuzgj30f801mwel.jpg\" alt=\"image.png\"></p>\n<ul>\n<li><p>4：动态交换方法（也叫iOS黑魔法，慎用）<br>没什么好例子，用一个网上说的例子(引用别人的东西，懒得复制了，就截了图)</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6kg3i5z6j30hv0fj0z9.jpg\" alt=\"\"></p>\n<p>其实本质即使SEL和IMP的交换，原理是这样的：在iOS中每一个类中都有一个叫dispatch table的东西，里面存放在SEL 和他所对应的IMP指针，之前也说过方法调用就是通过sel找IMP指针然后指针定位调用方法。方法交换就是对这个dispatch table进行操作。让A的SEL去对应B的IMP，B的SEL对应A的IMP，如图</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kgrq52oj30f80betcz.jpg\" alt=\"\"></p>\n<p>这样就达到方法交换的目的，下面看代码：</p>\n</li>\n</ul>\n<figure class=\"highlight monkey\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\">    //  如果是类方法 要使用 !</span><br><span class=\"line\">    //  如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet</span><br><span class=\"line\">    //  <span class=\"class\"><span class=\"keyword\">Class</span>  <span class=\"title\">class</span> = <span class=\"title\">NSClassFromString</span>(@\"<span class=\"title\">__NSSetM</span>\");</span></span><br><span class=\"line\">    //  <span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">metaClass</span> = <span class=\"title\">objc_getMetaClass</span>([<span class=\"title\">NSStringFromClass</span>(<span class=\"title\">class</span>) <span class=\"title\">UTF8String</span>]);</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">systemClass</span> = <span class=\"title\">NSClassFromString</span>(<span class=\"title\">__NSSetM</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SEL sel_System = NSSelectorFromString(addObject:);</span><br><span class=\"line\">    SEL sel_Custom = @selector(swizzle_addObject:);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method_System</span> =</span> class_getInstanceMethod(systemClass, sel_System);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method_Custom</span> =</span> class_getInstanceMethod([<span class=\"built_in\">self</span> <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"title\">sel_Custom</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    IMP imp_System = method_getImplementation(method_System);</span><br><span class=\"line\">    IMP imp_Custom = method_getImplementation(method_Custom);</span><br><span class=\"line\"></span><br><span class=\"line\">    method_exchangeImplementations(method_System, method_Custom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzle_addObject:(id) obj &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        [<span class=\"built_in\">self</span> swizzle_addObject:obj];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要代码  method_exchangeImplementations(method1, method2); 这两个参数很简单，就是两个需要交换的方法。<br>最后我调用了m1但是实际上走了m2。</p>\n<h5 id=\"动态交换方法的原理以及交换过程中指针的变化\"><a href=\"#动态交换方法的原理以及交换过程中指针的变化\" class=\"headerlink\" title=\"动态交换方法的原理以及交换过程中指针的变化\"></a>动态交换方法的原理以及交换过程中指针的变化</h5><p>在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个category，然后hook的方法会写在category中。另一种是自己创建一个Tool类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要hook的类非常多的(我实际项目中就遇到这样的问题)那你就需要针对不同的类创建category，就会导致文件过多，且每一个文件中只有一个hook方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6khw8c97j30740ag74v.jpg\" alt=\"image.png\"></p>\n<p>我要hook的是ViewController中的viewDidLoad方法，我建立了两个类一个是ViewController的category，另一个是Tool类，为了一会区别演示不同类hook的不同(两个类中hook的代码完全一样)</p>\n<ul>\n<li>ViewController中将要被替换的系统方法</li>\n</ul>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kir8y63j309a02rglq.jpg\" alt=\"被替换的方法(系统方法)\"></p>\n<ul>\n<li>Category中将要用来替换的自定义方法</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kj5dcykj308z02lwep.jpg\" alt=\"用来替换的方法(自定义方法)\"></p>\n<ul>\n<li>然后在ViewController中的load中做方法替换</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjlzvdqj30f90b43zw.jpg\" alt=\"进行方法替换\"></p>\n<p>运行一下的输出结果想必大家已经猜到了先执行custom再执行system，这是通常情况下大家的做法。<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kjxsheej30d701h3yl.jpg\" alt=\"结果\"></p>\n<p>下面再来看下如果我将替换方法写在不同类中会怎样，调用Tool中的交换方法</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kka2s8uj30dx0anwfp.jpg\" alt=\"执行Tool中的交换方法\"></p>\n<p>然后直接看结果了，因为代码都是一模一样的我直接复制过去的</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6kliitupj30yd08w422.jpg\" alt=\"结果\"></p>\n<p>发生了crash，原因是ViewController中没有swizzel_viewDidLoad_custom这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6km0wogkj30yg0pz43q.jpg\" alt=\"image.png\"></p>\n<p>解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把customMethod添加到SystemClass中，但是注意要把customMethod的实现指向syetemMethod的实现。这样一来就可以达到SystemClass调用customMethod却执行systemMethod的代码的效果，实现以上要求我们需要在交换之前执行这个方法。</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">class_addMethod(<span class=\"name\">systemClass</span>, sel_Custom, imp_System, method_getTypeEncoding(<span class=\"name\">method_System</span>))</span><br></pre></td></tr></table></figure>\n<p>其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">之前的都一样就省略</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">if (class<span class=\"emphasis\">_addMethod(systemClass, sel_</span>Custom, imp<span class=\"emphasis\">_System, method_</span>getTypeEncoding(method<span class=\"emphasis\">_System))) &#123;</span></span><br><span class=\"line\"><span class=\"emphasis\">        class_</span>replaceMethod(systemClass, sel<span class=\"emphasis\">_System, imp_</span>Custom, method<span class=\"emphasis\">_getTypeEncoding(method_</span>System));</span><br><span class=\"line\"><span class=\"code\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"code\">        method_exchangeImplementations(method_System, method_Custom);</span></span><br><span class=\"line\"><span class=\"code\">    &#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们来看下执行完add操作之后此时的方法和类的对应关系(红色的为add的修改)</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6kmhkzidj30yg0g378f.jpg\" alt=\"关系\"></p>\n<p>因为SystemClass中本身不包含customMethod所以add一定是成功的，也就是说会进入判断执行replace方法。</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">class_replaceMethod(<span class=\"name\">systemClass</span>, sel_System, imp_Custom, method_getTypeEncoding(<span class=\"name\">method_System</span>))<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完replace之后的类与方法名以及他们实现的关系(红色的为replace的修改)。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6kn9m5btj30yg0ifgqa.jpg\" alt=\"关系\"></p>\n<p>此时大家已经看出来了，虽然没有执行exchange方法，但是我已经达到了方法交换的目的。系统执行systemMethod时候会走customMethod的实现但是因为在customMethod方法中我会递归执行[self customMethod]，所以又会走到systemMethod的实现，因为之前进行了方法添加，所以此时A类中有了customMethod方法，不会再发生之前的crash。达到一个不同类进行Method Swizzling的目的。</p>\n<h5 id=\"综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\"><a href=\"#综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\" class=\"headerlink\" title=\"综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错\"></a>综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错</h5><figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (void)changeMethod &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class systemClass = NSClassFromString(<span class=\"comment\">@\"你的类\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">SEL </span><span class=\"keyword\">sel_System </span>= <span class=\"comment\">@selector(系统方法);</span></span><br><span class=\"line\">    <span class=\"keyword\">SEL </span><span class=\"keyword\">sel_Custom </span>= <span class=\"comment\">@selector(你自己的方法);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Method method_System = class_getInstanceMethod(systemClass, <span class=\"keyword\">sel_System);</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   Method method_Custom = class_getInstanceMethod([<span class=\"keyword\">self </span>class], <span class=\"keyword\">sel_Custom);</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   IMP imp_System = method_getImplementation(method_System)<span class=\"comment\">;</span></span><br><span class=\"line\">    IMP imp_Custom = method_getImplementation(method_Custom)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">if</span> (class_addMethod(systemClass, <span class=\"keyword\">sel_Custom, </span>imp_System, method_getTypeEncoding(method_System))) &#123;</span><br><span class=\"line\">        class_replaceMethod(systemClass, <span class=\"keyword\">sel_System, </span>imp_Custom, method_getTypeEncoding(method_System))<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125; <span class=\"meta\">else</span> &#123;</span><br><span class=\"line\">        method_exchangeImplementations(method_System, method_Custom)<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"以上代码无论是写在工具类中还是category中都是没有问题的。\"><a href=\"#以上代码无论是写在工具类中还是category中都是没有问题的。\" class=\"headerlink\" title=\"以上代码无论是写在工具类中还是category中都是没有问题的。\"></a>以上代码无论是写在工具类中还是category中都是没有问题的。</h5>"},{"title":"深入理解Http请求、DNS劫持与解析","date":"2018-01-23T10:12:18.000Z","comments":1,"_content":"### 背景\n前段时间在处理iOS端的HTTPDNS相关SDK，在接入和测试环节发现大家对HTTP的整体请求流程包括HTTP劫持原理以及HTTPDNS的工作原理并不是太清楚，所以写下这边文章帮助大家深入web请求过程：如何发起请求，HTTP协议解析，DNS域名解析。\n### HTTP发起一个请求过程\n当我们在手机端请求一个@\"www.baidu.com\"的域名的时候\n* 1.请求到达运营商的DNS服务器并由其把这个域名解析成对应的IP地址。\n\n* 2.根据IP地址在互联网上找到对应的服务器，向这个服务器发起一个get\\post请求。\n\n* 3.由这个服务器找到对应的资源原路返回给访问的用户。\n<!--more-->\n\n这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器上又会处理这个用户的请求。\n\n### HTTP劫持\n我们使用HTTPDNS的主要目的就是解决HTTP劫持问题。HTTP的劫持分两种第一种是DNS劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解：\n###### 1：DNS劫持\n* 劫持流程\nDNS劫持又称[域名劫持](https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81)，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示\n\n  ![DNS劫持原理](https://ws4.sinaimg.cn/large/006tNc79gy1fo6mqqoqxrj30yg0gt7oj.jpg)\n\n  从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。\n* 解决办法\n\n  * DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。\n\n  * HttpDNS是使用HTTP协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求,绕开了运营商的Local DNS，从而避免了使用运营商Local DNS造成的劫持和跨网问题\n\n###### 2：内容劫持\n\n* 劫持流程\n内容劫持网上很少有提到，这也是在做httpDNS SDK所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据\n\n  ![内容劫持](https://ws3.sinaimg.cn/large/006tNc79gy1fo6mtjymehj30yg0h3tob.jpg)\n\n  黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。\n\n* 解决办法：\n现在暂时无法通过HTTPdns和其他手段解决，不过这样的劫持不是很多。\n\n### DNS解析过程\n\n如果是iOS设备请直接跳到第三步骤\n\n* 1.系统会检查浏览器缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。\n\n* 2.如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的Host文件。\n\n* 3.如果本地Host文件中没有那么操作系统会把这个域名发送给这里设置的LocalDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约90%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。\n\n* 4.如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析\n\n* 5.根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD是国际顶级域名服务器，如.com，.cn、.org等。全球只有13台左右。\n\n* 6.本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。\n\n* 7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成\n\n* 8.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。\n\n* 9.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。\n\n* 10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。\n以上的流程可以简化为下图\n\n![DNS解析](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mu9fg86j30yg0k41hd.jpg)\n\n绿色的为非iOS设备的操作流程\n### CDN工作机制\n###### CDN简介\nCDN，全称Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他-有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN=镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN可以明显提高Internet中信息流动的效率。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。这里引用一个网上比较形象的例子：**A家的网速 100M的，但他只用了10M的速度，B家的网速是10M的，但是他需要15M的速度才行。怎么办呢。 C是一家CDN服务商，在A家有个节点（就像A是一个赞助商一样）B在C家买了CDN加速服务。当B的速度不够的时候，CDN加速就会选择有节余的节点来帮B，提高B的速度。这样B的速度就能达到或超过15M ，A没浪费，B速度有了，C赚了钱，皆大欢喜。 当C的节点在全国都有，非常多的时候。那么你用C家的CDN加速服务，你就会健步如飞了**。\n###### CDN工作流程\n一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。\n###### 负载均衡\n负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。\nCDN整体的工作流程可以大概归为下图：\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mup956fj30yg0f5wx0.jpg)\n\n### 总结\n以上就是Http请求的一些理解，如果有不对的地方及时与我来沟通。\n","source":"_posts/2018-01-23-深入理解Http请求、DNS劫持与解析.md","raw":"---\ntitle: 深入理解Http请求、DNS劫持与解析\ncategories: iOS开发\ndate: 2018-01-23 18:12:18\ntags:\ncomments:\n---\n### 背景\n前段时间在处理iOS端的HTTPDNS相关SDK，在接入和测试环节发现大家对HTTP的整体请求流程包括HTTP劫持原理以及HTTPDNS的工作原理并不是太清楚，所以写下这边文章帮助大家深入web请求过程：如何发起请求，HTTP协议解析，DNS域名解析。\n### HTTP发起一个请求过程\n当我们在手机端请求一个@\"www.baidu.com\"的域名的时候\n* 1.请求到达运营商的DNS服务器并由其把这个域名解析成对应的IP地址。\n\n* 2.根据IP地址在互联网上找到对应的服务器，向这个服务器发起一个get\\post请求。\n\n* 3.由这个服务器找到对应的资源原路返回给访问的用户。\n<!--more-->\n\n这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器上又会处理这个用户的请求。\n\n### HTTP劫持\n我们使用HTTPDNS的主要目的就是解决HTTP劫持问题。HTTP的劫持分两种第一种是DNS劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解：\n###### 1：DNS劫持\n* 劫持流程\nDNS劫持又称[域名劫持](https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81)，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示\n\n  ![DNS劫持原理](https://ws4.sinaimg.cn/large/006tNc79gy1fo6mqqoqxrj30yg0gt7oj.jpg)\n\n  从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。\n* 解决办法\n\n  * DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。\n\n  * HttpDNS是使用HTTP协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求,绕开了运营商的Local DNS，从而避免了使用运营商Local DNS造成的劫持和跨网问题\n\n###### 2：内容劫持\n\n* 劫持流程\n内容劫持网上很少有提到，这也是在做httpDNS SDK所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据\n\n  ![内容劫持](https://ws3.sinaimg.cn/large/006tNc79gy1fo6mtjymehj30yg0h3tob.jpg)\n\n  黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。\n\n* 解决办法：\n现在暂时无法通过HTTPdns和其他手段解决，不过这样的劫持不是很多。\n\n### DNS解析过程\n\n如果是iOS设备请直接跳到第三步骤\n\n* 1.系统会检查浏览器缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。\n\n* 2.如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的Host文件。\n\n* 3.如果本地Host文件中没有那么操作系统会把这个域名发送给这里设置的LocalDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约90%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。\n\n* 4.如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析\n\n* 5.根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD是国际顶级域名服务器，如.com，.cn、.org等。全球只有13台左右。\n\n* 6.本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。\n\n* 7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成\n\n* 8.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。\n\n* 9.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。\n\n* 10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。\n以上的流程可以简化为下图\n\n![DNS解析](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mu9fg86j30yg0k41hd.jpg)\n\n绿色的为非iOS设备的操作流程\n### CDN工作机制\n###### CDN简介\nCDN，全称Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他-有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN=镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN可以明显提高Internet中信息流动的效率。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。这里引用一个网上比较形象的例子：**A家的网速 100M的，但他只用了10M的速度，B家的网速是10M的，但是他需要15M的速度才行。怎么办呢。 C是一家CDN服务商，在A家有个节点（就像A是一个赞助商一样）B在C家买了CDN加速服务。当B的速度不够的时候，CDN加速就会选择有节余的节点来帮B，提高B的速度。这样B的速度就能达到或超过15M ，A没浪费，B速度有了，C赚了钱，皆大欢喜。 当C的节点在全国都有，非常多的时候。那么你用C家的CDN加速服务，你就会健步如飞了**。\n###### CDN工作流程\n一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。\n###### 负载均衡\n负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。\nCDN整体的工作流程可以大概归为下图：\n\n![image.png](https://ws2.sinaimg.cn/large/006tNc79gy1fo6mup956fj30yg0f5wx0.jpg)\n\n### 总结\n以上就是Http请求的一些理解，如果有不对的地方及时与我来沟通。\n","slug":"深入理解Http请求、DNS劫持与解析","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2l3000qa04wif28k5g8","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>前段时间在处理iOS端的HTTPDNS相关SDK，在接入和测试环节发现大家对HTTP的整体请求流程包括HTTP劫持原理以及HTTPDNS的工作原理并不是太清楚，所以写下这边文章帮助大家深入web请求过程：如何发起请求，HTTP协议解析，DNS域名解析。</p>\n<h3 id=\"HTTP发起一个请求过程\"><a href=\"#HTTP发起一个请求过程\" class=\"headerlink\" title=\"HTTP发起一个请求过程\"></a>HTTP发起一个请求过程</h3><p>当我们在手机端请求一个@”www.baidu.com”的域名的时候</p>\n<ul>\n<li><p>1.请求到达运营商的DNS服务器并由其把这个域名解析成对应的IP地址。</p>\n</li>\n<li><p>2.根据IP地址在互联网上找到对应的服务器，向这个服务器发起一个get\\post请求。</p>\n</li>\n<li><p>3.由这个服务器找到对应的资源原路返回给访问的用户。</p>\n<a id=\"more\"></a>\n</li>\n</ul>\n<p>这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器上又会处理这个用户的请求。</p>\n<h3 id=\"HTTP劫持\"><a href=\"#HTTP劫持\" class=\"headerlink\" title=\"HTTP劫持\"></a>HTTP劫持</h3><p>我们使用HTTPDNS的主要目的就是解决HTTP劫持问题。HTTP的劫持分两种第一种是DNS劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解：</p>\n<h6 id=\"1：DNS劫持\"><a href=\"#1：DNS劫持\" class=\"headerlink\" title=\"1：DNS劫持\"></a>1：DNS劫持</h6><ul>\n<li><p>劫持流程<br>DNS劫持又称<a href=\"https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81\" target=\"_blank\" rel=\"noopener\">域名劫持</a>，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6mqqoqxrj30yg0gt7oj.jpg\" alt=\"DNS劫持原理\"></p>\n<p>从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。</p>\n</li>\n<li><p>解决办法</p>\n<ul>\n<li><p>DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。</p>\n</li>\n<li><p>HttpDNS是使用HTTP协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求,绕开了运营商的Local DNS，从而避免了使用运营商Local DNS造成的劫持和跨网问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"2：内容劫持\"><a href=\"#2：内容劫持\" class=\"headerlink\" title=\"2：内容劫持\"></a>2：内容劫持</h6><ul>\n<li><p>劫持流程<br>内容劫持网上很少有提到，这也是在做httpDNS SDK所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6mtjymehj30yg0h3tob.jpg\" alt=\"内容劫持\"></p>\n<p>黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。</p>\n</li>\n<li><p>解决办法：<br>现在暂时无法通过HTTPdns和其他手段解决，不过这样的劫持不是很多。</p>\n</li>\n</ul>\n<h3 id=\"DNS解析过程\"><a href=\"#DNS解析过程\" class=\"headerlink\" title=\"DNS解析过程\"></a>DNS解析过程</h3><p>如果是iOS设备请直接跳到第三步骤</p>\n<ul>\n<li><p>1.系统会检查浏览器缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。</p>\n</li>\n<li><p>2.如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的Host文件。</p>\n</li>\n<li><p>3.如果本地Host文件中没有那么操作系统会把这个域名发送给这里设置的LocalDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约90%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。</p>\n</li>\n<li><p>4.如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析</p>\n</li>\n<li><p>5.根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD是国际顶级域名服务器，如.com，.cn、.org等。全球只有13台左右。</p>\n</li>\n<li><p>6.本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。</p>\n</li>\n<li><p>7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成</p>\n</li>\n<li><p>8.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。</p>\n</li>\n<li><p>9.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。</p>\n</li>\n<li><p>10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。<br>以上的流程可以简化为下图</p>\n</li>\n</ul>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mu9fg86j30yg0k41hd.jpg\" alt=\"DNS解析\"></p>\n<p>绿色的为非iOS设备的操作流程</p>\n<h3 id=\"CDN工作机制\"><a href=\"#CDN工作机制\" class=\"headerlink\" title=\"CDN工作机制\"></a>CDN工作机制</h3><h6 id=\"CDN简介\"><a href=\"#CDN简介\" class=\"headerlink\" title=\"CDN简介\"></a>CDN简介</h6><p>CDN，全称Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他-有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN=镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN可以明显提高Internet中信息流动的效率。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。这里引用一个网上比较形象的例子：<strong>A家的网速 100M的，但他只用了10M的速度，B家的网速是10M的，但是他需要15M的速度才行。怎么办呢。 C是一家CDN服务商，在A家有个节点（就像A是一个赞助商一样）B在C家买了CDN加速服务。当B的速度不够的时候，CDN加速就会选择有节余的节点来帮B，提高B的速度。这样B的速度就能达到或超过15M ，A没浪费，B速度有了，C赚了钱，皆大欢喜。 当C的节点在全国都有，非常多的时候。那么你用C家的CDN加速服务，你就会健步如飞了</strong>。</p>\n<h6 id=\"CDN工作流程\"><a href=\"#CDN工作流程\" class=\"headerlink\" title=\"CDN工作流程\"></a>CDN工作流程</h6><p>一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。</p>\n<h6 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h6><p>负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。<br>CDN整体的工作流程可以大概归为下图：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mup956fj30yg0f5wx0.jpg\" alt=\"image.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上就是Http请求的一些理解，如果有不对的地方及时与我来沟通。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>前段时间在处理iOS端的HTTPDNS相关SDK，在接入和测试环节发现大家对HTTP的整体请求流程包括HTTP劫持原理以及HTTPDNS的工作原理并不是太清楚，所以写下这边文章帮助大家深入web请求过程：如何发起请求，HTTP协议解析，DNS域名解析。</p>\n<h3 id=\"HTTP发起一个请求过程\"><a href=\"#HTTP发起一个请求过程\" class=\"headerlink\" title=\"HTTP发起一个请求过程\"></a>HTTP发起一个请求过程</h3><p>当我们在手机端请求一个@”www.baidu.com”的域名的时候</p>\n<ul>\n<li><p>1.请求到达运营商的DNS服务器并由其把这个域名解析成对应的IP地址。</p>\n</li>\n<li><p>2.根据IP地址在互联网上找到对应的服务器，向这个服务器发起一个get\\post请求。</p>\n</li>\n<li><p>3.由这个服务器找到对应的资源原路返回给访问的用户。</p>","more":"</li>\n</ul>\n<p>这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器上又会处理这个用户的请求。</p>\n<h3 id=\"HTTP劫持\"><a href=\"#HTTP劫持\" class=\"headerlink\" title=\"HTTP劫持\"></a>HTTP劫持</h3><p>我们使用HTTPDNS的主要目的就是解决HTTP劫持问题。HTTP的劫持分两种第一种是DNS劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解：</p>\n<h6 id=\"1：DNS劫持\"><a href=\"#1：DNS劫持\" class=\"headerlink\" title=\"1：DNS劫持\"></a>1：DNS劫持</h6><ul>\n<li><p>劫持流程<br>DNS劫持又称<a href=\"https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81\" target=\"_blank\" rel=\"noopener\">域名劫持</a>，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6mqqoqxrj30yg0gt7oj.jpg\" alt=\"DNS劫持原理\"></p>\n<p>从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。</p>\n</li>\n<li><p>解决办法</p>\n<ul>\n<li><p>DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。</p>\n</li>\n<li><p>HttpDNS是使用HTTP协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求,绕开了运营商的Local DNS，从而避免了使用运营商Local DNS造成的劫持和跨网问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"2：内容劫持\"><a href=\"#2：内容劫持\" class=\"headerlink\" title=\"2：内容劫持\"></a>2：内容劫持</h6><ul>\n<li><p>劫持流程<br>内容劫持网上很少有提到，这也是在做httpDNS SDK所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6mtjymehj30yg0h3tob.jpg\" alt=\"内容劫持\"></p>\n<p>黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。</p>\n</li>\n<li><p>解决办法：<br>现在暂时无法通过HTTPdns和其他手段解决，不过这样的劫持不是很多。</p>\n</li>\n</ul>\n<h3 id=\"DNS解析过程\"><a href=\"#DNS解析过程\" class=\"headerlink\" title=\"DNS解析过程\"></a>DNS解析过程</h3><p>如果是iOS设备请直接跳到第三步骤</p>\n<ul>\n<li><p>1.系统会检查浏览器缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。</p>\n</li>\n<li><p>2.如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的Host文件。</p>\n</li>\n<li><p>3.如果本地Host文件中没有那么操作系统会把这个域名发送给这里设置的LocalDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约90%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。</p>\n</li>\n<li><p>4.如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析</p>\n</li>\n<li><p>5.根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD是国际顶级域名服务器，如.com，.cn、.org等。全球只有13台左右。</p>\n</li>\n<li><p>6.本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。</p>\n</li>\n<li><p>7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成</p>\n</li>\n<li><p>8.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。</p>\n</li>\n<li><p>9.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。</p>\n</li>\n<li><p>10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。<br>以上的流程可以简化为下图</p>\n</li>\n</ul>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mu9fg86j30yg0k41hd.jpg\" alt=\"DNS解析\"></p>\n<p>绿色的为非iOS设备的操作流程</p>\n<h3 id=\"CDN工作机制\"><a href=\"#CDN工作机制\" class=\"headerlink\" title=\"CDN工作机制\"></a>CDN工作机制</h3><h6 id=\"CDN简介\"><a href=\"#CDN简介\" class=\"headerlink\" title=\"CDN简介\"></a>CDN简介</h6><p>CDN，全称Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他-有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN=镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN可以明显提高Internet中信息流动的效率。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。这里引用一个网上比较形象的例子：<strong>A家的网速 100M的，但他只用了10M的速度，B家的网速是10M的，但是他需要15M的速度才行。怎么办呢。 C是一家CDN服务商，在A家有个节点（就像A是一个赞助商一样）B在C家买了CDN加速服务。当B的速度不够的时候，CDN加速就会选择有节余的节点来帮B，提高B的速度。这样B的速度就能达到或超过15M ，A没浪费，B速度有了，C赚了钱，皆大欢喜。 当C的节点在全国都有，非常多的时候。那么你用C家的CDN加速服务，你就会健步如飞了</strong>。</p>\n<h6 id=\"CDN工作流程\"><a href=\"#CDN工作流程\" class=\"headerlink\" title=\"CDN工作流程\"></a>CDN工作流程</h6><p>一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。</p>\n<h6 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h6><p>负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。<br>CDN整体的工作流程可以大概归为下图：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6mup956fj30yg0f5wx0.jpg\" alt=\"image.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上就是Http请求的一些理解，如果有不对的地方及时与我来沟通。</p>"},{"title":"iOS端自动内存泄漏检测工具","date":"2018-01-24T03:41:50.000Z","comments":1,"_content":"#### 产生的背景\n  在移动设备上内存是一块公用的区域，如果一个App没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。\nFacebook的iOS端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在Facebook里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作：\n<!--more-->\n* 1：打开Xcode并且Build\n* 2：运行instrument\n* 3：使用App尽可能的去复现\n* 4：寻找内存泄漏的来源\n* 5：解决问题\n    \n\n  这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。\n\n  将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来[FBRetainCycleDetector](https://github.com/facebook/FBRetainCycleDetector), [FBAllocationTracker](https://github.com/facebook/FBAllocationTracker), and [FBMemoryProfiler](https://github.com/facebook/FBMemoryProfiler).\n#### 循环引用\n  Objective-C使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。\n\n&emsp;&emsp;一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个obj不在相互持有，而是通过另一个obj来互相持有，这样就会陷入一个循环引用的状态就像下面这张图\n\n![循环引用](https://ws1.sinaimg.cn/large/006tNc79gy1fnrkogrtqbj30kg0cndhd.jpg)\n\n一个View Controller持有一个Viw View中持有delegate delegate中持有ViewController。这样就形成一个环状，谁也无法释放。\n\n&emsp;&emsp;循环引用会导致一些列的的问题，如果一个对象在RAM中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致App的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的crash。\n\n&emsp;&emsp;在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这SDK能很轻松的做这些事。\n#### 在Runtime下的循环引用检测\n&emsp;&emsp;在OC中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果A引用B那么A到B就会有箭头指向可以看这个\n![image.png](https://ws4.sinaimg.cn/large/006tNc79gy1fo6kvv1735j30yg0mv0ug.jpg)我们发现这张图在箭头处发生循环引用\n\n&emsp;&emsp;这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用(持有的)对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。\n\n&emsp;&emsp;幸运的是OC给我提供了强大的Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是block或者是Object中的其中一个，让我们来分别讨论下\n#### Objects\n&emsp;&emsp;Runtime中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系\n```\nconst char *class_getIvarLayout(Class cls);\nconst char *class_getWeakIvarLayout(Class cls);\n```\n对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个“弱引用”的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。\n\n&emsp;&emsp;对于objective-c++来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过Runtime给我提供了“类型编码”来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是objective-c的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。\n\n&emsp;&emsp;还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。\n#### Blocks\n&emsp;&emsp;block和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理block时，我们使用了Mike Ash在他的项目[Circle](https://github.com/mikeash/Circle)中提出的想法:也正是这个项目激发FBRetainCycleDetector的项目。\n\n&emsp;$emsp;我们可以使用[application binary interface for blocks](http://clang.llvm.org/docs/Block-ABI-Apple.html) (ABI)，他可以向我们展示一个block在内存中是什么样子的，如果我们知道了我们所研究的block的表现形式我们就可以用一个假的结构体来模仿实现block的功能，之后我们就能知道了哪些对象被block引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。\n\n&emsp;&emsp;为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的block上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些block是被强引用的。这样一来我们可以找到我们原始block所持有的真是的对象，如下图所示\n\n\n![block](https://ws2.sinaimg.cn/large/006tNc79gy1fnrkpskc4zj30kg0fd76k.jpg)\n\n#### 自动化\n&emsp;&emsp;员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了FBAllocationTracker，他可以追踪任何一个Nsobject对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。\n\n&emsp;&emsp;在客户端上实现了这样的自动化操作意味着我们可以更加简单的在NSTimer上使用FBRetainCycleDetector和添加用了追踪实例的FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示A->B就是一个坏的引用环导致了A->B->C->D和A->B->C->E\n\n![引用环](https://ws2.sinaimg.cn/large/006tNc79gy1fnrkrd6o9oj30kg0j6acn.jpg)\n\n遇到这样的问题就会给我们的SDK带来两个问题：\n*  如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。\n\n*  如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来\n\n因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。\n* 1：把给定日期中所检测出的所有循环引用收集起来。\n* 2：找到每个循环引用环中Facebook特定的类名。\n* 3：找到每个环中最小的那个环。\n* 4：把最小周期放到一个组中。\n* 5：仅仅只像开发者报告最小的周期。\n\n有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过“git/hg blame”来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示\n\n![系统图](https://ws3.sinaimg.cn/large/006tNc79gy1fnrkrs9hmvj30kg0660ua.jpg)\n#### 手工配置\n&emsp;&emsp;尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用FBAllocationTracker和fbretaincycle检测器来完成。\n\n原文链接 https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/\n","source":"_posts/2018-01-24-iOS端自动内存泄漏检测工具.md","raw":"---\ntitle: iOS端自动内存泄漏检测工具\ncategories: 译文\ndate: 2018-01-24 11:41:50\ntags:\n  - 翻译\n  - 优化\n  - 国外文献\ncomments:\n---\n#### 产生的背景\n  在移动设备上内存是一块公用的区域，如果一个App没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。\nFacebook的iOS端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在Facebook里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作：\n<!--more-->\n* 1：打开Xcode并且Build\n* 2：运行instrument\n* 3：使用App尽可能的去复现\n* 4：寻找内存泄漏的来源\n* 5：解决问题\n    \n\n  这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。\n\n  将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来[FBRetainCycleDetector](https://github.com/facebook/FBRetainCycleDetector), [FBAllocationTracker](https://github.com/facebook/FBAllocationTracker), and [FBMemoryProfiler](https://github.com/facebook/FBMemoryProfiler).\n#### 循环引用\n  Objective-C使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。\n\n&emsp;&emsp;一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个obj不在相互持有，而是通过另一个obj来互相持有，这样就会陷入一个循环引用的状态就像下面这张图\n\n![循环引用](https://ws1.sinaimg.cn/large/006tNc79gy1fnrkogrtqbj30kg0cndhd.jpg)\n\n一个View Controller持有一个Viw View中持有delegate delegate中持有ViewController。这样就形成一个环状，谁也无法释放。\n\n&emsp;&emsp;循环引用会导致一些列的的问题，如果一个对象在RAM中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致App的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的crash。\n\n&emsp;&emsp;在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这SDK能很轻松的做这些事。\n#### 在Runtime下的循环引用检测\n&emsp;&emsp;在OC中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果A引用B那么A到B就会有箭头指向可以看这个\n![image.png](https://ws4.sinaimg.cn/large/006tNc79gy1fo6kvv1735j30yg0mv0ug.jpg)我们发现这张图在箭头处发生循环引用\n\n&emsp;&emsp;这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用(持有的)对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。\n\n&emsp;&emsp;幸运的是OC给我提供了强大的Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是block或者是Object中的其中一个，让我们来分别讨论下\n#### Objects\n&emsp;&emsp;Runtime中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系\n```\nconst char *class_getIvarLayout(Class cls);\nconst char *class_getWeakIvarLayout(Class cls);\n```\n对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个“弱引用”的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。\n\n&emsp;&emsp;对于objective-c++来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过Runtime给我提供了“类型编码”来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是objective-c的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。\n\n&emsp;&emsp;还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。\n#### Blocks\n&emsp;&emsp;block和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理block时，我们使用了Mike Ash在他的项目[Circle](https://github.com/mikeash/Circle)中提出的想法:也正是这个项目激发FBRetainCycleDetector的项目。\n\n&emsp;$emsp;我们可以使用[application binary interface for blocks](http://clang.llvm.org/docs/Block-ABI-Apple.html) (ABI)，他可以向我们展示一个block在内存中是什么样子的，如果我们知道了我们所研究的block的表现形式我们就可以用一个假的结构体来模仿实现block的功能，之后我们就能知道了哪些对象被block引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。\n\n&emsp;&emsp;为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的block上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些block是被强引用的。这样一来我们可以找到我们原始block所持有的真是的对象，如下图所示\n\n\n![block](https://ws2.sinaimg.cn/large/006tNc79gy1fnrkpskc4zj30kg0fd76k.jpg)\n\n#### 自动化\n&emsp;&emsp;员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了FBAllocationTracker，他可以追踪任何一个Nsobject对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。\n\n&emsp;&emsp;在客户端上实现了这样的自动化操作意味着我们可以更加简单的在NSTimer上使用FBRetainCycleDetector和添加用了追踪实例的FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示A->B就是一个坏的引用环导致了A->B->C->D和A->B->C->E\n\n![引用环](https://ws2.sinaimg.cn/large/006tNc79gy1fnrkrd6o9oj30kg0j6acn.jpg)\n\n遇到这样的问题就会给我们的SDK带来两个问题：\n*  如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。\n\n*  如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来\n\n因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。\n* 1：把给定日期中所检测出的所有循环引用收集起来。\n* 2：找到每个循环引用环中Facebook特定的类名。\n* 3：找到每个环中最小的那个环。\n* 4：把最小周期放到一个组中。\n* 5：仅仅只像开发者报告最小的周期。\n\n有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过“git/hg blame”来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示\n\n![系统图](https://ws3.sinaimg.cn/large/006tNc79gy1fnrkrs9hmvj30kg0660ua.jpg)\n#### 手工配置\n&emsp;&emsp;尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用FBAllocationTracker和fbretaincycle检测器来完成。\n\n原文链接 https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/\n","slug":"iOS端自动内存泄漏检测工具","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2l5000sa04w8magd3vy","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h4 id=\"产生的背景\"><a href=\"#产生的背景\" class=\"headerlink\" title=\"产生的背景\"></a>产生的背景</h4><p>  在移动设备上内存是一块公用的区域，如果一个App没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。<br>Facebook的iOS端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在Facebook里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作：<br><a id=\"more\"></a></p>\n<ul>\n<li>1：打开Xcode并且Build</li>\n<li>2：运行instrument</li>\n<li>3：使用App尽可能的去复现</li>\n<li>4：寻找内存泄漏的来源</li>\n<li>5：解决问题\n    </li>\n</ul>\n<p>  这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。</p>\n<p>  将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来<a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\" rel=\"noopener\">FBRetainCycleDetector</a>, <a href=\"https://github.com/facebook/FBAllocationTracker\" target=\"_blank\" rel=\"noopener\">FBAllocationTracker</a>, and <a href=\"https://github.com/facebook/FBMemoryProfiler\" target=\"_blank\" rel=\"noopener\">FBMemoryProfiler</a>.</p>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>  Objective-C使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。</p>\n<p>&emsp;&emsp;一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个obj不在相互持有，而是通过另一个obj来互相持有，这样就会陷入一个循环引用的状态就像下面这张图</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fnrkogrtqbj30kg0cndhd.jpg\" alt=\"循环引用\"></p>\n<p>一个View Controller持有一个Viw View中持有delegate delegate中持有ViewController。这样就形成一个环状，谁也无法释放。</p>\n<p>&emsp;&emsp;循环引用会导致一些列的的问题，如果一个对象在RAM中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致App的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的crash。</p>\n<p>&emsp;&emsp;在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这SDK能很轻松的做这些事。</p>\n<h4 id=\"在Runtime下的循环引用检测\"><a href=\"#在Runtime下的循环引用检测\" class=\"headerlink\" title=\"在Runtime下的循环引用检测\"></a>在Runtime下的循环引用检测</h4><p>&emsp;&emsp;在OC中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果A引用B那么A到B就会有箭头指向可以看这个<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6kvv1735j30yg0mv0ug.jpg\" alt=\"image.png\">我们发现这张图在箭头处发生循环引用</p>\n<p>&emsp;&emsp;这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用(持有的)对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。</p>\n<p>&emsp;&emsp;幸运的是OC给我提供了强大的Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是block或者是Object中的其中一个，让我们来分别讨论下</p>\n<h4 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h4><p>&emsp;&emsp;Runtime中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"title\">class_getIvarLayout</span><span class=\"params\">(Class cls)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"title\">class_getWeakIvarLayout</span><span class=\"params\">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个“弱引用”的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。</p>\n<p>&emsp;&emsp;对于objective-c++来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过Runtime给我提供了“类型编码”来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是objective-c的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。</p>\n<p>&emsp;&emsp;还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。</p>\n<h4 id=\"Blocks\"><a href=\"#Blocks\" class=\"headerlink\" title=\"Blocks\"></a>Blocks</h4><p>&emsp;&emsp;block和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理block时，我们使用了Mike Ash在他的项目<a href=\"https://github.com/mikeash/Circle\" target=\"_blank\" rel=\"noopener\">Circle</a>中提出的想法:也正是这个项目激发FBRetainCycleDetector的项目。</p>\n<p>&emsp;$emsp;我们可以使用<a href=\"http://clang.llvm.org/docs/Block-ABI-Apple.html\" target=\"_blank\" rel=\"noopener\">application binary interface for blocks</a> (ABI)，他可以向我们展示一个block在内存中是什么样子的，如果我们知道了我们所研究的block的表现形式我们就可以用一个假的结构体来模仿实现block的功能，之后我们就能知道了哪些对象被block引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。</p>\n<p>&emsp;&emsp;为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的block上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些block是被强引用的。这样一来我们可以找到我们原始block所持有的真是的对象，如下图所示</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fnrkpskc4zj30kg0fd76k.jpg\" alt=\"block\"></p>\n<h4 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h4><p>&emsp;&emsp;员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了FBAllocationTracker，他可以追踪任何一个Nsobject对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。</p>\n<p>&emsp;&emsp;在客户端上实现了这样的自动化操作意味着我们可以更加简单的在NSTimer上使用FBRetainCycleDetector和添加用了追踪实例的FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示A-&gt;B就是一个坏的引用环导致了A-&gt;B-&gt;C-&gt;D和A-&gt;B-&gt;C-&gt;E</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fnrkrd6o9oj30kg0j6acn.jpg\" alt=\"引用环\"></p>\n<p>遇到这样的问题就会给我们的SDK带来两个问题：</p>\n<ul>\n<li><p>如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。</p>\n</li>\n<li><p>如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来</p>\n</li>\n</ul>\n<p>因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。</p>\n<ul>\n<li>1：把给定日期中所检测出的所有循环引用收集起来。</li>\n<li>2：找到每个循环引用环中Facebook特定的类名。</li>\n<li>3：找到每个环中最小的那个环。</li>\n<li>4：把最小周期放到一个组中。</li>\n<li>5：仅仅只像开发者报告最小的周期。</li>\n</ul>\n<p>有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过“git/hg blame”来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fnrkrs9hmvj30kg0660ua.jpg\" alt=\"系统图\"></p>\n<h4 id=\"手工配置\"><a href=\"#手工配置\" class=\"headerlink\" title=\"手工配置\"></a>手工配置</h4><p>&emsp;&emsp;尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用FBAllocationTracker和fbretaincycle检测器来完成。</p>\n<p>原文链接 <a href=\"https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/\" target=\"_blank\" rel=\"noopener\">https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"产生的背景\"><a href=\"#产生的背景\" class=\"headerlink\" title=\"产生的背景\"></a>产生的背景</h4><p>  在移动设备上内存是一块公用的区域，如果一个App没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。<br>Facebook的iOS端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在Facebook里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作：<br>","more":"</p>\n<ul>\n<li>1：打开Xcode并且Build</li>\n<li>2：运行instrument</li>\n<li>3：使用App尽可能的去复现</li>\n<li>4：寻找内存泄漏的来源</li>\n<li>5：解决问题\n    </li>\n</ul>\n<p>  这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。</p>\n<p>  将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来<a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\" rel=\"noopener\">FBRetainCycleDetector</a>, <a href=\"https://github.com/facebook/FBAllocationTracker\" target=\"_blank\" rel=\"noopener\">FBAllocationTracker</a>, and <a href=\"https://github.com/facebook/FBMemoryProfiler\" target=\"_blank\" rel=\"noopener\">FBMemoryProfiler</a>.</p>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>  Objective-C使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。</p>\n<p>&emsp;&emsp;一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个obj不在相互持有，而是通过另一个obj来互相持有，这样就会陷入一个循环引用的状态就像下面这张图</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fnrkogrtqbj30kg0cndhd.jpg\" alt=\"循环引用\"></p>\n<p>一个View Controller持有一个Viw View中持有delegate delegate中持有ViewController。这样就形成一个环状，谁也无法释放。</p>\n<p>&emsp;&emsp;循环引用会导致一些列的的问题，如果一个对象在RAM中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致App的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的crash。</p>\n<p>&emsp;&emsp;在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这SDK能很轻松的做这些事。</p>\n<h4 id=\"在Runtime下的循环引用检测\"><a href=\"#在Runtime下的循环引用检测\" class=\"headerlink\" title=\"在Runtime下的循环引用检测\"></a>在Runtime下的循环引用检测</h4><p>&emsp;&emsp;在OC中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果A引用B那么A到B就会有箭头指向可以看这个<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6kvv1735j30yg0mv0ug.jpg\" alt=\"image.png\">我们发现这张图在箭头处发生循环引用</p>\n<p>&emsp;&emsp;这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用(持有的)对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。</p>\n<p>&emsp;&emsp;幸运的是OC给我提供了强大的Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是block或者是Object中的其中一个，让我们来分别讨论下</p>\n<h4 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h4><p>&emsp;&emsp;Runtime中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"title\">class_getIvarLayout</span><span class=\"params\">(Class cls)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"title\">class_getWeakIvarLayout</span><span class=\"params\">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个“弱引用”的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。</p>\n<p>&emsp;&emsp;对于objective-c++来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过Runtime给我提供了“类型编码”来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是objective-c的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。</p>\n<p>&emsp;&emsp;还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。</p>\n<h4 id=\"Blocks\"><a href=\"#Blocks\" class=\"headerlink\" title=\"Blocks\"></a>Blocks</h4><p>&emsp;&emsp;block和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理block时，我们使用了Mike Ash在他的项目<a href=\"https://github.com/mikeash/Circle\" target=\"_blank\" rel=\"noopener\">Circle</a>中提出的想法:也正是这个项目激发FBRetainCycleDetector的项目。</p>\n<p>&emsp;$emsp;我们可以使用<a href=\"http://clang.llvm.org/docs/Block-ABI-Apple.html\" target=\"_blank\" rel=\"noopener\">application binary interface for blocks</a> (ABI)，他可以向我们展示一个block在内存中是什么样子的，如果我们知道了我们所研究的block的表现形式我们就可以用一个假的结构体来模仿实现block的功能，之后我们就能知道了哪些对象被block引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。</p>\n<p>&emsp;&emsp;为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的block上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些block是被强引用的。这样一来我们可以找到我们原始block所持有的真是的对象，如下图所示</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fnrkpskc4zj30kg0fd76k.jpg\" alt=\"block\"></p>\n<h4 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h4><p>&emsp;&emsp;员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了FBAllocationTracker，他可以追踪任何一个Nsobject对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。</p>\n<p>&emsp;&emsp;在客户端上实现了这样的自动化操作意味着我们可以更加简单的在NSTimer上使用FBRetainCycleDetector和添加用了追踪实例的FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示A-&gt;B就是一个坏的引用环导致了A-&gt;B-&gt;C-&gt;D和A-&gt;B-&gt;C-&gt;E</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fnrkrd6o9oj30kg0j6acn.jpg\" alt=\"引用环\"></p>\n<p>遇到这样的问题就会给我们的SDK带来两个问题：</p>\n<ul>\n<li><p>如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。</p>\n</li>\n<li><p>如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来</p>\n</li>\n</ul>\n<p>因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。</p>\n<ul>\n<li>1：把给定日期中所检测出的所有循环引用收集起来。</li>\n<li>2：找到每个循环引用环中Facebook特定的类名。</li>\n<li>3：找到每个环中最小的那个环。</li>\n<li>4：把最小周期放到一个组中。</li>\n<li>5：仅仅只像开发者报告最小的周期。</li>\n</ul>\n<p>有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过“git/hg blame”来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fnrkrs9hmvj30kg0660ua.jpg\" alt=\"系统图\"></p>\n<h4 id=\"手工配置\"><a href=\"#手工配置\" class=\"headerlink\" title=\"手工配置\"></a>手工配置</h4><p>&emsp;&emsp;尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用FBAllocationTracker和fbretaincycle检测器来完成。</p>\n<p>原文链接 <a href=\"https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/\" target=\"_blank\" rel=\"noopener\">https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/</a></p>"},{"title":"可能是最全的iOS端HttpDns集成方案","date":"2018-01-24T05:54:36.000Z","comments":1,"_content":"# 科普片\n##### 1、DNS劫持的危害\n  不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇(se)怪(qing)的东西\n\n![图一](https://ws2.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg)\n\n或者这样\n<!--more-->\n\n![图二](https://ws4.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg)，\n\n其实造成这样的原因就是DNS劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。\n##### 2、什么是DNS解析\n  现在假如我们访问一个网站www.baidu.com从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤\n* 1：计算机会向我们的运营商(移动、电信、联通等)发出打开www.baidu.com的请求。\n* 2：运营商收到请求后会到自己的DNS服务器中找www.baidu.com这个域名所对应的服务器的IP地址(也就是百度的服务器的IP地址)，这里比如是180.149.132.47。\n* 3：运营商用第二步得到的IP地址去找到百度的服务器请求得到数据后返回给我们。\n\n其中第二步就是我们所说的DNS解析过程，域名和IP地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是IP地址\\身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在IP上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是IP的，所以DNS解析就应运而生了。\n##### 3：什么是DNS劫持\nDNS劫持，是指在DNS解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：\n* 1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。\n* 2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。\n\n##### 4：防止DNS劫持\n  了解了DNS劫持的相关资料后我们就知道了，防止NDS劫持就要从第二步入手，因为DNS解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，将我们原本的请求链接www.baidu.com 修改为180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是IP地址就会直接给我们放行，而不会去走他自己DNS解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的DNS解析也就不会存在DNS被劫持的问题，从根本是解决了。\n# 技术篇\n##### 5：项目中的实际操作\n\n###### 5.1：DNSPOD相关\n  我们知道要要把项目中请求的接口替换成成IP其实很简单，URL是字符串，域名替换IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云(没开源)，七牛云(开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个SDK，传个普通的URL进去就会返回一个域名被替换成IP的URL出来，也比较好用，这里要说一下IP地址的来源，如何拿到一个域名所对应的IP呢？这里就是需要用到另一个服务——HTTPDNS，国内比较有名的就是DNSPOD，包括阿里，七牛等也是使用他们的DNS服务来解析，就是这个\n\n![DNSPOD logo](https://ws3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg)\n\n![简介](https://ws2.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg)\n\n他会给我们提供一个接口，我们使用HTTP请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的IP列表返回回来。类似这样：\n```\n///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY\nNSString *url = [NSString stringWithFormat:@\"http://119.29.29.29/d?ttl=1&dn=www.baidu.com&id=KEY\"];\nNSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10];\nNSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:&networkError];\n```\n\n这里使用同步还是异步都是可以的，具体根据你们业务需求。\n\n###### 5.2：项目中的使用\n \n其实dnspod最难的部分是接入的部分，因为不同的APP不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把DNS解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到APP所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的APP中加入DNS防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是NSURLProtocol + Runtime hook方式来处理这些东西的，NSURLProtocol属于iOS黑魔法的一种可以拦截任何从APP的 URL Loading System系统中发出的请求，其中包括如下\n* File Transfer Protocol (ftp://)\n* Hypertext Transfer Protocol (http://)\n* Hypertext Transfer Protocol with encryption (https://)\n* Local file URLs (file:///)\n* Data URLs (data://)\n\n如果你的请求不在以上列表中就不能进行拦截了，比如WKWebview，AVPlayer(比较特殊，虽然请求也是http/https但是就是不走这套系统，苹果爸爸就是这样~)等，其实对于正常来说光用已经NSURLProtocol足够了。\n  NSURLProtocol这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样\n  ```\n // 注册自定义protocol\n[NSURLProtocol registerClass:[CustomURLProtocol class]];\n NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\nconfiguration.protocolClasses = @[[CustomURLProtocol class]];\n```\n在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法\n```\n+ (BOOL)canInitWithRequest:(NSURLRequest *)request;\n+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;\n- (void)startLoading;\n//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法\n- (void)stopLoading;\n```\n###### + (BOOL)canInitWithRequest:(NSURLRequest *)request;\n通过返回值来告诉NSUrlProtocol对进来的请求是否拦截，比如我只拦截HTTP的，或者是某个域名的请求之类\n###### + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;\n如果上面的方法返回YES那么request会传到这里，这个地方通常不做处理 直接返回request\n\n###### - (void)startLoading;\n这个地方就是对我们拦截的请求做一些处理，我们文中所做的IP对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样\n```\n- (void)startLoading {\n///其中customRequest是处理过的请求(域名替换后的)\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:[[NSURLSessionConfiguration alloc] init] delegate:self delegateQueue:nil];\n    NSURLSessionDataTask *task = [session dataTaskWithRequest:customRequest];\n    [task resume];\n}\n```\n你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：\n```\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {\n    [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];\n\n    completionHandler(NSURLSessionResponseAllow);\n}\n\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {\n    [[self client] URLProtocol:self didLoadData:data];\n}\n```\nclient在后面会有讲解。\n###### - (void)stopLoading;\n请求完毕后调用\n大概的执行流程是这样\n\n![流程](https://ws1.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg)\n\n在NSURLProtocol中有一个贯穿始终的变量\n```\n/*!\n    @method client\n    @abstract Returns the NSURLProtocolClient of the receiver.\n    @result The NSURLProtocolClient of the receiver.  \n*/\n@property (nullable, readonly, retain) id <NSURLProtocolClient> client;\n\n```\n你可以认为是这个是请求的发送者，打个比方，A想给B发送一个消息，由于距离遥远于是A去了邮局，A把消息内容告诉了邮局，并且A在邮局登记了自己名字方便B有反馈的时候邮局来通知A查收。这个例子中邮局就是NSURLProtocol，A在邮局登记的名字就是client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：\n```\n@protocol NSURLProtocolClient <NSObject>\n...\n- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;\n\n- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;\n\n- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;\n...\n@end\n```\n当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。\n到此正常情况下的DNS的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的URL的就会变成http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧)\n\n##### 6：遇到的坑点\n###### 6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\n```\n[mutableRequest setValue:self.request.URL.host forHTTPHeaderField:@\"HOST\"];\n```\n###### 加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\n```\n[mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@\"Cookie\"];\n```\n###### 6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\n```\n // 注册自定义protocol\n[NSURLProtocol registerClass:[CustomURLProtocol class]];\n NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\nconfiguration.protocolClasses = @[[CustomURLProtocol class]];\n```\n###### 在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\n```\nAFHTTPSessionManager * sessionManager = [AFHTTPSessionManager manager];\n```\n###### 我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\n```\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    if (!configuration) {\n        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    }\n\n    self.sessionConfiguration = configuration;\n    self.operationQueue = [[NSOperationQueue alloc] init];\n    self.operationQueue.maxConcurrentOperationCount = 1;\n\n    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];\n    .\n    .\n    .\n}\n\n```\n###### 大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\n```\n+ (NSURLSession *)swizzle_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration {\n\n    NSURLSessionConfiguration *newConfiguration = configuration;\n    // 在现有的Configuration中插入我们自定义的protocol\n    if (configuration) {\n        NSMutableArray *protocolArray = [NSMutableArray arrayWithArray:configuration.protocolClasses];\n        [protocolArray insertObject:[CustomProtocol class] atIndex:0];\n        newConfiguration.protocolClasses = protocolArray;\n    }\n    else {\n        newConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];\n        NSMutableArray *protocolArray = [NSMutableArray arrayWithArray:configuration.protocolClasses];\n        [protocolArray insertObject:[CustomProtocol class] atIndex:0];\n        newConfiguration.protocolClasses = protocolArray;\n    }\n\n    return [self swizzle_sessionWithConfiguration:newConfiguration];\n}\n```\n###### 然后就完美解决了。不过要注意下系统的是有两个方法的\n```\n/*\n * Customization of NSURLSession occurs during creation of a new session.\n * If you only need to use the convenience routines with custom\n * configuration options it is not necessary to specify a delegate.\n * If you do specify a delegate, the delegate will be retained until after\n * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.\n */\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id <NSURLSessionDelegate>)delegate delegateQueue:(nullable NSOperationQueue *)queue;\n```\n###### 这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\n###### 6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\n```\n/*!\n  @method\t\tinitWithURL:options:\n  @abstract\t\tInitializes an instance of AVURLAsset for inspection of a media resource.\n  @param\t\tURL\n\t\t\t\tAn instance of NSURL that references a media resource.\n  @param\t\toptions\n\t\t\t\tAn instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.\n  @result\t\tAn instance of AVURLAsset.\n*/\n- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary<NSString *, id> *)options NS_DESIGNATED_INITIALIZER;\n```\n###### 其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\n```\nAVF_EXPORT NSString *const AVURLAssetPreferPreciseDurationAndTimingKey NS_AVAILABLE(10_7, 4_0);\nAVF_EXPORT NSString *const AVURLAssetReferenceRestrictionsKey NS_AVAILABLE(10_7, 5_0);\nAVF_EXPORT NSString *const AVURLAssetHTTPCookiesKey NS_AVAILABLE_IOS(8_0);\nAVF_EXPORT NSString *const AVURLAssetAllowsCellularAccessKey NS_AVAILABLE_IOS(10_0);\n```\n###### 但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\n```\n[self swizzle_initWithURL:videoURL options:@{AVURLAssetHTTPHeaderFieldsKey : @{@\"Host\":host}}]\n```\n###### 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\n```\n//加密后的KEY\nconst NSString * headerKey = @\"35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F\";\n.\n.\n.\n//getRequestHeaderKey方法为解密方法\nreturn [self swizzle_initWithURL:videoURL options:@{[self getRequestHeaderKey] : @{@\"Host\":host}}];\n```\n###### 这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\n###### 6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\n```\n#pragma mark -\n#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体\n- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request {\n    NSMutableURLRequest * req = [request mutableCopy];\n    if ([request.HTTPMethod isEqualToString:@\"POST\"]) {\n        if (!request.HTTPBody) {\n            uint8_t d[1024] = {0};\n            NSInputStream *stream = request.HTTPBodyStream;\n            NSMutableData *data = [[NSMutableData alloc] init];\n            [stream open];\n            while ([stream hasBytesAvailable]) {\n                NSInteger len = [stream read:d maxLength:1024];\n                if (len > 0 && stream.streamError == nil) {\n                    [data appendBytes:(void *)d length:len];\n                }\n            }\n            req.HTTPBody = [data copy];\n            [stream close];\n        }\n    }\n    return req;\n}\n\n```\n###### 这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\n###### 6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\n###### 6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，**[阿里云文档](https://help.aliyun.com/document_detail/30143.html)**有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\n![阿里云文档截图](https://ws3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg)\n###### 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我**[主要的参考资料](https://github.com/Dave1991/alicloud-ios-demo/blob/master/httpdns_ios_demo/httpdns_ios_demo/CFHttpMessageURLProtocol.m)**发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\n```\n if ([self.request.URL.scheme isEqualToString:@\"https\"] ) {\n//使用CFnetwork\n        curRequest = req;\n        self.task = [[CustomCFNetworkRequestTask alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:self];\n        if (self.task) {\n            [self.task startLoading];\n        }\n    } else {\n//使用普通网络请求\n        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n        self.session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue mainQueue]];\n        NSURLSessionTask *task = [self.session dataTaskWithRequest:req];\n        [task resume];\n    }\n```\n###### 我是这么做的。\n###### 6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\n##### 7：总结\n  完成了以上的步骤之后你回发现在DNS坏掉的情况下手机里面除了微信QQ(他们也做了DNS解析)之外其他应用都不能上网了但是你的App依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧\n","source":"_posts/2018-01-24-可能是最全的iOS端HttpDns集成方案.md","raw":"---\ntitle: 可能是最全的iOS端HttpDns集成方案\ncategories: iOS开发\ndate: 2018-01-24 13:54:36\ntags:\n  - 网络\n  - httpdns\n  - 底层\ncomments:\n---\n# 科普片\n##### 1、DNS劫持的危害\n  不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇(se)怪(qing)的东西\n\n![图一](https://ws2.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg)\n\n或者这样\n<!--more-->\n\n![图二](https://ws4.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg)，\n\n其实造成这样的原因就是DNS劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。\n##### 2、什么是DNS解析\n  现在假如我们访问一个网站www.baidu.com从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤\n* 1：计算机会向我们的运营商(移动、电信、联通等)发出打开www.baidu.com的请求。\n* 2：运营商收到请求后会到自己的DNS服务器中找www.baidu.com这个域名所对应的服务器的IP地址(也就是百度的服务器的IP地址)，这里比如是180.149.132.47。\n* 3：运营商用第二步得到的IP地址去找到百度的服务器请求得到数据后返回给我们。\n\n其中第二步就是我们所说的DNS解析过程，域名和IP地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是IP地址\\身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在IP上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是IP的，所以DNS解析就应运而生了。\n##### 3：什么是DNS劫持\nDNS劫持，是指在DNS解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：\n* 1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。\n* 2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。\n\n##### 4：防止DNS劫持\n  了解了DNS劫持的相关资料后我们就知道了，防止NDS劫持就要从第二步入手，因为DNS解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，将我们原本的请求链接www.baidu.com 修改为180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是IP地址就会直接给我们放行，而不会去走他自己DNS解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的DNS解析也就不会存在DNS被劫持的问题，从根本是解决了。\n# 技术篇\n##### 5：项目中的实际操作\n\n###### 5.1：DNSPOD相关\n  我们知道要要把项目中请求的接口替换成成IP其实很简单，URL是字符串，域名替换IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云(没开源)，七牛云(开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个SDK，传个普通的URL进去就会返回一个域名被替换成IP的URL出来，也比较好用，这里要说一下IP地址的来源，如何拿到一个域名所对应的IP呢？这里就是需要用到另一个服务——HTTPDNS，国内比较有名的就是DNSPOD，包括阿里，七牛等也是使用他们的DNS服务来解析，就是这个\n\n![DNSPOD logo](https://ws3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg)\n\n![简介](https://ws2.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg)\n\n他会给我们提供一个接口，我们使用HTTP请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的IP列表返回回来。类似这样：\n```\n///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY\nNSString *url = [NSString stringWithFormat:@\"http://119.29.29.29/d?ttl=1&dn=www.baidu.com&id=KEY\"];\nNSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10];\nNSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:&networkError];\n```\n\n这里使用同步还是异步都是可以的，具体根据你们业务需求。\n\n###### 5.2：项目中的使用\n \n其实dnspod最难的部分是接入的部分，因为不同的APP不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把DNS解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到APP所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的APP中加入DNS防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是NSURLProtocol + Runtime hook方式来处理这些东西的，NSURLProtocol属于iOS黑魔法的一种可以拦截任何从APP的 URL Loading System系统中发出的请求，其中包括如下\n* File Transfer Protocol (ftp://)\n* Hypertext Transfer Protocol (http://)\n* Hypertext Transfer Protocol with encryption (https://)\n* Local file URLs (file:///)\n* Data URLs (data://)\n\n如果你的请求不在以上列表中就不能进行拦截了，比如WKWebview，AVPlayer(比较特殊，虽然请求也是http/https但是就是不走这套系统，苹果爸爸就是这样~)等，其实对于正常来说光用已经NSURLProtocol足够了。\n  NSURLProtocol这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样\n  ```\n // 注册自定义protocol\n[NSURLProtocol registerClass:[CustomURLProtocol class]];\n NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\nconfiguration.protocolClasses = @[[CustomURLProtocol class]];\n```\n在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法\n```\n+ (BOOL)canInitWithRequest:(NSURLRequest *)request;\n+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;\n- (void)startLoading;\n//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法\n- (void)stopLoading;\n```\n###### + (BOOL)canInitWithRequest:(NSURLRequest *)request;\n通过返回值来告诉NSUrlProtocol对进来的请求是否拦截，比如我只拦截HTTP的，或者是某个域名的请求之类\n###### + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;\n如果上面的方法返回YES那么request会传到这里，这个地方通常不做处理 直接返回request\n\n###### - (void)startLoading;\n这个地方就是对我们拦截的请求做一些处理，我们文中所做的IP对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样\n```\n- (void)startLoading {\n///其中customRequest是处理过的请求(域名替换后的)\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:[[NSURLSessionConfiguration alloc] init] delegate:self delegateQueue:nil];\n    NSURLSessionDataTask *task = [session dataTaskWithRequest:customRequest];\n    [task resume];\n}\n```\n你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：\n```\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {\n    [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];\n\n    completionHandler(NSURLSessionResponseAllow);\n}\n\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {\n    [[self client] URLProtocol:self didLoadData:data];\n}\n```\nclient在后面会有讲解。\n###### - (void)stopLoading;\n请求完毕后调用\n大概的执行流程是这样\n\n![流程](https://ws1.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg)\n\n在NSURLProtocol中有一个贯穿始终的变量\n```\n/*!\n    @method client\n    @abstract Returns the NSURLProtocolClient of the receiver.\n    @result The NSURLProtocolClient of the receiver.  \n*/\n@property (nullable, readonly, retain) id <NSURLProtocolClient> client;\n\n```\n你可以认为是这个是请求的发送者，打个比方，A想给B发送一个消息，由于距离遥远于是A去了邮局，A把消息内容告诉了邮局，并且A在邮局登记了自己名字方便B有反馈的时候邮局来通知A查收。这个例子中邮局就是NSURLProtocol，A在邮局登记的名字就是client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：\n```\n@protocol NSURLProtocolClient <NSObject>\n...\n- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;\n\n- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;\n\n- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;\n...\n@end\n```\n当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。\n到此正常情况下的DNS的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的URL的就会变成http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧)\n\n##### 6：遇到的坑点\n###### 6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\n```\n[mutableRequest setValue:self.request.URL.host forHTTPHeaderField:@\"HOST\"];\n```\n###### 加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\n```\n[mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@\"Cookie\"];\n```\n###### 6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\n```\n // 注册自定义protocol\n[NSURLProtocol registerClass:[CustomURLProtocol class]];\n NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\nconfiguration.protocolClasses = @[[CustomURLProtocol class]];\n```\n###### 在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\n```\nAFHTTPSessionManager * sessionManager = [AFHTTPSessionManager manager];\n```\n###### 我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\n```\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n\n    if (!configuration) {\n        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    }\n\n    self.sessionConfiguration = configuration;\n    self.operationQueue = [[NSOperationQueue alloc] init];\n    self.operationQueue.maxConcurrentOperationCount = 1;\n\n    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];\n    .\n    .\n    .\n}\n\n```\n###### 大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\n```\n+ (NSURLSession *)swizzle_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration {\n\n    NSURLSessionConfiguration *newConfiguration = configuration;\n    // 在现有的Configuration中插入我们自定义的protocol\n    if (configuration) {\n        NSMutableArray *protocolArray = [NSMutableArray arrayWithArray:configuration.protocolClasses];\n        [protocolArray insertObject:[CustomProtocol class] atIndex:0];\n        newConfiguration.protocolClasses = protocolArray;\n    }\n    else {\n        newConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];\n        NSMutableArray *protocolArray = [NSMutableArray arrayWithArray:configuration.protocolClasses];\n        [protocolArray insertObject:[CustomProtocol class] atIndex:0];\n        newConfiguration.protocolClasses = protocolArray;\n    }\n\n    return [self swizzle_sessionWithConfiguration:newConfiguration];\n}\n```\n###### 然后就完美解决了。不过要注意下系统的是有两个方法的\n```\n/*\n * Customization of NSURLSession occurs during creation of a new session.\n * If you only need to use the convenience routines with custom\n * configuration options it is not necessary to specify a delegate.\n * If you do specify a delegate, the delegate will be retained until after\n * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.\n */\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id <NSURLSessionDelegate>)delegate delegateQueue:(nullable NSOperationQueue *)queue;\n```\n###### 这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\n###### 6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\n```\n/*!\n  @method\t\tinitWithURL:options:\n  @abstract\t\tInitializes an instance of AVURLAsset for inspection of a media resource.\n  @param\t\tURL\n\t\t\t\tAn instance of NSURL that references a media resource.\n  @param\t\toptions\n\t\t\t\tAn instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.\n  @result\t\tAn instance of AVURLAsset.\n*/\n- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary<NSString *, id> *)options NS_DESIGNATED_INITIALIZER;\n```\n###### 其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\n```\nAVF_EXPORT NSString *const AVURLAssetPreferPreciseDurationAndTimingKey NS_AVAILABLE(10_7, 4_0);\nAVF_EXPORT NSString *const AVURLAssetReferenceRestrictionsKey NS_AVAILABLE(10_7, 5_0);\nAVF_EXPORT NSString *const AVURLAssetHTTPCookiesKey NS_AVAILABLE_IOS(8_0);\nAVF_EXPORT NSString *const AVURLAssetAllowsCellularAccessKey NS_AVAILABLE_IOS(10_0);\n```\n###### 但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\n```\n[self swizzle_initWithURL:videoURL options:@{AVURLAssetHTTPHeaderFieldsKey : @{@\"Host\":host}}]\n```\n###### 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\n```\n//加密后的KEY\nconst NSString * headerKey = @\"35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F\";\n.\n.\n.\n//getRequestHeaderKey方法为解密方法\nreturn [self swizzle_initWithURL:videoURL options:@{[self getRequestHeaderKey] : @{@\"Host\":host}}];\n```\n###### 这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\n###### 6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\n```\n#pragma mark -\n#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体\n- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request {\n    NSMutableURLRequest * req = [request mutableCopy];\n    if ([request.HTTPMethod isEqualToString:@\"POST\"]) {\n        if (!request.HTTPBody) {\n            uint8_t d[1024] = {0};\n            NSInputStream *stream = request.HTTPBodyStream;\n            NSMutableData *data = [[NSMutableData alloc] init];\n            [stream open];\n            while ([stream hasBytesAvailable]) {\n                NSInteger len = [stream read:d maxLength:1024];\n                if (len > 0 && stream.streamError == nil) {\n                    [data appendBytes:(void *)d length:len];\n                }\n            }\n            req.HTTPBody = [data copy];\n            [stream close];\n        }\n    }\n    return req;\n}\n\n```\n###### 这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\n###### 6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\n###### 6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，**[阿里云文档](https://help.aliyun.com/document_detail/30143.html)**有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\n![阿里云文档截图](https://ws3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg)\n###### 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我**[主要的参考资料](https://github.com/Dave1991/alicloud-ios-demo/blob/master/httpdns_ios_demo/httpdns_ios_demo/CFHttpMessageURLProtocol.m)**发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\n```\n if ([self.request.URL.scheme isEqualToString:@\"https\"] ) {\n//使用CFnetwork\n        curRequest = req;\n        self.task = [[CustomCFNetworkRequestTask alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:self];\n        if (self.task) {\n            [self.task startLoading];\n        }\n    } else {\n//使用普通网络请求\n        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n        self.session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue mainQueue]];\n        NSURLSessionTask *task = [self.session dataTaskWithRequest:req];\n        [task resume];\n    }\n```\n###### 我是这么做的。\n###### 6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\n##### 7：总结\n  完成了以上的步骤之后你回发现在DNS坏掉的情况下手机里面除了微信QQ(他们也做了DNS解析)之外其他应用都不能上网了但是你的App依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧\n","slug":"可能是最全的iOS端HttpDns集成方案","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2l6000va04wm2ubwmyu","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"科普片\"><a href=\"#科普片\" class=\"headerlink\" title=\"科普片\"></a>科普片</h1><h5 id=\"1、DNS劫持的危害\"><a href=\"#1、DNS劫持的危害\" class=\"headerlink\" title=\"1、DNS劫持的危害\"></a>1、DNS劫持的危害</h5><p>  不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇(se)怪(qing)的东西</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg\" alt=\"图一\"></p>\n<p>或者这样<br><a id=\"more\"></a></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg\" alt=\"图二\">，</p>\n<p>其实造成这样的原因就是DNS劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。</p>\n<h5 id=\"2、什么是DNS解析\"><a href=\"#2、什么是DNS解析\" class=\"headerlink\" title=\"2、什么是DNS解析\"></a>2、什么是DNS解析</h5><p>  现在假如我们访问一个网站www.baidu.com从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤</p>\n<ul>\n<li>1：计算机会向我们的运营商(移动、电信、联通等)发出打开www.baidu.com的请求。</li>\n<li>2：运营商收到请求后会到自己的DNS服务器中找www.baidu.com这个域名所对应的服务器的IP地址(也就是百度的服务器的IP地址)，这里比如是180.149.132.47。</li>\n<li>3：运营商用第二步得到的IP地址去找到百度的服务器请求得到数据后返回给我们。</li>\n</ul>\n<p>其中第二步就是我们所说的DNS解析过程，域名和IP地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是IP地址\\身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在IP上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是IP的，所以DNS解析就应运而生了。</p>\n<h5 id=\"3：什么是DNS劫持\"><a href=\"#3：什么是DNS劫持\" class=\"headerlink\" title=\"3：什么是DNS劫持\"></a>3：什么是DNS劫持</h5><p>DNS劫持，是指在DNS解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：</p>\n<ul>\n<li>1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。</li>\n<li>2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</li>\n</ul>\n<h5 id=\"4：防止DNS劫持\"><a href=\"#4：防止DNS劫持\" class=\"headerlink\" title=\"4：防止DNS劫持\"></a>4：防止DNS劫持</h5><p>  了解了DNS劫持的相关资料后我们就知道了，防止NDS劫持就要从第二步入手，因为DNS解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，将我们原本的请求链接www.baidu.com 修改为180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是IP地址就会直接给我们放行，而不会去走他自己DNS解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的DNS解析也就不会存在DNS被劫持的问题，从根本是解决了。</p>\n<h1 id=\"技术篇\"><a href=\"#技术篇\" class=\"headerlink\" title=\"技术篇\"></a>技术篇</h1><h5 id=\"5：项目中的实际操作\"><a href=\"#5：项目中的实际操作\" class=\"headerlink\" title=\"5：项目中的实际操作\"></a>5：项目中的实际操作</h5><h6 id=\"5-1：DNSPOD相关\"><a href=\"#5-1：DNSPOD相关\" class=\"headerlink\" title=\"5.1：DNSPOD相关\"></a>5.1：DNSPOD相关</h6><p>  我们知道要要把项目中请求的接口替换成成IP其实很简单，URL是字符串，域名替换IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云(没开源)，七牛云(开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个SDK，传个普通的URL进去就会返回一个域名被替换成IP的URL出来，也比较好用，这里要说一下IP地址的来源，如何拿到一个域名所对应的IP呢？这里就是需要用到另一个服务——HTTPDNS，国内比较有名的就是DNSPOD，包括阿里，七牛等也是使用他们的DNS服务来解析，就是这个</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg\" alt=\"DNSPOD logo\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg\" alt=\"简介\"></p>\n<p>他会给我们提供一个接口，我们使用HTTP请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的IP列表返回回来。类似这样：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *url = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:url] cachePolicy:<span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class=\"literal\">nil</span> error:&amp;networkError];</span><br></pre></td></tr></table></figure></p>\n<p>这里使用同步还是异步都是可以的，具体根据你们业务需求。</p>\n<h6 id=\"5-2：项目中的使用\"><a href=\"#5-2：项目中的使用\" class=\"headerlink\" title=\"5.2：项目中的使用\"></a>5.2：项目中的使用</h6><p> <br>其实dnspod最难的部分是接入的部分，因为不同的APP不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把DNS解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到APP所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的APP中加入DNS防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是NSURLProtocol + Runtime hook方式来处理这些东西的，NSURLProtocol属于iOS黑魔法的一种可以拦截任何从APP的 URL Loading System系统中发出的请求，其中包括如下</p>\n<ul>\n<li>File Transfer Protocol (ftp://)</li>\n<li>Hypertext Transfer Protocol (http://)</li>\n<li>Hypertext Transfer Protocol with encryption (https://)</li>\n<li>Local file URLs (file:///)</li>\n<li>Data URLs (data://)</li>\n</ul>\n<p>如果你的请求不在以上列表中就不能进行拦截了，比如WKWebview，AVPlayer(比较特殊，虽然请求也是http/https但是就是不走这套系统，苹果爸爸就是这样~)等，其实对于正常来说光用已经NSURLProtocol足够了。<br>  NSURLProtocol这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样<br>  <figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure></p>\n<p>在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"BOOL-canInitWithRequest-NSURLRequest-request\"><a href=\"#BOOL-canInitWithRequest-NSURLRequest-request\" class=\"headerlink\" title=\"+ (BOOL)canInitWithRequest:(NSURLRequest *)request;\"></a>+ (BOOL)canInitWithRequest:(NSURLRequest *)request;</h6><p>通过返回值来告诉NSUrlProtocol对进来的请求是否拦截，比如我只拦截HTTP的，或者是某个域名的请求之类</p>\n<h6 id=\"NSURLRequest-canonicalRequestForRequest-NSURLRequest-request\"><a href=\"#NSURLRequest-canonicalRequestForRequest-NSURLRequest-request\" class=\"headerlink\" title=\"+ (NSURLRequest )canonicalRequestForRequest:(NSURLRequest )request;\"></a>+ (NSURLRequest <em>)canonicalRequestForRequest:(NSURLRequest </em>)request;</h6><p>如果上面的方法返回YES那么request会传到这里，这个地方通常不做处理 直接返回request</p>\n<h6 id=\"void-startLoading\"><a href=\"#void-startLoading\" class=\"headerlink\" title=\"- (void)startLoading;\"></a>- (void)startLoading;</h6><p>这个地方就是对我们拦截的请求做一些处理，我们文中所做的IP对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startLoading &#123;</span><br><span class=\"line\"><span class=\"comment\">///其中customRequest是处理过的请求(域名替换后的)</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:[[<span class=\"built_in\">NSURLSessionConfiguration</span> alloc] init] delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:customRequest];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：<br><figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">URLSession</span><span class=\"selector-pseudo\">:(NSURLSession</span> *)<span class=\"selector-tag\">session</span> <span class=\"selector-tag\">dataTask</span><span class=\"selector-pseudo\">:(NSURLSessionDataTask</span> *)<span class=\"selector-tag\">dataTask</span> <span class=\"selector-tag\">didReceiveResponse</span><span class=\"selector-pseudo\">:(NSURLResponse</span> *)<span class=\"selector-tag\">response</span> <span class=\"selector-tag\">completionHandler</span><span class=\"selector-pseudo\">:(void</span> (^)(NSURLSessionResponseDisposition))<span class=\"selector-tag\">completionHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[[self client]</span> <span class=\"selector-tag\">URLProtocol</span><span class=\"selector-pseudo\">:self</span> <span class=\"selector-tag\">didReceiveResponse</span><span class=\"selector-pseudo\">:response</span> <span class=\"selector-tag\">cacheStoragePolicy</span><span class=\"selector-pseudo\">:NSURLCacheStorageAllowed</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-tag\">completionHandler</span>(NSURLSessionResponseAllow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">URLSession</span><span class=\"selector-pseudo\">:(NSURLSession</span> *)<span class=\"selector-tag\">session</span> <span class=\"selector-tag\">dataTask</span><span class=\"selector-pseudo\">:(NSURLSessionDataTask</span> *)<span class=\"selector-tag\">dataTask</span> <span class=\"selector-tag\">didReceiveData</span><span class=\"selector-pseudo\">:(NSData</span> *)<span class=\"selector-tag\">data</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[[self client]</span> <span class=\"selector-tag\">URLProtocol</span><span class=\"selector-pseudo\">:self</span> <span class=\"selector-tag\">didLoadData</span><span class=\"selector-pseudo\">:data</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>client在后面会有讲解。</p>\n<h6 id=\"void-stopLoading\"><a href=\"#void-stopLoading\" class=\"headerlink\" title=\"- (void)stopLoading;\"></a>- (void)stopLoading;</h6><p>请求完毕后调用<br>大概的执行流程是这样</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg\" alt=\"流程\"></p>\n<p>在NSURLProtocol中有一个贯穿始终的变量<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">    @method client</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract Returns the NSURLProtocolClient of the receiver.</span></span><br><span class=\"line\"><span class=\"comment\">    @result The NSURLProtocolClient of the receiver.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt; client;</span><br></pre></td></tr></table></figure></p>\n<p>你可以认为是这个是请求的发送者，打个比方，A想给B发送一个消息，由于距离遥远于是A去了邮局，A把消息内容告诉了邮局，并且A在邮局登记了自己名字方便B有反馈的时候邮局来通知A查收。这个例子中邮局就是NSURLProtocol，A在邮局登记的名字就是client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：<br><figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">@protocol NSURLProtocolClient &lt;NSObject&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didReceiveResponse:<span class=\"params\">(NSURLResponse *)</span>response cacheStoragePolicy:<span class=\"params\">(NSURLCacheStoragePolicy)</span>policy;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didLoadData:<span class=\"params\">(NSData *)</span>data;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocolDidFinishLoading:<span class=\"params\">(NSURLProtocol *)</span>protocol;</span><br><span class=\"line\">...</span><br><span class=\"line\">@<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。<br>到此正常情况下的DNS的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的URL的就会变成<a href=\"http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧\" target=\"_blank\" rel=\"noopener\">http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧</a>)</p>\n<h5 id=\"6：遇到的坑点\"><a href=\"#6：遇到的坑点\" class=\"headerlink\" title=\"6：遇到的坑点\"></a>6：遇到的坑点</h5><h6 id=\"6-1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\"><a href=\"#6-1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\" class=\"headerlink\" title=\"6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\"></a>6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。</h6><figure class=\"highlight pf\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"built_in\">set</span>Value:<span class=\"literal\">self</span>.request.URL.host <span class=\"keyword\">for</span>HTTPHeaderField:@<span class=\"string\">\"HOST\"</span>];</span><br></pre></td></tr></table></figure>\n<h6 id=\"加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\"><a href=\"#加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\" class=\"headerlink\" title=\"加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\"></a>加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中</h6><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"string\">setValue:</span>YOUR Cookie <span class=\"string\">forHTTPHeaderField:</span>@<span class=\"string\">\"Cookie\"</span>];</span><br></pre></td></tr></table></figure>\n<h6 id=\"6-2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\"><a href=\"#6-2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\" class=\"headerlink\" title=\"6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\"></a>6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure>\n<h6 id=\"在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\"><a href=\"#在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\" class=\"headerlink\" title=\"在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\"></a>在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。</h6><figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager * sessionManager = [AFHTTPSessionManager manager]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\"><a href=\"#我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\" class=\"headerlink\" title=\"我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\"></a>我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!configuration) &#123;</span><br><span class=\"line\">        configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime-hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook-NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\"><a href=\"#大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime-hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook-NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\" class=\"headerlink\" title=\"大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\"></a>大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)swizzle_sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *newConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"comment\">// 在现有的Configuration中插入我们自定义的protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuration) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_sessionWithConfiguration:newConfiguration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"然后就完美解决了。不过要注意下系统的是有两个方法的\"><a href=\"#然后就完美解决了。不过要注意下系统的是有两个方法的\" class=\"headerlink\" title=\"然后就完美解决了。不过要注意下系统的是有两个方法的\"></a>然后就完美解决了。不过要注意下系统的是有两个方法的</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you only need to use the convenience routines with custom</span></span><br><span class=\"line\"><span class=\"comment\"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class=\"line\"><span class=\"comment\"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>\n<h6 id=\"这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\"><a href=\"#这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\" class=\"headerlink\" title=\"这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\"></a>这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的</h6><h6 id=\"6-3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http-https-file……请求这个概念，但是AVPlayer所有的请求都不会走URL-Loading-System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\"><a href=\"#6-3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http-https-file……请求这个概念，但是AVPlayer所有的请求都不会走URL-Loading-System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\" class=\"headerlink\" title=\"6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\"></a>6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：</h6><figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\">  @method\t\tinitWithURL:options:</span><br><span class=\"line\">  @abstract\t\tInitializes an<span class=\"built_in\"> instance </span>of AVURLAsset for inspection of a media resource.</span><br><span class=\"line\">  @param\t\tURL</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSURL that references a media resource.</span><br><span class=\"line\">  @param\t\toptions</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey<span class=\"built_in\"> and </span>AVURLAssetReferenceRestrictionsKey above.</span><br><span class=\"line\">  @result\t\tAn<span class=\"built_in\"> instance </span>of AVURLAsset.</span><br><span class=\"line\">*/</span><br><span class=\"line\">- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIA<span class=\"class\">LIZER;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\"><a href=\"#其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\" class=\"headerlink\" title=\"其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\"></a>其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetPreferPreciseDurationAndTimingKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">4</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetReferenceRestrictionsKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetHTTPCookiesKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetAllowsCellularAccessKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">10</span>_0);</span><br></pre></td></tr></table></figure>\n<h6 id=\"但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\"><a href=\"#但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\" class=\"headerlink\" title=\"但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\"></a>但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是</h6><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">[self swizzle_initWithURL:videoURL options:@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@<span class=\"string\">\"Host\"</span><span class=\"symbol\">:host</span>&#125;&#125;]</span><br></pre></td></tr></table></figure>\n<h6 id=\"这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\"><a href=\"#这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\" class=\"headerlink\" title=\"这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\"></a>这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加密后的KEY</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> * headerKey = <span class=\"string\">@\"35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F\"</span>;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"comment\">//getRequestHeaderKey方法为解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_initWithURL:videoURL options:@&#123;[<span class=\"keyword\">self</span> getRequestHeaderKey] : @&#123;<span class=\"string\">@\"Host\"</span>:host&#125;&#125;];</span><br></pre></td></tr></table></figure>\n<h6 id=\"这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\"><a href=\"#这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\" class=\"headerlink\" title=\"这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\"></a>这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，</h6><h6 id=\"6-4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request-timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\"><a href=\"#6-4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request-timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\" class=\"headerlink\" title=\"6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\"></a>6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@\"POST\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"keyword\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\"><a href=\"#这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\" class=\"headerlink\" title=\"这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\"></a>这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。</h6><h6 id=\"6-5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL-Loading-System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\"><a href=\"#6-5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL-Loading-System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\" class=\"headerlink\" title=\"6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\"></a>6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。</h6><h6 id=\"6-6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server-Name-Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\"><a href=\"#6-6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server-Name-Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\" class=\"headerlink\" title=\"6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\"></a>6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，<strong><a href=\"https://help.aliyun.com/document_detail/30143.html\" target=\"_blank\" rel=\"noopener\">阿里云文档</a></strong>有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：</h6><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg\" alt=\"阿里云文档截图\"></p>\n<h6 id=\"三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI-https-环境服务-所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\"><a href=\"#三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI-https-环境服务-所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\" class=\"headerlink\" title=\"三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\"></a>三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我<strong><a href=\"https://github.com/Dave1991/alicloud-ios-demo/blob/master/httpdns_ios_demo/httpdns_ios_demo/CFHttpMessageURLProtocol.m\" target=\"_blank\" rel=\"noopener\">主要的参考资料</a></strong>发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.request.URL.scheme isEqualToString:<span class=\"string\">@\"https\"</span>] ) &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用CFnetwork</span></span><br><span class=\"line\">        curRequest = req;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task = [[CustomCFNetworkRequestTask alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.task) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.task startLoading];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用普通网络请求</span></span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue]];</span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionTask</span> *task = [<span class=\"keyword\">self</span>.session dataTaskWithRequest:req];</span><br><span class=\"line\">        [task resume];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"我是这么做的。\"><a href=\"#我是这么做的。\" class=\"headerlink\" title=\"我是这么做的。\"></a>我是这么做的。</h6><h6 id=\"6-7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\"><a href=\"#6-7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\" class=\"headerlink\" title=\"6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\"></a>6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。</h6><h5 id=\"7：总结\"><a href=\"#7：总结\" class=\"headerlink\" title=\"7：总结\"></a>7：总结</h5><p>  完成了以上的步骤之后你回发现在DNS坏掉的情况下手机里面除了微信QQ(他们也做了DNS解析)之外其他应用都不能上网了但是你的App依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"科普片\"><a href=\"#科普片\" class=\"headerlink\" title=\"科普片\"></a>科普片</h1><h5 id=\"1、DNS劫持的危害\"><a href=\"#1、DNS劫持的危害\" class=\"headerlink\" title=\"1、DNS劫持的危害\"></a>1、DNS劫持的危害</h5><p>  不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇(se)怪(qing)的东西</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6jm5b190j30h60ugqkg.jpg\" alt=\"图一\"></p>\n<p>或者这样<br>","more":"</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6jmr1afuj30ww0ue4qp.jpg\" alt=\"图二\">，</p>\n<p>其实造成这样的原因就是DNS劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。</p>\n<h5 id=\"2、什么是DNS解析\"><a href=\"#2、什么是DNS解析\" class=\"headerlink\" title=\"2、什么是DNS解析\"></a>2、什么是DNS解析</h5><p>  现在假如我们访问一个网站www.baidu.com从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤</p>\n<ul>\n<li>1：计算机会向我们的运营商(移动、电信、联通等)发出打开www.baidu.com的请求。</li>\n<li>2：运营商收到请求后会到自己的DNS服务器中找www.baidu.com这个域名所对应的服务器的IP地址(也就是百度的服务器的IP地址)，这里比如是180.149.132.47。</li>\n<li>3：运营商用第二步得到的IP地址去找到百度的服务器请求得到数据后返回给我们。</li>\n</ul>\n<p>其中第二步就是我们所说的DNS解析过程，域名和IP地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是IP地址\\身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在IP上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是IP的，所以DNS解析就应运而生了。</p>\n<h5 id=\"3：什么是DNS劫持\"><a href=\"#3：什么是DNS劫持\" class=\"headerlink\" title=\"3：什么是DNS劫持\"></a>3：什么是DNS劫持</h5><p>DNS劫持，是指在DNS解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点：</p>\n<ul>\n<li>1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。</li>\n<li>2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</li>\n</ul>\n<h5 id=\"4：防止DNS劫持\"><a href=\"#4：防止DNS劫持\" class=\"headerlink\" title=\"4：防止DNS劫持\"></a>4：防止DNS劫持</h5><p>  了解了DNS劫持的相关资料后我们就知道了，防止NDS劫持就要从第二步入手，因为DNS解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，将我们原本的请求链接www.baidu.com 修改为180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是IP地址就会直接给我们放行，而不会去走他自己DNS解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的DNS解析也就不会存在DNS被劫持的问题，从根本是解决了。</p>\n<h1 id=\"技术篇\"><a href=\"#技术篇\" class=\"headerlink\" title=\"技术篇\"></a>技术篇</h1><h5 id=\"5：项目中的实际操作\"><a href=\"#5：项目中的实际操作\" class=\"headerlink\" title=\"5：项目中的实际操作\"></a>5：项目中的实际操作</h5><h6 id=\"5-1：DNSPOD相关\"><a href=\"#5-1：DNSPOD相关\" class=\"headerlink\" title=\"5.1：DNSPOD相关\"></a>5.1：DNSPOD相关</h6><p>  我们知道要要把项目中请求的接口替换成成IP其实很简单，URL是字符串，域名替换IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云(没开源)，七牛云(开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个SDK，传个普通的URL进去就会返回一个域名被替换成IP的URL出来，也比较好用，这里要说一下IP地址的来源，如何拿到一个域名所对应的IP呢？这里就是需要用到另一个服务——HTTPDNS，国内比较有名的就是DNSPOD，包括阿里，七牛等也是使用他们的DNS服务来解析，就是这个</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6jnbe2zhj30sa0i8dwv.jpg\" alt=\"DNSPOD logo\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6jnt2uw9j31kw0icava.jpg\" alt=\"简介\"></p>\n<p>他会给我们提供一个接口，我们使用HTTP请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的IP列表返回回来。类似这样：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEY</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *url = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> * request = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:url] cachePolicy:<span class=\"built_in\">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSData</span> * data = [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class=\"literal\">nil</span> error:&amp;networkError];</span><br></pre></td></tr></table></figure></p>\n<p>这里使用同步还是异步都是可以的，具体根据你们业务需求。</p>\n<h6 id=\"5-2：项目中的使用\"><a href=\"#5-2：项目中的使用\" class=\"headerlink\" title=\"5.2：项目中的使用\"></a>5.2：项目中的使用</h6><p> <br>其实dnspod最难的部分是接入的部分，因为不同的APP不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把DNS解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到APP所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的APP中加入DNS防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是NSURLProtocol + Runtime hook方式来处理这些东西的，NSURLProtocol属于iOS黑魔法的一种可以拦截任何从APP的 URL Loading System系统中发出的请求，其中包括如下</p>\n<ul>\n<li>File Transfer Protocol (ftp://)</li>\n<li>Hypertext Transfer Protocol (http://)</li>\n<li>Hypertext Transfer Protocol with encryption (https://)</li>\n<li>Local file URLs (file:///)</li>\n<li>Data URLs (data://)</li>\n</ul>\n<p>如果你的请求不在以上列表中就不能进行拦截了，比如WKWebview，AVPlayer(比较特殊，虽然请求也是http/https但是就是不走这套系统，苹果爸爸就是这样~)等，其实对于正常来说光用已经NSURLProtocol足够了。<br>  NSURLProtocol这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样<br>  <figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure></p>\n<p>在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)canInitWithRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLRequest</span> *)canonicalRequestForRequest:(<span class=\"built_in\">NSURLRequest</span> *)request;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startLoading;</span><br><span class=\"line\"><span class=\"comment\">//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stopLoading;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"BOOL-canInitWithRequest-NSURLRequest-request\"><a href=\"#BOOL-canInitWithRequest-NSURLRequest-request\" class=\"headerlink\" title=\"+ (BOOL)canInitWithRequest:(NSURLRequest *)request;\"></a>+ (BOOL)canInitWithRequest:(NSURLRequest *)request;</h6><p>通过返回值来告诉NSUrlProtocol对进来的请求是否拦截，比如我只拦截HTTP的，或者是某个域名的请求之类</p>\n<h6 id=\"NSURLRequest-canonicalRequestForRequest-NSURLRequest-request\"><a href=\"#NSURLRequest-canonicalRequestForRequest-NSURLRequest-request\" class=\"headerlink\" title=\"+ (NSURLRequest )canonicalRequestForRequest:(NSURLRequest )request;\"></a>+ (NSURLRequest <em>)canonicalRequestForRequest:(NSURLRequest </em>)request;</h6><p>如果上面的方法返回YES那么request会传到这里，这个地方通常不做处理 直接返回request</p>\n<h6 id=\"void-startLoading\"><a href=\"#void-startLoading\" class=\"headerlink\" title=\"- (void)startLoading;\"></a>- (void)startLoading;</h6><p>这个地方就是对我们拦截的请求做一些处理，我们文中所做的IP对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startLoading &#123;</span><br><span class=\"line\"><span class=\"comment\">///其中customRequest是处理过的请求(域名替换后的)</span></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> *session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:[[<span class=\"built_in\">NSURLSessionConfiguration</span> alloc] init] delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:customRequest];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：<br><figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">URLSession</span><span class=\"selector-pseudo\">:(NSURLSession</span> *)<span class=\"selector-tag\">session</span> <span class=\"selector-tag\">dataTask</span><span class=\"selector-pseudo\">:(NSURLSessionDataTask</span> *)<span class=\"selector-tag\">dataTask</span> <span class=\"selector-tag\">didReceiveResponse</span><span class=\"selector-pseudo\">:(NSURLResponse</span> *)<span class=\"selector-tag\">response</span> <span class=\"selector-tag\">completionHandler</span><span class=\"selector-pseudo\">:(void</span> (^)(NSURLSessionResponseDisposition))<span class=\"selector-tag\">completionHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[[self client]</span> <span class=\"selector-tag\">URLProtocol</span><span class=\"selector-pseudo\">:self</span> <span class=\"selector-tag\">didReceiveResponse</span><span class=\"selector-pseudo\">:response</span> <span class=\"selector-tag\">cacheStoragePolicy</span><span class=\"selector-pseudo\">:NSURLCacheStorageAllowed</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-tag\">completionHandler</span>(NSURLSessionResponseAllow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">URLSession</span><span class=\"selector-pseudo\">:(NSURLSession</span> *)<span class=\"selector-tag\">session</span> <span class=\"selector-tag\">dataTask</span><span class=\"selector-pseudo\">:(NSURLSessionDataTask</span> *)<span class=\"selector-tag\">dataTask</span> <span class=\"selector-tag\">didReceiveData</span><span class=\"selector-pseudo\">:(NSData</span> *)<span class=\"selector-tag\">data</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[[self client]</span> <span class=\"selector-tag\">URLProtocol</span><span class=\"selector-pseudo\">:self</span> <span class=\"selector-tag\">didLoadData</span><span class=\"selector-pseudo\">:data</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>client在后面会有讲解。</p>\n<h6 id=\"void-stopLoading\"><a href=\"#void-stopLoading\" class=\"headerlink\" title=\"- (void)stopLoading;\"></a>- (void)stopLoading;</h6><p>请求完毕后调用<br>大概的执行流程是这样</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6jtpp3z0j30ze1by122.jpg\" alt=\"流程\"></p>\n<p>在NSURLProtocol中有一个贯穿始终的变量<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">    @method client</span></span><br><span class=\"line\"><span class=\"comment\">    @abstract Returns the NSURLProtocolClient of the receiver.</span></span><br><span class=\"line\"><span class=\"comment\">    @result The NSURLProtocolClient of the receiver.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">readonly</span>, <span class=\"keyword\">retain</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSURLProtocolClient</span>&gt; client;</span><br></pre></td></tr></table></figure></p>\n<p>你可以认为是这个是请求的发送者，打个比方，A想给B发送一个消息，由于距离遥远于是A去了邮局，A把消息内容告诉了邮局，并且A在邮局登记了自己名字方便B有反馈的时候邮局来通知A查收。这个例子中邮局就是NSURLProtocol，A在邮局登记的名字就是client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：<br><figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">@protocol NSURLProtocolClient &lt;NSObject&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didReceiveResponse:<span class=\"params\">(NSURLResponse *)</span>response cacheStoragePolicy:<span class=\"params\">(NSURLCacheStoragePolicy)</span>policy;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocol:<span class=\"params\">(NSURLProtocol *)</span>protocol didLoadData:<span class=\"params\">(NSData *)</span>data;</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"params\">(void)</span>URLProtocolDidFinishLoading:<span class=\"params\">(NSURLProtocol *)</span>protocol;</span><br><span class=\"line\">...</span><br><span class=\"line\">@<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。<br>到此正常情况下的DNS的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的URL的就会变成<a href=\"http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧\" target=\"_blank\" rel=\"noopener\">http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧</a>)</p>\n<h5 id=\"6：遇到的坑点\"><a href=\"#6：遇到的坑点\" class=\"headerlink\" title=\"6：遇到的坑点\"></a>6：遇到的坑点</h5><h6 id=\"6-1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\"><a href=\"#6-1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\" class=\"headerlink\" title=\"6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。\"></a>6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。</h6><figure class=\"highlight pf\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"built_in\">set</span>Value:<span class=\"literal\">self</span>.request.URL.host <span class=\"keyword\">for</span>HTTPHeaderField:@<span class=\"string\">\"HOST\"</span>];</span><br></pre></td></tr></table></figure>\n<h6 id=\"加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\"><a href=\"#加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\" class=\"headerlink\" title=\"加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中\"></a>加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中</h6><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mutableRequest <span class=\"string\">setValue:</span>YOUR Cookie <span class=\"string\">forHTTPHeaderField:</span>@<span class=\"string\">\"Cookie\"</span>];</span><br></pre></td></tr></table></figure>\n<h6 id=\"6-2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\"><a href=\"#6-2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\" class=\"headerlink\" title=\"6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样\"></a>6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 注册自定义protocol</span></span><br><span class=\"line\">[<span class=\"built_in\">NSURLProtocol</span> registerClass:[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br><span class=\"line\"> <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">configuration.protocolClasses = @[[CustomURLProtocol <span class=\"keyword\">class</span>]];</span><br></pre></td></tr></table></figure>\n<h6 id=\"在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\"><a href=\"#在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\" class=\"headerlink\" title=\"在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。\"></a>在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。</h6><figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager * sessionManager = [AFHTTPSessionManager manager]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\"><a href=\"#我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\" class=\"headerlink\" title=\"我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法\"></a>我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithSessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!configuration) &#123;</span><br><span class=\"line\">        configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.sessionConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.operationQueue.maxConcurrentOperationCount = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:<span class=\"keyword\">self</span>.sessionConfiguration delegate:<span class=\"keyword\">self</span> delegateQueue:<span class=\"keyword\">self</span>.operationQueue];</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime-hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook-NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\"><a href=\"#大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime-hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook-NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\" class=\"headerlink\" title=\"大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样\"></a>大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)swizzle_sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSURLSessionConfiguration</span> *newConfiguration = configuration;</span><br><span class=\"line\">    <span class=\"comment\">// 在现有的Configuration中插入我们自定义的protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuration) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newConfiguration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *protocolArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:configuration.protocolClasses];</span><br><span class=\"line\">        [protocolArray insertObject:[CustomProtocol <span class=\"keyword\">class</span>] atIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        newConfiguration.protocolClasses = protocolArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_sessionWithConfiguration:newConfiguration];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"然后就完美解决了。不过要注意下系统的是有两个方法的\"><a href=\"#然后就完美解决了。不过要注意下系统的是有两个方法的\" class=\"headerlink\" title=\"然后就完美解决了。不过要注意下系统的是有两个方法的\"></a>然后就完美解决了。不过要注意下系统的是有两个方法的</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you only need to use the convenience routines with custom</span></span><br><span class=\"line\"><span class=\"comment\"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class=\"line\"><span class=\"comment\"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSURLSession</span> *)sessionWithConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration delegate:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>\n<h6 id=\"这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\"><a href=\"#这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\" class=\"headerlink\" title=\"这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的\"></a>这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的</h6><h6 id=\"6-3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http-https-file……请求这个概念，但是AVPlayer所有的请求都不会走URL-Loading-System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\"><a href=\"#6-3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http-https-file……请求这个概念，但是AVPlayer所有的请求都不会走URL-Loading-System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\" class=\"headerlink\" title=\"6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：\"></a>6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：</h6><figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\">  @method\t\tinitWithURL:options:</span><br><span class=\"line\">  @abstract\t\tInitializes an<span class=\"built_in\"> instance </span>of AVURLAsset for inspection of a media resource.</span><br><span class=\"line\">  @param\t\tURL</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSURL that references a media resource.</span><br><span class=\"line\">  @param\t\toptions</span><br><span class=\"line\">\t\t\t\tAn<span class=\"built_in\"> instance </span>of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey<span class=\"built_in\"> and </span>AVURLAssetReferenceRestrictionsKey above.</span><br><span class=\"line\">  @result\t\tAn<span class=\"built_in\"> instance </span>of AVURLAsset.</span><br><span class=\"line\">*/</span><br><span class=\"line\">- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIA<span class=\"class\">LIZER;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\"><a href=\"#其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\" class=\"headerlink\" title=\"其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key\"></a>其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个Key</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetPreferPreciseDurationAndTimingKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">4</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetReferenceRestrictionsKey</span> <span class=\"built_in\">NS_AVAILABLE</span>(<span class=\"number\">10</span>_7, <span class=\"number\">5</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetHTTPCookiesKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0);</span><br><span class=\"line\"><span class=\"built_in\">AVF_EXPORT</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">AVURLAssetAllowsCellularAccessKey</span> <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">10</span>_0);</span><br></pre></td></tr></table></figure>\n<h6 id=\"但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\"><a href=\"#但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\" class=\"headerlink\" title=\"但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是\"></a>但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是</h6><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">[self swizzle_initWithURL:videoURL options:@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@<span class=\"string\">\"Host\"</span><span class=\"symbol\">:host</span>&#125;&#125;]</span><br></pre></td></tr></table></figure>\n<h6 id=\"这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\"><a href=\"#这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\" class=\"headerlink\" title=\"这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：\"></a>这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加密后的KEY</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">NSString</span> * headerKey = <span class=\"string\">@\"35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F\"</span>;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"comment\">//getRequestHeaderKey方法为解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> swizzle_initWithURL:videoURL options:@&#123;[<span class=\"keyword\">self</span> getRequestHeaderKey] : @&#123;<span class=\"string\">@\"Host\"</span>:host&#125;&#125;];</span><br></pre></td></tr></table></figure>\n<h6 id=\"这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\"><a href=\"#这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\" class=\"headerlink\" title=\"这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，\"></a>这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，</h6><h6 id=\"6-4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request-timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\"><a href=\"#6-4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request-timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\" class=\"headerlink\" title=\"6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下\"></a>6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark -</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class=\"built_in\">NSMutableURLRequest</span> *)request &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableURLRequest</span> * req = [request mutableCopy];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([request.HTTPMethod isEqualToString:<span class=\"string\">@\"POST\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!request.HTTPBody) &#123;</span><br><span class=\"line\">            uint8_t d[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">            <span class=\"built_in\">NSInputStream</span> *stream = request.HTTPBodyStream;</span><br><span class=\"line\">            <span class=\"built_in\">NSMutableData</span> *data = [[<span class=\"built_in\">NSMutableData</span> alloc] init];</span><br><span class=\"line\">            [stream open];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSInteger</span> len = [stream read:d maxLength:<span class=\"number\">1024</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len &gt; <span class=\"number\">0</span> &amp;&amp; stream.streamError == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">                    [data appendBytes:(<span class=\"keyword\">void</span> *)d length:len];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            req.HTTPBody = [data <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">            [stream close];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\"><a href=\"#这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\" class=\"headerlink\" title=\"这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。\"></a>这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。</h6><h6 id=\"6-5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL-Loading-System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\"><a href=\"#6-5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL-Loading-System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\" class=\"headerlink\" title=\"6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。\"></a>6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。</h6><h6 id=\"6-6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server-Name-Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\"><a href=\"#6-6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server-Name-Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\" class=\"headerlink\" title=\"6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：\"></a>6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，<strong><a href=\"https://help.aliyun.com/document_detail/30143.html\" target=\"_blank\" rel=\"noopener\">阿里云文档</a></strong>有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了：</h6><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6juzsqdqj31kw0bbn5v.jpg\" alt=\"阿里云文档截图\"></p>\n<h6 id=\"三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI-https-环境服务-所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\"><a href=\"#三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI-https-环境服务-所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\" class=\"headerlink\" title=\"三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，\"></a>三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我<strong><a href=\"https://github.com/Dave1991/alicloud-ios-demo/blob/master/httpdns_ios_demo/httpdns_ios_demo/CFHttpMessageURLProtocol.m\" target=\"_blank\" rel=\"noopener\">主要的参考资料</a></strong>发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发，</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.request.URL.scheme isEqualToString:<span class=\"string\">@\"https\"</span>] ) &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用CFnetwork</span></span><br><span class=\"line\">        curRequest = req;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.task = [[CustomCFNetworkRequestTask alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.task) &#123;</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.task startLoading];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//使用普通网络请求</span></span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionConfiguration</span> *configuration = [<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.session = [<span class=\"built_in\">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class=\"keyword\">self</span> delegateQueue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue]];</span><br><span class=\"line\">        <span class=\"built_in\">NSURLSessionTask</span> *task = [<span class=\"keyword\">self</span>.session dataTaskWithRequest:req];</span><br><span class=\"line\">        [task resume];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"我是这么做的。\"><a href=\"#我是这么做的。\" class=\"headerlink\" title=\"我是这么做的。\"></a>我是这么做的。</h6><h6 id=\"6-7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\"><a href=\"#6-7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\" class=\"headerlink\" title=\"6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。\"></a>6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。</h6><h5 id=\"7：总结\"><a href=\"#7：总结\" class=\"headerlink\" title=\"7：总结\"></a>7：总结</h5><p>  完成了以上的步骤之后你回发现在DNS坏掉的情况下手机里面除了微信QQ(他们也做了DNS解析)之外其他应用都不能上网了但是你的App依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧</p>"},{"title":"自定义AlertView","date":"2018-01-24T04:37:20.000Z","comments":1,"_content":"# CustomAlertView\n一个自定义的AlertView，用户可以根据自己的需求来设置。\n## 使用方法\n\n![初始化方法](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg)\n\n类似于系统的初始化方法，如果没有值的话就传nil就好，不要传空字符串。最后一个参数传title数组就好了。\n\n![使用](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg)\n\n然后调用showInViewWithAction方法显示出来\n<!--more-->\n\n![显示](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg)\n\n最后一个参数是button的点击事件，根据tag值来区分不同的button点击，只有取消button的tag是0，其他的是1.2.3...依次往下排列就好\n\n![可自定义的一些属性](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg)\n\n这些属性可以自定义，这里就不细说了，大家可以使试试。\n\n## 样式截图\n\n![样式截图](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg)\n\n![使用截图](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif)\n\n大概就这么多，很简单的有问题随时联系我吧。\n","source":"_posts/2018-01-24-自定义AlertView.md","raw":"---\ntitle: 自定义AlertView\ncategories: iOS开发\ndate: 2018-01-24 12:37:20\ntags:\n  - UI\n  - AlertView\ncomments:\n---\n# CustomAlertView\n一个自定义的AlertView，用户可以根据自己的需求来设置。\n## 使用方法\n\n![初始化方法](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg)\n\n类似于系统的初始化方法，如果没有值的话就传nil就好，不要传空字符串。最后一个参数传title数组就好了。\n\n![使用](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg)\n\n然后调用showInViewWithAction方法显示出来\n<!--more-->\n\n![显示](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg)\n\n最后一个参数是button的点击事件，根据tag值来区分不同的button点击，只有取消button的tag是0，其他的是1.2.3...依次往下排列就好\n\n![可自定义的一些属性](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg)\n\n这些属性可以自定义，这里就不细说了，大家可以使试试。\n\n## 样式截图\n\n![样式截图](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg)\n\n![使用截图](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif)\n\n大概就这么多，很简单的有问题随时联系我吧。\n","slug":"自定义AlertView","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2l8000ya04wfumpaerw","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"CustomAlertView\"><a href=\"#CustomAlertView\" class=\"headerlink\" title=\"CustomAlertView\"></a>CustomAlertView</h1><p>一个自定义的AlertView，用户可以根据自己的需求来设置。</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg\" alt=\"初始化方法\"></p>\n<p>类似于系统的初始化方法，如果没有值的话就传nil就好，不要传空字符串。最后一个参数传title数组就好了。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg\" alt=\"使用\"></p>\n<p>然后调用showInViewWithAction方法显示出来<br><a id=\"more\"></a></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg\" alt=\"显示\"></p>\n<p>最后一个参数是button的点击事件，根据tag值来区分不同的button点击，只有取消button的tag是0，其他的是1.2.3…依次往下排列就好</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg\" alt=\"可自定义的一些属性\"></p>\n<p>这些属性可以自定义，这里就不细说了，大家可以使试试。</p>\n<h2 id=\"样式截图\"><a href=\"#样式截图\" class=\"headerlink\" title=\"样式截图\"></a>样式截图</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg\" alt=\"样式截图\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif\" alt=\"使用截图\"></p>\n<p>大概就这么多，很简单的有问题随时联系我吧。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"CustomAlertView\"><a href=\"#CustomAlertView\" class=\"headerlink\" title=\"CustomAlertView\"></a>CustomAlertView</h1><p>一个自定义的AlertView，用户可以根据自己的需求来设置。</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k50sh34j30hy084abf.jpg\" alt=\"初始化方法\"></p>\n<p>类似于系统的初始化方法，如果没有值的话就传nil就好，不要传空字符串。最后一个参数传title数组就好了。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5axspej30r702rmy0.jpg\" alt=\"使用\"></p>\n<p>然后调用showInViewWithAction方法显示出来<br>","more":"</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5idk8ij30mp041aai.jpg\" alt=\"显示\"></p>\n<p>最后一个参数是button的点击事件，根据tag值来区分不同的button点击，只有取消button的tag是0，其他的是1.2.3…依次往下排列就好</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k5q4o6nj30kr0ox78u.jpg\" alt=\"可自定义的一些属性\"></p>\n<p>这些属性可以自定义，这里就不细说了，大家可以使试试。</p>\n<h2 id=\"样式截图\"><a href=\"#样式截图\" class=\"headerlink\" title=\"样式截图\"></a>样式截图</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k5zfyi2j30dc0notac.jpg\" alt=\"样式截图\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k66fmogg308o0figvd.gif\" alt=\"使用截图\"></p>\n<p>大概就这么多，很简单的有问题随时联系我吧。</p>"},{"title":"在iOS工程中Cocoapods的使用","date":"2018-01-24T04:42:28.000Z","comments":1,"_content":"我们在开发iOS程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程(比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到cocoapods来管理我们的第三方了，在我们有了CocoaPods这个工具之后，只需要将用到的第三方开源库放到一个名为Podfile的文件中，\n<!--more-->\n然后在命令行执行$ pod install命令。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。\n### 第一步 ：\n首先安装cocoapods要在ruby环境下进行，虽然我们的mac系统都是自带了ruby，但是为了保险起见我们还是要先更新一下ruby环境：在这里我们直接使用   sudo gem update --system   命令来更新，网上有的说使用 gem update --system 前面少了sudo，其实加sudo的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6jyxwn6cj30ta06kn1a.jpg)\n\n意思是你没有权限去执行这个命令，等出现了RubyGems system software updated 这句话的时候就证明升级成功了。\n\n### 第二步：\n安装cocoapods时候我们要访问cocoapods.org这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的ruby的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6jzdqmrlj30ma03ydjy.jpg)\n\n也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用gem sources --remove XXXXXXXXXXXXXXX 来把其他的source删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a https://ruby.taobao.org/ 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https  网上好多教程写的是 http，那个已经作废了\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6jzxkmf5j31kw0ask74.jpg)\n### 第三步：\n安装是cocoapods 使用 sudo gem install cocoapods 命令来安装cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。\n### 第四步：\n使用search命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找afnetworking 我就输入 pod search afn 回车后就会输出所有以afn开头的类库名字，像这样\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k0kkcjjj311u0wq4qp.jpg)\n\n搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑podfile时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的version是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。\n###### 值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json\n\n### 第五步：\n进入你的工程目录，这里建议直接右键你工程中.xcodeproj文件选择在终端中打开，然后 在终端中输入命令cd ..  就会跳到.xcodeproj所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile熟悉Linux的用户都知道这是创建一个Podfile文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作esc键  ->  \":\"  ->  输入wq\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k16wn0yj311s0wqth2.jpg)\n\n然后输入命令来安装 pod update --verbose --no-repo-update 等待过后就安装完成啦，其实使用pod install也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1nkijrj311u0wq1g6.jpg)\n\n安装成功！以后打卡工程就直接打开这个文件就好啦\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1y1x80j306q0cb0sy.jpg)\n\n其中podfile文件中显示了我们这个工程中所以集成的第三方，\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6k27zcbxj30ln0bfmxn.jpg)\n\n想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以pod开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install --verbose --no-repo-update 命令来更新，这样才会真正的生效。\n\n### 第六步：\n关于cocoapods的更新。有的时候在pod install的时候会出现[!] The 'master' repo requires CocoaPods 0.32.1 - 这样的错误，是由于你cocoapods版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。                                  \n##### 值得注意1         \n经常遇到的错误比如下面这个\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2hpy06j30ej01gt8q.jpg)\n\n通常出现在OS X 10.11系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k2pt7n9j30hy02zwev.jpg)\n\n这个命令就可以成功升级啦      \n\n##### 值得注意2\n有的时候大家在pod search的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用pod repo update（推荐）或者pod setup将远程仓库的框架信息更新到本地。其实，从pod search的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息[呵呵]\n    此外，如果你的框架更新比较慢，可以尝试执行下面2条指令更换镜像服务器\n1：pod repo remove master\n2：pod repo add master http://git.oschina.net/akuandev/Specs.git\n    更换镜像完毕后，以后执行pod repo update的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示403错误像这样\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2xgrwuj30i101h3yg.jpg)\n\n那么在执行完第一条之后直接pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。\n### 总结：\n关于使用cocoapods在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！\n","source":"_posts/2018-01-24-在iOS工程中Cocoapods的使用.md","raw":"---\ntitle: 在iOS工程中Cocoapods的使用\ncategories: iOS开发\ndate: 2018-01-24 12:42:28\ntags:\n  - Cocoapods\n  - 架构\ncomments:\n---\n我们在开发iOS程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程(比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到cocoapods来管理我们的第三方了，在我们有了CocoaPods这个工具之后，只需要将用到的第三方开源库放到一个名为Podfile的文件中，\n<!--more-->\n然后在命令行执行$ pod install命令。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。\n### 第一步 ：\n首先安装cocoapods要在ruby环境下进行，虽然我们的mac系统都是自带了ruby，但是为了保险起见我们还是要先更新一下ruby环境：在这里我们直接使用   sudo gem update --system   命令来更新，网上有的说使用 gem update --system 前面少了sudo，其实加sudo的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6jyxwn6cj30ta06kn1a.jpg)\n\n意思是你没有权限去执行这个命令，等出现了RubyGems system software updated 这句话的时候就证明升级成功了。\n\n### 第二步：\n安装cocoapods时候我们要访问cocoapods.org这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的ruby的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6jzdqmrlj30ma03ydjy.jpg)\n\n也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用gem sources --remove XXXXXXXXXXXXXXX 来把其他的source删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a https://ruby.taobao.org/ 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https  网上好多教程写的是 http，那个已经作废了\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6jzxkmf5j31kw0ask74.jpg)\n### 第三步：\n安装是cocoapods 使用 sudo gem install cocoapods 命令来安装cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。\n### 第四步：\n使用search命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找afnetworking 我就输入 pod search afn 回车后就会输出所有以afn开头的类库名字，像这样\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k0kkcjjj311u0wq4qp.jpg)\n\n搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑podfile时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的version是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。\n###### 值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json\n\n### 第五步：\n进入你的工程目录，这里建议直接右键你工程中.xcodeproj文件选择在终端中打开，然后 在终端中输入命令cd ..  就会跳到.xcodeproj所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile熟悉Linux的用户都知道这是创建一个Podfile文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作esc键  ->  \":\"  ->  输入wq\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k16wn0yj311s0wqth2.jpg)\n\n然后输入命令来安装 pod update --verbose --no-repo-update 等待过后就安装完成啦，其实使用pod install也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1nkijrj311u0wq1g6.jpg)\n\n安装成功！以后打卡工程就直接打开这个文件就好啦\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1y1x80j306q0cb0sy.jpg)\n\n其中podfile文件中显示了我们这个工程中所以集成的第三方，\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo6k27zcbxj30ln0bfmxn.jpg)\n\n想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以pod开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install --verbose --no-repo-update 命令来更新，这样才会真正的生效。\n\n### 第六步：\n关于cocoapods的更新。有的时候在pod install的时候会出现[!] The 'master' repo requires CocoaPods 0.32.1 - 这样的错误，是由于你cocoapods版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。                                  \n##### 值得注意1         \n经常遇到的错误比如下面这个\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2hpy06j30ej01gt8q.jpg)\n\n通常出现在OS X 10.11系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo6k2pt7n9j30hy02zwev.jpg)\n\n这个命令就可以成功升级啦      \n\n##### 值得注意2\n有的时候大家在pod search的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用pod repo update（推荐）或者pod setup将远程仓库的框架信息更新到本地。其实，从pod search的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息[呵呵]\n    此外，如果你的框架更新比较慢，可以尝试执行下面2条指令更换镜像服务器\n1：pod repo remove master\n2：pod repo add master http://git.oschina.net/akuandev/Specs.git\n    更换镜像完毕后，以后执行pod repo update的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示403错误像这样\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2xgrwuj30i101h3yg.jpg)\n\n那么在执行完第一条之后直接pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。\n### 总结：\n关于使用cocoapods在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！\n","slug":"在iOS工程中Cocoapods的使用","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2l90010a04wwawh6vi7","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>我们在开发iOS程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程(比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到cocoapods来管理我们的第三方了，在我们有了CocoaPods这个工具之后，只需要将用到的第三方开源库放到一个名为Podfile的文件中，<br><a id=\"more\"></a><br>然后在命令行执行$ pod install命令。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。</p>\n<h3 id=\"第一步-：\"><a href=\"#第一步-：\" class=\"headerlink\" title=\"第一步 ：\"></a>第一步 ：</h3><p>首先安装cocoapods要在ruby环境下进行，虽然我们的mac系统都是自带了ruby，但是为了保险起见我们还是要先更新一下ruby环境：在这里我们直接使用   sudo gem update –system   命令来更新，网上有的说使用 gem update –system 前面少了sudo，其实加sudo的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6jyxwn6cj30ta06kn1a.jpg\" alt=\"\"></p>\n<p>意思是你没有权限去执行这个命令，等出现了RubyGems system software updated 这句话的时候就证明升级成功了。</p>\n<h3 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h3><p>安装cocoapods时候我们要访问cocoapods.org这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的ruby的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6jzdqmrlj30ma03ydjy.jpg\" alt=\"\"></p>\n<p>也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用gem sources –remove XXXXXXXXXXXXXXX 来把其他的source删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a <a href=\"https://ruby.taobao.org/\" target=\"_blank\" rel=\"noopener\">https://ruby.taobao.org/</a> 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https  网上好多教程写的是 http，那个已经作废了</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6jzxkmf5j31kw0ask74.jpg\" alt=\"\"></p>\n<h3 id=\"第三步：\"><a href=\"#第三步：\" class=\"headerlink\" title=\"第三步：\"></a>第三步：</h3><p>安装是cocoapods 使用 sudo gem install cocoapods 命令来安装cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。</p>\n<h3 id=\"第四步：\"><a href=\"#第四步：\" class=\"headerlink\" title=\"第四步：\"></a>第四步：</h3><p>使用search命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找afnetworking 我就输入 pod search afn 回车后就会输出所有以afn开头的类库名字，像这样</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k0kkcjjj311u0wq4qp.jpg\" alt=\"\"></p>\n<p>搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑podfile时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的version是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。</p>\n<h6 id=\"值得注意的是如果你不是第一次安装cocoapods，-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-Library-Caches-CocoaPods-search-index-json\"><a href=\"#值得注意的是如果你不是第一次安装cocoapods，-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-Library-Caches-CocoaPods-search-index-json\" class=\"headerlink\" title=\"值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json\"></a>值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json</h6><h3 id=\"第五步：\"><a href=\"#第五步：\" class=\"headerlink\" title=\"第五步：\"></a>第五步：</h3><p>进入你的工程目录，这里建议直接右键你工程中.xcodeproj文件选择在终端中打开，然后 在终端中输入命令cd ..  就会跳到.xcodeproj所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile熟悉Linux的用户都知道这是创建一个Podfile文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作esc键  -&gt;  “:”  -&gt;  输入wq</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k16wn0yj311s0wqth2.jpg\" alt=\"\"></p>\n<p>然后输入命令来安装 pod update –verbose –no-repo-update 等待过后就安装完成啦，其实使用pod install也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1nkijrj311u0wq1g6.jpg\" alt=\"\"></p>\n<p>安装成功！以后打卡工程就直接打开这个文件就好啦</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1y1x80j306q0cb0sy.jpg\" alt=\"\"></p>\n<p>其中podfile文件中显示了我们这个工程中所以集成的第三方，</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6k27zcbxj30ln0bfmxn.jpg\" alt=\"\"></p>\n<p>想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以pod开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install –verbose –no-repo-update 命令来更新，这样才会真正的生效。</p>\n<h3 id=\"第六步：\"><a href=\"#第六步：\" class=\"headerlink\" title=\"第六步：\"></a>第六步：</h3><p>关于cocoapods的更新。有的时候在pod install的时候会出现[!] The ‘master’ repo requires CocoaPods 0.32.1 - 这样的错误，是由于你cocoapods版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。                                  </p>\n<h5 id=\"值得注意1\"><a href=\"#值得注意1\" class=\"headerlink\" title=\"值得注意1\"></a>值得注意1</h5><p>经常遇到的错误比如下面这个</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2hpy06j30ej01gt8q.jpg\" alt=\"\"></p>\n<p>通常出现在OS X 10.11系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k2pt7n9j30hy02zwev.jpg\" alt=\"\"></p>\n<p>这个命令就可以成功升级啦      </p>\n<h5 id=\"值得注意2\"><a href=\"#值得注意2\" class=\"headerlink\" title=\"值得注意2\"></a>值得注意2</h5><p>有的时候大家在pod search的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用pod repo update（推荐）或者pod setup将远程仓库的框架信息更新到本地。其实，从pod search的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息[呵呵]<br>    此外，如果你的框架更新比较慢，可以尝试执行下面2条指令更换镜像服务器<br>1：pod repo remove master<br>2：pod repo add master <a href=\"http://git.oschina.net/akuandev/Specs.git\" target=\"_blank\" rel=\"noopener\">http://git.oschina.net/akuandev/Specs.git</a><br>    更换镜像完毕后，以后执行pod repo update的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示403错误像这样</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2xgrwuj30i101h3yg.jpg\" alt=\"\"></p>\n<p>那么在执行完第一条之后直接pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>关于使用cocoapods在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>我们在开发iOS程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程(比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到cocoapods来管理我们的第三方了，在我们有了CocoaPods这个工具之后，只需要将用到的第三方开源库放到一个名为Podfile的文件中，<br>","more":"<br>然后在命令行执行$ pod install命令。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。</p>\n<h3 id=\"第一步-：\"><a href=\"#第一步-：\" class=\"headerlink\" title=\"第一步 ：\"></a>第一步 ：</h3><p>首先安装cocoapods要在ruby环境下进行，虽然我们的mac系统都是自带了ruby，但是为了保险起见我们还是要先更新一下ruby环境：在这里我们直接使用   sudo gem update –system   命令来更新，网上有的说使用 gem update –system 前面少了sudo，其实加sudo的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6jyxwn6cj30ta06kn1a.jpg\" alt=\"\"></p>\n<p>意思是你没有权限去执行这个命令，等出现了RubyGems system software updated 这句话的时候就证明升级成功了。</p>\n<h3 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h3><p>安装cocoapods时候我们要访问cocoapods.org这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的ruby的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6jzdqmrlj30ma03ydjy.jpg\" alt=\"\"></p>\n<p>也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用gem sources –remove XXXXXXXXXXXXXXX 来把其他的source删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a <a href=\"https://ruby.taobao.org/\" target=\"_blank\" rel=\"noopener\">https://ruby.taobao.org/</a> 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https  网上好多教程写的是 http，那个已经作废了</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6jzxkmf5j31kw0ask74.jpg\" alt=\"\"></p>\n<h3 id=\"第三步：\"><a href=\"#第三步：\" class=\"headerlink\" title=\"第三步：\"></a>第三步：</h3><p>安装是cocoapods 使用 sudo gem install cocoapods 命令来安装cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。</p>\n<h3 id=\"第四步：\"><a href=\"#第四步：\" class=\"headerlink\" title=\"第四步：\"></a>第四步：</h3><p>使用search命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找afnetworking 我就输入 pod search afn 回车后就会输出所有以afn开头的类库名字，像这样</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k0kkcjjj311u0wq4qp.jpg\" alt=\"\"></p>\n<p>搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑podfile时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的version是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。</p>\n<h6 id=\"值得注意的是如果你不是第一次安装cocoapods，-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-Library-Caches-CocoaPods-search-index-json\"><a href=\"#值得注意的是如果你不是第一次安装cocoapods，-那么之前的缓存会对你有影响search先清理下缓存-使用这个命之后就可以了-rm-Library-Caches-CocoaPods-search-index-json\" class=\"headerlink\" title=\"值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json\"></a>值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json</h6><h3 id=\"第五步：\"><a href=\"#第五步：\" class=\"headerlink\" title=\"第五步：\"></a>第五步：</h3><p>进入你的工程目录，这里建议直接右键你工程中.xcodeproj文件选择在终端中打开，然后 在终端中输入命令cd ..  就会跳到.xcodeproj所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile熟悉Linux的用户都知道这是创建一个Podfile文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作esc键  -&gt;  “:”  -&gt;  输入wq</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k16wn0yj311s0wqth2.jpg\" alt=\"\"></p>\n<p>然后输入命令来安装 pod update –verbose –no-repo-update 等待过后就安装完成啦，其实使用pod install也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1nkijrj311u0wq1g6.jpg\" alt=\"\"></p>\n<p>安装成功！以后打卡工程就直接打开这个文件就好啦</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo6k1y1x80j306q0cb0sy.jpg\" alt=\"\"></p>\n<p>其中podfile文件中显示了我们这个工程中所以集成的第三方，</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6k27zcbxj30ln0bfmxn.jpg\" alt=\"\"></p>\n<p>想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以pod开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install –verbose –no-repo-update 命令来更新，这样才会真正的生效。</p>\n<h3 id=\"第六步：\"><a href=\"#第六步：\" class=\"headerlink\" title=\"第六步：\"></a>第六步：</h3><p>关于cocoapods的更新。有的时候在pod install的时候会出现[!] The ‘master’ repo requires CocoaPods 0.32.1 - 这样的错误，是由于你cocoapods版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。                                  </p>\n<h5 id=\"值得注意1\"><a href=\"#值得注意1\" class=\"headerlink\" title=\"值得注意1\"></a>值得注意1</h5><p>经常遇到的错误比如下面这个</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2hpy06j30ej01gt8q.jpg\" alt=\"\"></p>\n<p>通常出现在OS X 10.11系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6k2pt7n9j30hy02zwev.jpg\" alt=\"\"></p>\n<p>这个命令就可以成功升级啦      </p>\n<h5 id=\"值得注意2\"><a href=\"#值得注意2\" class=\"headerlink\" title=\"值得注意2\"></a>值得注意2</h5><p>有的时候大家在pod search的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用pod repo update（推荐）或者pod setup将远程仓库的框架信息更新到本地。其实，从pod search的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息[呵呵]<br>    此外，如果你的框架更新比较慢，可以尝试执行下面2条指令更换镜像服务器<br>1：pod repo remove master<br>2：pod repo add master <a href=\"http://git.oschina.net/akuandev/Specs.git\" target=\"_blank\" rel=\"noopener\">http://git.oschina.net/akuandev/Specs.git</a><br>    更换镜像完毕后，以后执行pod repo update的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示403错误像这样</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6k2xgrwuj30i101h3yg.jpg\" alt=\"\"></p>\n<p>那么在执行完第一条之后直接pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>关于使用cocoapods在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！</p>"},{"title":"(转)如何掌握所有的程序语言","date":"2018-01-24T03:38:59.000Z","comments":1,"_content":"觉得作者写的很好就转载下，原文链接：http://www.yinwang.org/blog-cn/2017/07/06/master-pl\n\n对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……\n很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道标题问题的答案，所以总感觉这个问题是如此“低级”，一直没来得及回复 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。\n今天休闲活动进入第二个星期，稍微闲下来一点，我想来统一回答一下这个搁置已久的“初级问题”。这个话题貌似曾经写过，然而现在我想把它重新写一遍。因为通过跟很多人的交流，我对自己头脑中的（未转化为语言的）想法，有了更精确的表达。\n如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：\n你是编程初学者，不知道该选择什么程序语言来入门。\n你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”于那种语言。\n你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。\n你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……\n<!--more-->\n\n虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝 :P\n其实呢，我并不是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。。。 :P\n重视语言特性，而不是语言\n很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。\n任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。\n这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：\n变量定义\n算术运算\nfor 循环语句，while 循环语句\n函数定义，函数调用\n递归\n静态类型系统\n类型推导\nlambda 函数\n面向对象\n垃圾回收\n指针算术\ngoto 语句\n\n这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。\n程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，我都可以把他纠结过的语言全部掌握了。\n初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。\n很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。\n在这个过程中，他会问这样的问题：\n这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？\n它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？\n这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？\n……\n\n注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。\n这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。\n掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！\n同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的[博文](http://www.yinwang.org/blog-cn/2017/05/23/kotlin)里指出了 checked exception 和 union type 之间的关系 :P\n很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。\n合理的入门语言\n所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：\nScheme\nC\nJava\nPython\nJavaScript\n\n那么相比之下，我不推荐用哪些语言入门呢？\nShell\nPowerShell\nAWK\nPerl\nPHP\nBasic\nGo\n\n总的说来，你不应该使用所谓“[脚本语言](http://www.yinwang.org/blog-cn/2013/03/29/scripting-language)”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P\n采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……\n不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。\n掌握关键语言特性，忽略次要特性\n为了达到我之前提到的“融会贯通”，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的内容分心。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……\n可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解“变量”和“函数”是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 %d\n，%f\n，%.2f\n 的含义都记不住，还怎么学编程！\n然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？\n所以你就发现一旦被坏老师教过，这个程序员基本就毁了。就算遇到好的老师，她也很难纠正过来。\n自己动手实现语言特性\n在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完完全全的拥有它们，成为它们的主人。否则你就只是它们的使用者，你会永远做语言创造者们的仆人。\n有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。\n注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。\n举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念。它甚至能帮助你理解各种面向对象实现的差异，这种效果是你直接学习 OOP 语言也得不到的。\n类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前都是可以被任意拆卸组装玩弄的玩具，而不再是凌驾于我之上，高高在上的神圣。\n总结\n写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是整个语言的“品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码\n","source":"_posts/2018-01-24-转-如何掌握所有的程序语言.md","raw":"---\ntitle: (转)如何掌握所有的程序语言\ncategories: 通用开发\ndate: 2018-01-24 11:38:59\ntags:\n  - 杂谈\ncomments:\n---\n觉得作者写的很好就转载下，原文链接：http://www.yinwang.org/blog-cn/2017/07/06/master-pl\n\n对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……\n很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道标题问题的答案，所以总感觉这个问题是如此“低级”，一直没来得及回复 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。\n今天休闲活动进入第二个星期，稍微闲下来一点，我想来统一回答一下这个搁置已久的“初级问题”。这个话题貌似曾经写过，然而现在我想把它重新写一遍。因为通过跟很多人的交流，我对自己头脑中的（未转化为语言的）想法，有了更精确的表达。\n如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：\n你是编程初学者，不知道该选择什么程序语言来入门。\n你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”于那种语言。\n你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。\n你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……\n<!--more-->\n\n虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝 :P\n其实呢，我并不是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。。。 :P\n重视语言特性，而不是语言\n很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。\n任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。\n这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：\n变量定义\n算术运算\nfor 循环语句，while 循环语句\n函数定义，函数调用\n递归\n静态类型系统\n类型推导\nlambda 函数\n面向对象\n垃圾回收\n指针算术\ngoto 语句\n\n这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。\n程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，我都可以把他纠结过的语言全部掌握了。\n初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。\n很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。\n在这个过程中，他会问这样的问题：\n这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？\n它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？\n这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？\n……\n\n注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。\n这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。\n掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！\n同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的[博文](http://www.yinwang.org/blog-cn/2017/05/23/kotlin)里指出了 checked exception 和 union type 之间的关系 :P\n很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。\n合理的入门语言\n所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：\nScheme\nC\nJava\nPython\nJavaScript\n\n那么相比之下，我不推荐用哪些语言入门呢？\nShell\nPowerShell\nAWK\nPerl\nPHP\nBasic\nGo\n\n总的说来，你不应该使用所谓“[脚本语言](http://www.yinwang.org/blog-cn/2013/03/29/scripting-language)”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P\n采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……\n不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。\n掌握关键语言特性，忽略次要特性\n为了达到我之前提到的“融会贯通”，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的内容分心。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……\n可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解“变量”和“函数”是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 %d\n，%f\n，%.2f\n 的含义都记不住，还怎么学编程！\n然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？\n所以你就发现一旦被坏老师教过，这个程序员基本就毁了。就算遇到好的老师，她也很难纠正过来。\n自己动手实现语言特性\n在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完完全全的拥有它们，成为它们的主人。否则你就只是它们的使用者，你会永远做语言创造者们的仆人。\n有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。\n注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。\n举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念。它甚至能帮助你理解各种面向对象实现的差异，这种效果是你直接学习 OOP 语言也得不到的。\n类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前都是可以被任意拆卸组装玩弄的玩具，而不再是凌驾于我之上，高高在上的神圣。\n总结\n写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是整个语言的“品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码\n","slug":"转-如何掌握所有的程序语言","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lb0014a04wpz18qtns","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>觉得作者写的很好就转载下，原文链接：<a href=\"http://www.yinwang.org/blog-cn/2017/07/06/master-pl\" target=\"_blank\" rel=\"noopener\">http://www.yinwang.org/blog-cn/2017/07/06/master-pl</a></p>\n<p>对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……<br>很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道标题问题的答案，所以总感觉这个问题是如此“低级”，一直没来得及回复 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。<br>今天休闲活动进入第二个星期，稍微闲下来一点，我想来统一回答一下这个搁置已久的“初级问题”。这个话题貌似曾经写过，然而现在我想把它重新写一遍。因为通过跟很多人的交流，我对自己头脑中的（未转化为语言的）想法，有了更精确的表达。<br>如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：<br>你是编程初学者，不知道该选择什么程序语言来入门。<br>你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”于那种语言。<br>你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。<br>你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……<br><a id=\"more\"></a></p>\n<p>虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝 :P<br>其实呢，我并不是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。。。 :P<br>重视语言特性，而不是语言<br>很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。<br>任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。<br>这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：<br>变量定义<br>算术运算<br>for 循环语句，while 循环语句<br>函数定义，函数调用<br>递归<br>静态类型系统<br>类型推导<br>lambda 函数<br>面向对象<br>垃圾回收<br>指针算术<br>goto 语句</p>\n<p>这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。<br>程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，我都可以把他纠结过的语言全部掌握了。<br>初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。<br>很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。<br>在这个过程中，他会问这样的问题：<br>这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？<br>它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？<br>这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？<br>……</p>\n<p>注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。<br>这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。<br>掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！<br>同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的<a href=\"http://www.yinwang.org/blog-cn/2017/05/23/kotlin\" target=\"_blank\" rel=\"noopener\">博文</a>里指出了 checked exception 和 union type 之间的关系 :P<br>很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。<br>合理的入门语言<br>所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：<br>Scheme<br>C<br>Java<br>Python<br>JavaScript</p>\n<p>那么相比之下，我不推荐用哪些语言入门呢？<br>Shell<br>PowerShell<br>AWK<br>Perl<br>PHP<br>Basic<br>Go</p>\n<p>总的说来，你不应该使用所谓“<a href=\"http://www.yinwang.org/blog-cn/2013/03/29/scripting-language\" target=\"_blank\" rel=\"noopener\">脚本语言</a>”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P<br>采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……<br>不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。<br>掌握关键语言特性，忽略次要特性<br>为了达到我之前提到的“融会贯通”，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的内容分心。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……<br>可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解“变量”和“函数”是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 %d<br>，%f<br>，%.2f<br> 的含义都记不住，还怎么学编程！<br>然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？<br>所以你就发现一旦被坏老师教过，这个程序员基本就毁了。就算遇到好的老师，她也很难纠正过来。<br>自己动手实现语言特性<br>在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完完全全的拥有它们，成为它们的主人。否则你就只是它们的使用者，你会永远做语言创造者们的仆人。<br>有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。<br>注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。<br>举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念。它甚至能帮助你理解各种面向对象实现的差异，这种效果是你直接学习 OOP 语言也得不到的。<br>类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前都是可以被任意拆卸组装玩弄的玩具，而不再是凌驾于我之上，高高在上的神圣。<br>总结<br>写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是整个语言的“品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码</p>\n","site":{"data":{}},"excerpt":"<p>觉得作者写的很好就转载下，原文链接：<a href=\"http://www.yinwang.org/blog-cn/2017/07/06/master-pl\" target=\"_blank\" rel=\"noopener\">http://www.yinwang.org/blog-cn/2017/07/06/master-pl</a></p>\n<p>对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……<br>很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道标题问题的答案，所以总感觉这个问题是如此“低级”，一直没来得及回复 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。<br>今天休闲活动进入第二个星期，稍微闲下来一点，我想来统一回答一下这个搁置已久的“初级问题”。这个话题貌似曾经写过，然而现在我想把它重新写一遍。因为通过跟很多人的交流，我对自己头脑中的（未转化为语言的）想法，有了更精确的表达。<br>如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：<br>你是编程初学者，不知道该选择什么程序语言来入门。<br>你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”于那种语言。<br>你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。<br>你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……<br>","more":"</p>\n<p>虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝 :P<br>其实呢，我并不是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。。。 :P<br>重视语言特性，而不是语言<br>很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。<br>任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。<br>这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：<br>变量定义<br>算术运算<br>for 循环语句，while 循环语句<br>函数定义，函数调用<br>递归<br>静态类型系统<br>类型推导<br>lambda 函数<br>面向对象<br>垃圾回收<br>指针算术<br>goto 语句</p>\n<p>这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。<br>程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，我都可以把他纠结过的语言全部掌握了。<br>初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。<br>很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。<br>在这个过程中，他会问这样的问题：<br>这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？<br>它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？<br>这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？<br>……</p>\n<p>注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。<br>这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。<br>掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！<br>同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的<a href=\"http://www.yinwang.org/blog-cn/2017/05/23/kotlin\" target=\"_blank\" rel=\"noopener\">博文</a>里指出了 checked exception 和 union type 之间的关系 :P<br>很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。<br>合理的入门语言<br>所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：<br>Scheme<br>C<br>Java<br>Python<br>JavaScript</p>\n<p>那么相比之下，我不推荐用哪些语言入门呢？<br>Shell<br>PowerShell<br>AWK<br>Perl<br>PHP<br>Basic<br>Go</p>\n<p>总的说来，你不应该使用所谓“<a href=\"http://www.yinwang.org/blog-cn/2013/03/29/scripting-language\" target=\"_blank\" rel=\"noopener\">脚本语言</a>”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P<br>采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……<br>不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。<br>掌握关键语言特性，忽略次要特性<br>为了达到我之前提到的“融会贯通”，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的内容分心。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……<br>可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解“变量”和“函数”是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 %d<br>，%f<br>，%.2f<br> 的含义都记不住，还怎么学编程！<br>然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？<br>所以你就发现一旦被坏老师教过，这个程序员基本就毁了。就算遇到好的老师，她也很难纠正过来。<br>自己动手实现语言特性<br>在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完完全全的拥有它们，成为它们的主人。否则你就只是它们的使用者，你会永远做语言创造者们的仆人。<br>有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。<br>注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。<br>举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念。它甚至能帮助你理解各种面向对象实现的差异，这种效果是你直接学习 OOP 语言也得不到的。<br>类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前都是可以被任意拆卸组装玩弄的玩具，而不再是凌驾于我之上，高高在上的神圣。<br>总结<br>写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是整个语言的“品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码</p>"},{"title":"记一次Runtime Hook的问题","date":"2018-01-24T03:35:57.000Z","comments":1,"_content":"#### 背景\n项目中遇到一个问题，需要引入两个SDK，我们暂且命名为A 和 B，由于业务需要这两个SDK都需要对一个系统函数C进行hook, 但是有一个前提，由于B 所做的是一个统计相关的SDK，所以B要监控App内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保B在hook C函数时候  A已经对C函数hook完毕，其实这就涉及到hook顺序的问题。\n<!--more-->\n#### 研究\n先看下代码，我用hookMethod来模仿系统方法。\n```\n- (void) TEST_HOOK_TWICE {\n    [self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod1\" isClassMethod:NO];\n\n    [self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod2\" isClassMethod:NO];\n\n    [self hookedMethod];\n\n}\n\n- (void)hookedMethod {\n    NSLog(@\"原始方法\");\n}\n\n- (void)swizzle_hookedMethod1 {\n    NSLog(@\"1\");\n    [self swizzle_hookedMethod1];\n}\n\n- (void)swizzle_hookedMethod2 {\n    NSLog(@\"2\");\n    [self swizzle_hookedMethod2];\n}\n```\n然后看下没有hook之前的样子\n\n\n![原本的样子](https://ws2.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg)\n\n\n然后我们执行代码\n```\n//第一步：交换A中的方法和系统方法\n [self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod1\" isClassMethod:NO];\n//第二步：交换B中的方法和系统方法\n[self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod2\" isClassMethod:NO];\n//第三步：调用系统方法\n[self hookedMethod];\n```\n然后我们一步一步来看，先看调用第一步之后是什么样子的(红色箭头为第一步之后的样子)\n\n![第一步之后](https://ws3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg)\n\n然后看第二步调用完之后的样子(绿色是第二步调用)\n\n![第二部之后的样子](https://ws2.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg)\n\n接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的(每个方法实现里面都会递归调用下自身，为了是hook时候不改变原有逻辑)\n\n![调用顺序](https://ws3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg)\n\n这样一来就很明显 如果想想监控住所有的代码那就需要在A IMP 这步，因为之前的Hook顺序是先A -> B -> System 这样一来只要我们改一下顺序改为 B -> A -> System就可以让B SDK监控到所有的代码。\n\n![调用顺序](https://ws4.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg)\n","source":"_posts/2018-01-24-记一次Runtime-Hook的问题.md","raw":"---\ntitle: 记一次Runtime Hook的问题\ncategories: iOS开发\ndate: 2018-01-24 11:35:57\ntags:\n  - 底层\n  - runtime\n  - Hook\ncomments:\n---\n#### 背景\n项目中遇到一个问题，需要引入两个SDK，我们暂且命名为A 和 B，由于业务需要这两个SDK都需要对一个系统函数C进行hook, 但是有一个前提，由于B 所做的是一个统计相关的SDK，所以B要监控App内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保B在hook C函数时候  A已经对C函数hook完毕，其实这就涉及到hook顺序的问题。\n<!--more-->\n#### 研究\n先看下代码，我用hookMethod来模仿系统方法。\n```\n- (void) TEST_HOOK_TWICE {\n    [self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod1\" isClassMethod:NO];\n\n    [self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod2\" isClassMethod:NO];\n\n    [self hookedMethod];\n\n}\n\n- (void)hookedMethod {\n    NSLog(@\"原始方法\");\n}\n\n- (void)swizzle_hookedMethod1 {\n    NSLog(@\"1\");\n    [self swizzle_hookedMethod1];\n}\n\n- (void)swizzle_hookedMethod2 {\n    NSLog(@\"2\");\n    [self swizzle_hookedMethod2];\n}\n```\n然后看下没有hook之前的样子\n\n\n![原本的样子](https://ws2.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg)\n\n\n然后我们执行代码\n```\n//第一步：交换A中的方法和系统方法\n [self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod1\" isClassMethod:NO];\n//第二步：交换B中的方法和系统方法\n[self changeOrginalSelectorName:@\"hookedMethod\" inClass:@\"RootViewController\" withCustomSelectorName:@\"swizzle_hookedMethod2\" isClassMethod:NO];\n//第三步：调用系统方法\n[self hookedMethod];\n```\n然后我们一步一步来看，先看调用第一步之后是什么样子的(红色箭头为第一步之后的样子)\n\n![第一步之后](https://ws3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg)\n\n然后看第二步调用完之后的样子(绿色是第二步调用)\n\n![第二部之后的样子](https://ws2.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg)\n\n接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的(每个方法实现里面都会递归调用下自身，为了是hook时候不改变原有逻辑)\n\n![调用顺序](https://ws3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg)\n\n这样一来就很明显 如果想想监控住所有的代码那就需要在A IMP 这步，因为之前的Hook顺序是先A -> B -> System 这样一来只要我们改一下顺序改为 B -> A -> System就可以让B SDK监控到所有的代码。\n\n![调用顺序](https://ws4.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg)\n","slug":"记一次Runtime-Hook的问题","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2ld0017a04wjkywxar4","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>项目中遇到一个问题，需要引入两个SDK，我们暂且命名为A 和 B，由于业务需要这两个SDK都需要对一个系统函数C进行hook, 但是有一个前提，由于B 所做的是一个统计相关的SDK，所以B要监控App内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保B在hook C函数时候  A已经对C函数hook完毕，其实这就涉及到hook顺序的问题。<br><a id=\"more\"></a></p>\n<h4 id=\"研究\"><a href=\"#研究\" class=\"headerlink\" title=\"研究\"></a>研究</h4><p>先看下代码，我用hookMethod来模仿系统方法。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) TEST_HOOK_TWICE &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@\"hookedMethod\"</span> inClass:<span class=\"string\">@\"RootViewController\"</span> withCustomSelectorName:<span class=\"string\">@\"swizzle_hookedMethod1\"</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@\"hookedMethod\"</span> inClass:<span class=\"string\">@\"RootViewController\"</span> withCustomSelectorName:<span class=\"string\">@\"swizzle_hookedMethod2\"</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> hookedMethod];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hookedMethod &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"原始方法\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)swizzle_hookedMethod1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)swizzle_hookedMethod2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后看下没有hook之前的样子</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg\" alt=\"原本的样子\"></p>\n<p>然后我们执行代码<br><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步：交换A中的方法和系统方法</span></span><br><span class=\"line\"> [self <span class=\"string\">changeOrginalSelectorName:</span>@<span class=\"string\">\"hookedMethod\"</span> <span class=\"string\">inClass:</span>@<span class=\"string\">\"RootViewController\"</span> <span class=\"string\">withCustomSelectorName:</span>@<span class=\"string\">\"swizzle_hookedMethod1\"</span> <span class=\"string\">isClassMethod:</span>NO];</span><br><span class=\"line\"><span class=\"comment\">//第二步：交换B中的方法和系统方法</span></span><br><span class=\"line\">[self <span class=\"string\">changeOrginalSelectorName:</span>@<span class=\"string\">\"hookedMethod\"</span> <span class=\"string\">inClass:</span>@<span class=\"string\">\"RootViewController\"</span> <span class=\"string\">withCustomSelectorName:</span>@<span class=\"string\">\"swizzle_hookedMethod2\"</span> <span class=\"string\">isClassMethod:</span>NO];</span><br><span class=\"line\"><span class=\"comment\">//第三步：调用系统方法</span></span><br><span class=\"line\">[self hookedMethod];</span><br></pre></td></tr></table></figure></p>\n<p>然后我们一步一步来看，先看调用第一步之后是什么样子的(红色箭头为第一步之后的样子)</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg\" alt=\"第一步之后\"></p>\n<p>然后看第二步调用完之后的样子(绿色是第二步调用)</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg\" alt=\"第二部之后的样子\"></p>\n<p>接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的(每个方法实现里面都会递归调用下自身，为了是hook时候不改变原有逻辑)</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg\" alt=\"调用顺序\"></p>\n<p>这样一来就很明显 如果想想监控住所有的代码那就需要在A IMP 这步，因为之前的Hook顺序是先A -&gt; B -&gt; System 这样一来只要我们改一下顺序改为 B -&gt; A -&gt; System就可以让B SDK监控到所有的代码。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg\" alt=\"调用顺序\"></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>项目中遇到一个问题，需要引入两个SDK，我们暂且命名为A 和 B，由于业务需要这两个SDK都需要对一个系统函数C进行hook, 但是有一个前提，由于B 所做的是一个统计相关的SDK，所以B要监控App内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保B在hook C函数时候  A已经对C函数hook完毕，其实这就涉及到hook顺序的问题。<br>","more":"</p>\n<h4 id=\"研究\"><a href=\"#研究\" class=\"headerlink\" title=\"研究\"></a>研究</h4><p>先看下代码，我用hookMethod来模仿系统方法。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>) TEST_HOOK_TWICE &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@\"hookedMethod\"</span> inClass:<span class=\"string\">@\"RootViewController\"</span> withCustomSelectorName:<span class=\"string\">@\"swizzle_hookedMethod1\"</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> changeOrginalSelectorName:<span class=\"string\">@\"hookedMethod\"</span> inClass:<span class=\"string\">@\"RootViewController\"</span> withCustomSelectorName:<span class=\"string\">@\"swizzle_hookedMethod2\"</span> isClassMethod:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> hookedMethod];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hookedMethod &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"原始方法\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)swizzle_hookedMethod1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"1\"</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)swizzle_hookedMethod2 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"2\"</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> swizzle_hookedMethod2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后看下没有hook之前的样子</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6ll1zt21j30j80jk3zc.jpg\" alt=\"原本的样子\"></p>\n<p>然后我们执行代码<br><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步：交换A中的方法和系统方法</span></span><br><span class=\"line\"> [self <span class=\"string\">changeOrginalSelectorName:</span>@<span class=\"string\">\"hookedMethod\"</span> <span class=\"string\">inClass:</span>@<span class=\"string\">\"RootViewController\"</span> <span class=\"string\">withCustomSelectorName:</span>@<span class=\"string\">\"swizzle_hookedMethod1\"</span> <span class=\"string\">isClassMethod:</span>NO];</span><br><span class=\"line\"><span class=\"comment\">//第二步：交换B中的方法和系统方法</span></span><br><span class=\"line\">[self <span class=\"string\">changeOrginalSelectorName:</span>@<span class=\"string\">\"hookedMethod\"</span> <span class=\"string\">inClass:</span>@<span class=\"string\">\"RootViewController\"</span> <span class=\"string\">withCustomSelectorName:</span>@<span class=\"string\">\"swizzle_hookedMethod2\"</span> <span class=\"string\">isClassMethod:</span>NO];</span><br><span class=\"line\"><span class=\"comment\">//第三步：调用系统方法</span></span><br><span class=\"line\">[self hookedMethod];</span><br></pre></td></tr></table></figure></p>\n<p>然后我们一步一步来看，先看调用第一步之后是什么样子的(红色箭头为第一步之后的样子)</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6llhzf0uj30ki0k2q3z.jpg\" alt=\"第一步之后\"></p>\n<p>然后看第二步调用完之后的样子(绿色是第二步调用)</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo6lm7mfshj30jo0iu75m.jpg\" alt=\"第二部之后的样子\"></p>\n<p>接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的(每个方法实现里面都会递归调用下自身，为了是hook时候不改变原有逻辑)</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo6lmi43vmj30yg03v756.jpg\" alt=\"调用顺序\"></p>\n<p>这样一来就很明显 如果想想监控住所有的代码那就需要在A IMP 这步，因为之前的Hook顺序是先A -&gt; B -&gt; System 这样一来只要我们改一下顺序改为 B -&gt; A -&gt; System就可以让B SDK监控到所有的代码。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo6ln0wmlyj30yg07ign0.jpg\" alt=\"调用顺序\"></p>"},{"title":"关于iPhone X下Home键的隐藏和延迟响应","date":"2018-02-08T02:15:57.000Z","comments":1,"_content":"\n# iOS 11通用相关\n\n## Edge Protect\n\niPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的“系统手势和App自带手势冲突”的问题也给出了相应的解决办法:\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg)\n\n虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 \"edge protect\" 因为进入App后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。\n\n<!--more-->\n\n根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发App的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。\n\n## API Discussion\n\n根据官方文档找到对应的API\n\n```\n// Override to return a child view controller or nil. If non-nil, that view controller's screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.\n- (nullable UIViewController *)childViewControllerForScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// Controls the application's preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.\n- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// This should be called whenever the return values for the view controller's screen edges deferring system gestures have changed.\n- (void)setNeedsUpdateOfScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n```\n#### childViewControllerForScreenEdgesDeferringSystemGestures\n\n该方法是用来控制子试图控制器是否允许开发者控制edge protect的开启或是关闭。如果实现了这个方法并且返回值不为空那么子VC的edge protect设置就会遵循父VC的设置，跟随父VC是否延迟执行系统手势。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg)\n\n#### preferredScreenEdgesDeferringSystemGestures\n\n该方法是设置edge protect的方法，返回值是一个边界的枚举\n\n```\ntypedef NS_OPTIONS(NSUInteger, UIRectEdge) {\n    UIRectEdgeNone   = 0,\n    UIRectEdgeTop    = 1 << 0,\n    UIRectEdgeLeft   = 1 << 1,\n    UIRectEdgeBottom = 1 << 2,\n    UIRectEdgeRight  = 1 << 3,\n    UIRectEdgeAll    = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight\n} NS_ENUM_AVAILABLE_IOS(7_0);\n```\n\n因为不论我们从shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从iOS11开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于VC的左边界右滑动pop手势是无效的，也就是说这个pop手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。\n\n* 无限制\n\n  当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于Tab.eView的scroll手势执行，虽说屏幕大部分的界面还是执行TableView手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等\n\n  ![](https://ws2.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif)\n\n\n* Edge Protent\n\n  在对应的ViewControll中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发App内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。\n```\n-(UIRectEdge)preferredScreenEdgesDeferringSystemGestures\n{\n    return UIRectEdgeAll;\n}\n```\n\n  ![](https://ws4.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif)\n\n#### setNeedsUpdateOfScreenEdgesDeferringSystemGestures\n\n这个方法是在应用内部动态控制edge protect，我们可以在上个方法中返回一个BOOL变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif)\n\n\n# iPhone X使用相关\n\niPhone X在系统手势上面交互和其他设备还是有一定区别的，因为加入了Home Indicator的原因，引入了新的手势，同时对以往的手势也做了相应的调整。\n\n## iPhone X Edge Protect\n\n在iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被Home Indicator占用。其实Edge Protect在这里依然适用，只是对于Home Indicator的手势有一个小插曲。正常来说他在底部，就应该受到UIRectEdgeBottom 或者是 UIRectEdgeAll控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在iPhone X刚发布我就试图去处理交互问题，因为海报工厂并没有传统的UITabBarController，且里面所有的tableView都是直通到底，但是始终都无法延迟执行与Home Indicator相关的任何手势。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg)\n\n后来看了其他游戏，视频类App在iPhone X上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年1月25日苹果推送了iOS 11.2.5的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的Home Indicator当你一段时间不去触碰它的时候由黑色或者白色(根据当前的屏幕显示的内容来决定)变成非常透明的灰色，当你第一次进行操作会默认执行App内手势，同时激活Home Indicator，短时间内进行第二次操作就可以返回桌面\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif)\n\n一开以为是有新的API出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的edge protect 代码运行后确实可以达到效果。对于视频，游戏等App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括Gameloft出品的游戏都没做相应的处理。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif)\n\n## iPhone X Home Indicator Hidden\n\n如果说上面的Edge Protect适合在游戏中使用，那么Home Indicator Hidden则更适合在非游戏环境下增强App的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个API，和Edge protect的用法完全一样。\n\n```\n// Override to return a child view controller or nil. If non-nil, that view controller's home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.\n- (nullable UIViewController *)childViewControllerForHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// Controls the application's preferred home indicator auto-hiding when this view controller is shown.\n- (BOOL)prefersHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// This should be called whenever the return values for the view controller's home indicator auto-hiding have changed.\n- (void)setNeedsUpdateOfHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n```\n上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候Home Indicator会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif)\n\n如果是feed流界面搭配酷一点的UI就会提高沉浸感，比如这样：\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif)\n\n有的人可能会问如果说点击的手势会触发它再次显示那我获取window上的交互每次在它即将显示的时候通过**setNeedsUpdateOfHomeIndicatorAutoHidden**在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。\n\n## 坑点\n\n需要注意的是：prefersHomeIndicatorAutoHidden和preferredScreenEdgesDeferringSystemGestures不可一起使用，如果一起使用的话后者是不生效的。\n","source":"_posts/2018-02-08-关于iPhone-X下Home键的隐藏和延迟响应.md","raw":"---\ntitle: 关于iPhone X下Home键的隐藏和延迟响应\ncategories: iOS开发\ndate: 2018-02-08 10:15:57\ntags:\n - UI\n - 屏幕适配\n - iOS 11\ncomments:\n---\n\n# iOS 11通用相关\n\n## Edge Protect\n\niPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的“系统手势和App自带手势冲突”的问题也给出了相应的解决办法:\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg)\n\n虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 \"edge protect\" 因为进入App后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。\n\n<!--more-->\n\n根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发App的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。\n\n## API Discussion\n\n根据官方文档找到对应的API\n\n```\n// Override to return a child view controller or nil. If non-nil, that view controller's screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.\n- (nullable UIViewController *)childViewControllerForScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// Controls the application's preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.\n- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// This should be called whenever the return values for the view controller's screen edges deferring system gestures have changed.\n- (void)setNeedsUpdateOfScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n```\n#### childViewControllerForScreenEdgesDeferringSystemGestures\n\n该方法是用来控制子试图控制器是否允许开发者控制edge protect的开启或是关闭。如果实现了这个方法并且返回值不为空那么子VC的edge protect设置就会遵循父VC的设置，跟随父VC是否延迟执行系统手势。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg)\n\n#### preferredScreenEdgesDeferringSystemGestures\n\n该方法是设置edge protect的方法，返回值是一个边界的枚举\n\n```\ntypedef NS_OPTIONS(NSUInteger, UIRectEdge) {\n    UIRectEdgeNone   = 0,\n    UIRectEdgeTop    = 1 << 0,\n    UIRectEdgeLeft   = 1 << 1,\n    UIRectEdgeBottom = 1 << 2,\n    UIRectEdgeRight  = 1 << 3,\n    UIRectEdgeAll    = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight\n} NS_ENUM_AVAILABLE_IOS(7_0);\n```\n\n因为不论我们从shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从iOS11开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于VC的左边界右滑动pop手势是无效的，也就是说这个pop手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。\n\n* 无限制\n\n  当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于Tab.eView的scroll手势执行，虽说屏幕大部分的界面还是执行TableView手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等\n\n  ![](https://ws2.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif)\n\n\n* Edge Protent\n\n  在对应的ViewControll中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发App内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。\n```\n-(UIRectEdge)preferredScreenEdgesDeferringSystemGestures\n{\n    return UIRectEdgeAll;\n}\n```\n\n  ![](https://ws4.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif)\n\n#### setNeedsUpdateOfScreenEdgesDeferringSystemGestures\n\n这个方法是在应用内部动态控制edge protect，我们可以在上个方法中返回一个BOOL变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif)\n\n\n# iPhone X使用相关\n\niPhone X在系统手势上面交互和其他设备还是有一定区别的，因为加入了Home Indicator的原因，引入了新的手势，同时对以往的手势也做了相应的调整。\n\n## iPhone X Edge Protect\n\n在iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被Home Indicator占用。其实Edge Protect在这里依然适用，只是对于Home Indicator的手势有一个小插曲。正常来说他在底部，就应该受到UIRectEdgeBottom 或者是 UIRectEdgeAll控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在iPhone X刚发布我就试图去处理交互问题，因为海报工厂并没有传统的UITabBarController，且里面所有的tableView都是直通到底，但是始终都无法延迟执行与Home Indicator相关的任何手势。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg)\n\n后来看了其他游戏，视频类App在iPhone X上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年1月25日苹果推送了iOS 11.2.5的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的Home Indicator当你一段时间不去触碰它的时候由黑色或者白色(根据当前的屏幕显示的内容来决定)变成非常透明的灰色，当你第一次进行操作会默认执行App内手势，同时激活Home Indicator，短时间内进行第二次操作就可以返回桌面\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif)\n\n一开以为是有新的API出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的edge protect 代码运行后确实可以达到效果。对于视频，游戏等App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括Gameloft出品的游戏都没做相应的处理。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif)\n\n## iPhone X Home Indicator Hidden\n\n如果说上面的Edge Protect适合在游戏中使用，那么Home Indicator Hidden则更适合在非游戏环境下增强App的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个API，和Edge protect的用法完全一样。\n\n```\n// Override to return a child view controller or nil. If non-nil, that view controller's home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.\n- (nullable UIViewController *)childViewControllerForHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// Controls the application's preferred home indicator auto-hiding when this view controller is shown.\n- (BOOL)prefersHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n\n// This should be called whenever the return values for the view controller's home indicator auto-hiding have changed.\n- (void)setNeedsUpdateOfHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);\n```\n上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候Home Indicator会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif)\n\n如果是feed流界面搭配酷一点的UI就会提高沉浸感，比如这样：\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif)\n\n有的人可能会问如果说点击的手势会触发它再次显示那我获取window上的交互每次在它即将显示的时候通过**setNeedsUpdateOfHomeIndicatorAutoHidden**在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。\n\n## 坑点\n\n需要注意的是：prefersHomeIndicatorAutoHidden和preferredScreenEdgesDeferringSystemGestures不可一起使用，如果一起使用的话后者是不生效的。\n","slug":"关于iPhone-X下Home键的隐藏和延迟响应","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lf001ca04ww8whl1ir","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"iOS-11通用相关\"><a href=\"#iOS-11通用相关\" class=\"headerlink\" title=\"iOS 11通用相关\"></a>iOS 11通用相关</h1><h2 id=\"Edge-Protect\"><a href=\"#Edge-Protect\" class=\"headerlink\" title=\"Edge Protect\"></a>Edge Protect</h2><p>iPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的“系统手势和App自带手势冲突”的问题也给出了相应的解决办法:</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg\" alt=\"\"></p>\n<p>虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 “edge protect” 因为进入App后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。</p>\n<a id=\"more\"></a>\n<p>根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发App的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。</p>\n<h2 id=\"API-Discussion\"><a href=\"#API-Discussion\" class=\"headerlink\" title=\"API Discussion\"></a>API Discussion</h2><p>根据官方文档找到对应的API</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller's screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (nullable UIViewController *)<span class=\"selector-tag\">childViewControllerForScreenEdgesDeferringSystemGestures</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application's preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UIRectEdge)<span class=\"selector-tag\">preferredScreenEdgesDeferringSystemGestures</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller's screen edges deferring system gestures have changed.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">setNeedsUpdateOfScreenEdgesDeferringSystemGestures</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br></pre></td></tr></table></figure>\n<h4 id=\"childViewControllerForScreenEdgesDeferringSystemGestures\"><a href=\"#childViewControllerForScreenEdgesDeferringSystemGestures\" class=\"headerlink\" title=\"childViewControllerForScreenEdgesDeferringSystemGestures\"></a>childViewControllerForScreenEdgesDeferringSystemGestures</h4><p>该方法是用来控制子试图控制器是否允许开发者控制edge protect的开启或是关闭。如果实现了这个方法并且返回值不为空那么子VC的edge protect设置就会遵循父VC的设置，跟随父VC是否延迟执行系统手势。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg\" alt=\"\"></p>\n<h4 id=\"preferredScreenEdgesDeferringSystemGestures\"><a href=\"#preferredScreenEdgesDeferringSystemGestures\" class=\"headerlink\" title=\"preferredScreenEdgesDeferringSystemGestures\"></a>preferredScreenEdgesDeferringSystemGestures</h4><p>该方法是设置edge protect的方法，返回值是一个边界的枚举</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">UIRectEdge</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeNone</span>   = 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeTop</span>    = 1 &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeLeft</span>   = 1 &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeBottom</span> = 1 &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeRight</span>  = 1 &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeAll</span>    = <span class=\"type\">UIRectEdgeTop</span> | <span class=\"type\">UIRectEdgeLeft</span> | <span class=\"type\">UIRectEdgeBottom</span> | <span class=\"type\">UIRectEdgeRight</span></span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE_IOS</span>(7_0);</span><br></pre></td></tr></table></figure>\n<p>因为不论我们从shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从iOS11开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于VC的左边界右滑动pop手势是无效的，也就是说这个pop手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。</p>\n<ul>\n<li><p>无限制</p>\n<p>当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于Tab.eView的scroll手势执行，虽说屏幕大部分的界面还是执行TableView手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li><p>Edge Protent</p>\n<p>在对应的ViewControll中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发App内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">UIRectEdge</span>)preferredScreenEdgesDeferringSystemGestures</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIRectEdgeAll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"setNeedsUpdateOfScreenEdgesDeferringSystemGestures\"><a href=\"#setNeedsUpdateOfScreenEdgesDeferringSystemGestures\" class=\"headerlink\" title=\"setNeedsUpdateOfScreenEdgesDeferringSystemGestures\"></a>setNeedsUpdateOfScreenEdgesDeferringSystemGestures</h4><p>这个方法是在应用内部动态控制edge protect，我们可以在上个方法中返回一个BOOL变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif\" alt=\"\"></p>\n<h1 id=\"iPhone-X使用相关\"><a href=\"#iPhone-X使用相关\" class=\"headerlink\" title=\"iPhone X使用相关\"></a>iPhone X使用相关</h1><p>iPhone X在系统手势上面交互和其他设备还是有一定区别的，因为加入了Home Indicator的原因，引入了新的手势，同时对以往的手势也做了相应的调整。</p>\n<h2 id=\"iPhone-X-Edge-Protect\"><a href=\"#iPhone-X-Edge-Protect\" class=\"headerlink\" title=\"iPhone X Edge Protect\"></a>iPhone X Edge Protect</h2><p>在iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被Home Indicator占用。其实Edge Protect在这里依然适用，只是对于Home Indicator的手势有一个小插曲。正常来说他在底部，就应该受到UIRectEdgeBottom 或者是 UIRectEdgeAll控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在iPhone X刚发布我就试图去处理交互问题，因为海报工厂并没有传统的UITabBarController，且里面所有的tableView都是直通到底，但是始终都无法延迟执行与Home Indicator相关的任何手势。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg\" alt=\"\"></p>\n<p>后来看了其他游戏，视频类App在iPhone X上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年1月25日苹果推送了iOS 11.2.5的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的Home Indicator当你一段时间不去触碰它的时候由黑色或者白色(根据当前的屏幕显示的内容来决定)变成非常透明的灰色，当你第一次进行操作会默认执行App内手势，同时激活Home Indicator，短时间内进行第二次操作就可以返回桌面</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif\" alt=\"\"></p>\n<p>一开以为是有新的API出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的edge protect 代码运行后确实可以达到效果。对于视频，游戏等App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括Gameloft出品的游戏都没做相应的处理。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif\" alt=\"\"></p>\n<h2 id=\"iPhone-X-Home-Indicator-Hidden\"><a href=\"#iPhone-X-Home-Indicator-Hidden\" class=\"headerlink\" title=\"iPhone X Home Indicator Hidden\"></a>iPhone X Home Indicator Hidden</h2><p>如果说上面的Edge Protect适合在游戏中使用，那么Home Indicator Hidden则更适合在非游戏环境下增强App的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个API，和Edge protect的用法完全一样。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller's home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (nullable UIViewController *)<span class=\"selector-tag\">childViewControllerForHomeIndicatorAutoHidden</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application's preferred home indicator auto-hiding when this view controller is shown.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (BOOL)<span class=\"selector-tag\">prefersHomeIndicatorAutoHidden</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller's home indicator auto-hiding have changed.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">setNeedsUpdateOfHomeIndicatorAutoHidden</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br></pre></td></tr></table></figure>\n<p>上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候Home Indicator会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif\" alt=\"\"></p>\n<p>如果是feed流界面搭配酷一点的UI就会提高沉浸感，比如这样：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif\" alt=\"\"></p>\n<p>有的人可能会问如果说点击的手势会触发它再次显示那我获取window上的交互每次在它即将显示的时候通过<strong>setNeedsUpdateOfHomeIndicatorAutoHidden</strong>在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。</p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>需要注意的是：prefersHomeIndicatorAutoHidden和preferredScreenEdgesDeferringSystemGestures不可一起使用，如果一起使用的话后者是不生效的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"iOS-11通用相关\"><a href=\"#iOS-11通用相关\" class=\"headerlink\" title=\"iOS 11通用相关\"></a>iOS 11通用相关</h1><h2 id=\"Edge-Protect\"><a href=\"#Edge-Protect\" class=\"headerlink\" title=\"Edge Protect\"></a>Edge Protect</h2><p>iPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的“系统手势和App自带手势冲突”的问题也给出了相应的解决办法:</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo8u9uqjehj31kw0t7h2q.jpg\" alt=\"\"></p>\n<p>虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 “edge protect” 因为进入App后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。</p>","more":"<p>根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发App的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。</p>\n<h2 id=\"API-Discussion\"><a href=\"#API-Discussion\" class=\"headerlink\" title=\"API Discussion\"></a>API Discussion</h2><p>根据官方文档找到对应的API</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller's screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (nullable UIViewController *)<span class=\"selector-tag\">childViewControllerForScreenEdgesDeferringSystemGestures</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application's preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UIRectEdge)<span class=\"selector-tag\">preferredScreenEdgesDeferringSystemGestures</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller's screen edges deferring system gestures have changed.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">setNeedsUpdateOfScreenEdgesDeferringSystemGestures</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br></pre></td></tr></table></figure>\n<h4 id=\"childViewControllerForScreenEdgesDeferringSystemGestures\"><a href=\"#childViewControllerForScreenEdgesDeferringSystemGestures\" class=\"headerlink\" title=\"childViewControllerForScreenEdgesDeferringSystemGestures\"></a>childViewControllerForScreenEdgesDeferringSystemGestures</h4><p>该方法是用来控制子试图控制器是否允许开发者控制edge protect的开启或是关闭。如果实现了这个方法并且返回值不为空那么子VC的edge protect设置就会遵循父VC的设置，跟随父VC是否延迟执行系统手势。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo917ycqy6j319i0bqjtr.jpg\" alt=\"\"></p>\n<h4 id=\"preferredScreenEdgesDeferringSystemGestures\"><a href=\"#preferredScreenEdgesDeferringSystemGestures\" class=\"headerlink\" title=\"preferredScreenEdgesDeferringSystemGestures\"></a>preferredScreenEdgesDeferringSystemGestures</h4><p>该方法是设置edge protect的方法，返回值是一个边界的枚举</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">UIRectEdge</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeNone</span>   = 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeTop</span>    = 1 &lt;&lt; 0,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeLeft</span>   = 1 &lt;&lt; 1,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeBottom</span> = 1 &lt;&lt; 2,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeRight</span>  = 1 &lt;&lt; 3,</span><br><span class=\"line\">    <span class=\"type\">UIRectEdgeAll</span>    = <span class=\"type\">UIRectEdgeTop</span> | <span class=\"type\">UIRectEdgeLeft</span> | <span class=\"type\">UIRectEdgeBottom</span> | <span class=\"type\">UIRectEdgeRight</span></span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE_IOS</span>(7_0);</span><br></pre></td></tr></table></figure>\n<p>因为不论我们从shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从iOS11开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于VC的左边界右滑动pop手势是无效的，也就是说这个pop手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。</p>\n<ul>\n<li><p>无限制</p>\n<p>当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于Tab.eView的scroll手势执行，虽说屏幕大部分的界面还是执行TableView手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo909u85fpg308k0goe8d.gif\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li><p>Edge Protent</p>\n<p>在对应的ViewControll中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发App内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">UIRectEdge</span>)preferredScreenEdgesDeferringSystemGestures</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIRectEdgeAll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo90rfo0dig308k0go7wu.gif\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"setNeedsUpdateOfScreenEdgesDeferringSystemGestures\"><a href=\"#setNeedsUpdateOfScreenEdgesDeferringSystemGestures\" class=\"headerlink\" title=\"setNeedsUpdateOfScreenEdgesDeferringSystemGestures\"></a>setNeedsUpdateOfScreenEdgesDeferringSystemGestures</h4><p>这个方法是在应用内部动态控制edge protect，我们可以在上个方法中返回一个BOOL变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo912yvhsag308k0goe8h.gif\" alt=\"\"></p>\n<h1 id=\"iPhone-X使用相关\"><a href=\"#iPhone-X使用相关\" class=\"headerlink\" title=\"iPhone X使用相关\"></a>iPhone X使用相关</h1><p>iPhone X在系统手势上面交互和其他设备还是有一定区别的，因为加入了Home Indicator的原因，引入了新的手势，同时对以往的手势也做了相应的调整。</p>\n<h2 id=\"iPhone-X-Edge-Protect\"><a href=\"#iPhone-X-Edge-Protect\" class=\"headerlink\" title=\"iPhone X Edge Protect\"></a>iPhone X Edge Protect</h2><p>在iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被Home Indicator占用。其实Edge Protect在这里依然适用，只是对于Home Indicator的手势有一个小插曲。正常来说他在底部，就应该受到UIRectEdgeBottom 或者是 UIRectEdgeAll控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在iPhone X刚发布我就试图去处理交互问题，因为海报工厂并没有传统的UITabBarController，且里面所有的tableView都是直通到底，但是始终都无法延迟执行与Home Indicator相关的任何手势。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo920zedwnj308w0j9gxa.jpg\" alt=\"\"></p>\n<p>后来看了其他游戏，视频类App在iPhone X上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年1月25日苹果推送了iOS 11.2.5的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的Home Indicator当你一段时间不去触碰它的时候由黑色或者白色(根据当前的屏幕显示的内容来决定)变成非常透明的灰色，当你第一次进行操作会默认执行App内手势，同时激活Home Indicator，短时间内进行第二次操作就可以返回桌面</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo935pn8dsg30go07s1l2.gif\" alt=\"\"></p>\n<p>一开以为是有新的API出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的edge protect 代码运行后确实可以达到效果。对于视频，游戏等App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括Gameloft出品的游戏都没做相应的处理。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo943bx7sog308h0gox6z.gif\" alt=\"\"></p>\n<h2 id=\"iPhone-X-Home-Indicator-Hidden\"><a href=\"#iPhone-X-Home-Indicator-Hidden\" class=\"headerlink\" title=\"iPhone X Home Indicator Hidden\"></a>iPhone X Home Indicator Hidden</h2><p>如果说上面的Edge Protect适合在游戏中使用，那么Home Indicator Hidden则更适合在非游戏环境下增强App的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个API，和Edge protect的用法完全一样。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Override to return a child view controller or nil. If non-nil, that view controller's home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (nullable UIViewController *)<span class=\"selector-tag\">childViewControllerForHomeIndicatorAutoHidden</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controls the application's preferred home indicator auto-hiding when this view controller is shown.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (BOOL)<span class=\"selector-tag\">prefersHomeIndicatorAutoHidden</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This should be called whenever the return values for the view controller's home indicator auto-hiding have changed.</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">setNeedsUpdateOfHomeIndicatorAutoHidden</span> <span class=\"selector-tag\">API_AVAILABLE</span>(ios(<span class=\"number\">11.0</span>)) <span class=\"selector-tag\">API_UNAVAILABLE</span>(watchos, tvos);</span><br></pre></td></tr></table></figure>\n<p>上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候Home Indicator会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo94hujx35g308h0go4qy.gif\" alt=\"\"></p>\n<p>如果是feed流界面搭配酷一点的UI就会提高沉浸感，比如这样：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo94p0bmoqg308h0gox6t.gif\" alt=\"\"></p>\n<p>有的人可能会问如果说点击的手势会触发它再次显示那我获取window上的交互每次在它即将显示的时候通过<strong>setNeedsUpdateOfHomeIndicatorAutoHidden</strong>在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。</p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>需要注意的是：prefersHomeIndicatorAutoHidden和preferredScreenEdgesDeferringSystemGestures不可一起使用，如果一起使用的话后者是不生效的。</p>"},{"title":"可能是最全的使用HEXO搭建个人博客教程","date":"2018-01-25T07:43:15.000Z","comments":1,"_content":"## 背景\n\n作为一个开发者不能没有博客，最近花了几天的时间搭建了这个博客，处理了很多细节，在这篇文章中我会把我从开始到现在以及后续的优化整理出来，帮助更多的人搭建、维护、更新、自己的博客。\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fnsy5fhyhsj31hc0xchdt.jpg)\n\n一开始我所有的博客都写在新浪微博，因为微博上更容易推广自己的文章，微博用户量大，但是后来微博的弊端慢慢的显示出来了，毕竟不是开发者的天地，我的博客中经常会插入大量的代码，而微博不支持markdown编辑，普通的编辑器对代码块的兼容性非常差，别说高亮了，有时候排版都会错乱，最后外观很不好看，如下图：\n\n<!--more-->\n\n![微博代码](https://ws4.sinaimg.cn/large/006tNc79ly1fnsxwzb745j31i20tuad4.jpg)\n\n而且微博的账号系统也存在一定的弊端，所以后来转向简书、掘金等技术平台，不得不承认相对于微博来说这些平台对开发者就要友好多了，不过后来又发现一个问题。因为我在写文章的时候使用的是本地的markdown编辑器，而这些平台对markdown语法的一些小细节并不严谨或者说统一如下图：\n\n\n![简书VS掘金](https://ws3.sinaimg.cn/large/006tNc79ly1fnsy0p6no4j316q0nsn2v.jpg)\n\n两个平台的编辑器无法做到统一，以至于每次写完文章都需要针对两个平台做不同的修改。\n\n综上所述，最简单的也最一劳永逸的方法就是搭建自己的博客平台，而HEXO很好的帮我们解决了这个问题，其实对于一个开发者来说并不是什么难事，整个流程对于大部分有代码基础的开发者来说一上午时间就可以搞定，不过最难的也是最头痛的就是对细节的调整，对UI的修改、优化等，不过本文会对此逐一讲解。\n\n## 环境配置\n\n\n* [Node.js](https://nodejs.org/en/)\n\n cURL:\n\n `$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n`\n\n Wget:\n\n `$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n`\n\n 安装完成后，重启终端并执行下列命令即可安装 Node.js。\n\n `$ nvm install stable`\n\n\n* [Git](https://git-scm.com/)\n\n 一般的开发者不会没有这个吧，我是安装Xcode就会有这个了，\n\n 使用 Homebrew, MacPorts ：brew install git;或下载 [安装程序](https://sourceforge.net/directory/) 安装\n\n* [bitbucket](https://bitbucket.org/)账号\n\n 一般都会使用HEXO+GitHub page的形式搭建自己的博客，但是这里有个问题就是GitHub是开源的，任何人都能在上面看到你的源代码，虽然这并没有什么太大的影响，不过对于我来说感觉怪怪的，所以我就用了bitbucket page来处理我的博客，所有的东西都一样只不过这个是个私有库罢了（免费五个人）\n\n ![](https://ws3.sinaimg.cn/large/006tNc79ly1fnt1nn8k9uj30b308amye.jpg)\n\n\n## 开始建站\n\n#### 第一步：创建仓库\n\n进入github/bitbucket（后续都以github为例）新建repo，这里要注意repo的名字一定要满足`your Account Name`/github.io。如果是bitbucket那就是`your Account Name`/bitbucket.io，因为只有这样的仓库名称最后才能以静态页面展示。如图：XXX的内容一定要与红色的框里的文本一致。\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fntzjgvzvyj30q006nmy0.jpg)\n\n#### 第二步：创建本地文件夹\n\n创建文件夹之后CD到你创建的文件夹中执行hexo的初始化相关命令\n\n```\n$ hexo init\n$ npm install\n```\n\n执行完毕之后你的文件夹里就有内容了，标准的目录结构是这样（只列出几个必要的文件夹及其子目录）\n\n```\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n * _config.yml：\n 其中我们以后的大部分操作都会在`_config.yml`中进行，这个文件是我们的站点的配置文件。\n\n * scaffolds：\n 模板文件，规定了我们创建一篇文章的时候最开始的样子，\n\n * source：\n 可以暂时的理解成我们文章的存放处\n\n * themes：\n 主题文件\n\n#### 第三步：部署到Git\n\n修改我们的的站点配置文件`_config.yml`中如下字段\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fntzzwn8dkj30w0058wga.jpg)\n其中：\n  * `type`值对应的是你所部署的的服务器类型，我们这里填写git就可以。\n\n  * `repo`是你的仓库地址，也就是仓库克隆的地址，推荐用https的链接。\n\n  * `branch`不写默认是master，通常我们写成master就可以。\n\n以上配置完成后保存 然后回到终端执行`npm install hexo-deployer-git --save`安装一个插件，这样才能将你写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)\n  * `hexo clean`  清理缓存  \n\n  * `hexo generate` 进行渲染 简写 `hexo g`\n\n  * `hexo server` 部署到本地(调试使用) 简写 `hexo s`。然后浏览器输入 `http://localhost:4000` 就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得 `control + C` 关闭本地端口，不然下次就进不去啦)\n\n  * 调试完毕后使用 `hexo deploy` 简写为 `hexo d`来部署到git服务器。\n\n执行完以上操作后打开浏览器地址了输入`http://你github名字.github.io`就可以看看到效果啦，这回是所有人都能看到的，用手机也可以。至此第三步已经完成,最终的结果如下图：\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu0jxw383j310l0gcdrk.jpg)\n\n#### 第四步：写文章\n\n使用如下命令 `hexo new post “文章名字”` 就可新建文章啦，建立好的文章在 `source/_posts` 中，你可以用markdown语法编辑内容就可以。编辑完成后执行第三步中终端的操作就可以啦，刷新下浏览器就可看到你的新文章啦。如下图:\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu0ml6lp4j310n0g9tjv.jpg)\n\n## 个性化\n\n#### 一：主题\n\n###### 获取\n\n主题是我么个性化的基础和前提，我们想做任何个性化上的修改基本上都是在我们主题上的修改，先找到一个自己满意的主题是首要任务。关于主题网上有很多很多，[HEXO官方的主题目录](https://hexo.io/themes/)也收录了好多来着世界各地开发者的主题。或者开发者也可以直接去网上搜索HEXO theme关键字来获取主题。\n\n###### 安装\n\n主题一般都是repo，只要讲起clone到博客目录themes/XXXX下就可了，XXXX对应的就是你给主题起的名字，像这样：`git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet` 这样就可以保证每次主题的作者有更新了我们就可以 pull获取更新。不过这样有个问题后面我会在HEXO多终端同步一栏讲到，所以这里我们选择另一种方式去安装，就是直接把主题的repo下载下来\n然后解压放到themes中。其实对于已经稳定的主题作者一般不会频繁更新，不稳定的主题我们也不会用，所以用后者安装也是一样的。\n\n然后我们回到刚才的站点配置文件中`_config.yml`修改如下字段，对应的名字就是你刚才那个主题文件夹的名字：我这边是next，\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fnu5dr697rj312006a0tp.jpg)\n\n然后保存，再去终端执行那三步，接着刷新网页就可以看到新的界面啦。下面是我换了NEXT主题刷新后的效果。因为该注意已经非常完善，所有后续用该主题做例子来讲\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu5ohsltng30go097e83.gif)\n\n#### 二：主题菜单\n\n###### 添加按钮\n\n主题菜单也可以说是主题按钮。也就是上面顶部的两个，next主题默认的两个是Home、Archive，我们一般会加上tag about category等。这些都是需要在主题上进行修改，我们需要修改主题的配置文件，首先在主题的文件夹下找到`_config.yml`文件，没错和之前的站点配置文件同名，只不过他们的路径不同，大家千万不要弄混，站点配置文件是配置站点通用的东西，而主题配置文件是配置一些主题的元素。在主题配置文件找到menu字段\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu69gaksbj312s0cijtz.jpg)\n\n可以看到主题作者注释掉了一部分按钮只保留了两个最基本的，这里需要注意前面的Key并不是代表的是按钮名字，因为该主题是支持多语言，所以这个key只是个标识，具体的按钮名字要去该路径下查找\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu6e4quu7j30fa0zkwgi.jpg)\n\n其中每一个文件对应了不同的语言，我们以汉语为例，进入`zh-Hans.yml`中修改这些字段\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fnu6fypjr7j30ay054wes.jpg)\n\n其中key就是之前我们在主题配置文件中的key，而后面的value则是简体中文状态下按钮的名字。修改完成后我们保存执行那三步就可以看到我们新添加的按钮了。\n\n###### 添加页面\n\n添加按钮后我们需要点击按钮显示统一的页面。这时候我们需要添加页面。以tag页面为例，hexo中添加页面的命令是`hexo new page XXXXX` 后面XXX则是要添加页面的名称，我们这里写tags。为了测试新建的tag页面我们对之前的页面添加个tag。去 source/_post中找一篇文章我们在开头添加如下字段,多标签以此类推\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fnu6nmt2ywj30v00f4jsi.jpg)\n\n然后编辑我们刚才生成的tag页面(`source/tags/index.md`)指定其type为tags\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu6q39ak4j310y09e3zb.jpg)\n\n然后保存执行那三步就会有如下效果\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fnu6vtcn1og30gn07fhe0.gif)\n\n点击对应的tag即可跳转到改tag所对应的文章。其他页面同理。\n\n#### 三：添加阅读更多button\n\n我们在首页的时候其实就是我们的文章列表，但是这时候有个问题，如果我们某一篇或者某几篇文章很长，那首页是不是更长呢？其实在首页我们可以只显示文章部分内容，通过点击阅读更多按钮来进入文章详情。这个时候就需要截断文章。我们在文章的合适地方采用`<!--more-->`来截断,用默认文章来看\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu73u6xghj313o0hujuz.jpg)\n\n然后执行那三步就会如下效果\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu75xee1rj31kw0iomzf.jpg)\n\n点击阅读更多。\n\n#### 四：更改主题背景\n\n首先找到如下路径 `themes\\next\\source\\css_custom\\custom.styl` 会发现里面是空的，这个文件是Next主题为我们预留的做一些自定的css样式的地方，我们添加如下代码。\n\n```\n//背景图片相关\n@media screen and (min-width:1200px) {\n\n    body {\n    background-image:url(/images/bg.jpg);\n    background-repeat: no-repeat;\n    background-attachment:fixed;\n    background-position:50% 50%;\n    background-size: cover\n    }\n\n    #footer a {\n        color:#eee;\n    }\n}\n```\n这里大家应该就可以看出括号里面的图片路径就是我们的背景图片，我们只需把图片放入 `themes\\next\\source\\images` 中即可，记住图片名字要写对，要有后缀。同理括号里面我们可以直接放一个图片的链接比如 `https://tpc.googlesyndication.com/simgad/6893153702744595670` 做完这些操作保存，然后执行那三步即可看到效果，不过可能浏览器有缓存，可以清理下缓存再刷新看看。\n\n#### 五：修改博客背景透明度\n\n既然再上一步中修改了背景图片，如果被NExt本身的白色挡住确实不好看，我们可以尝试把本身的白色背景变成透明的，这样会美观很多，同样还是修改刚才的文件 `themes\\next\\source\\css_custom\\custom.styl` 在上一步的基础上我们可以添加如下代码\n ```\n //改变背景色和透明度\n .main-inner {\n     background: #fff;\n     opacity: 0.9;\n }\n ```\n 其中第一个属性为颜色值，第二个属性就是我们的透明度啦。适当修改，不然会适得其反连字都看不清啦。做完上两步就是我的这个博客的效果。\n\n #### 六：修改作者头像为圆形，\n\n 我们默认是方形的头像，想修改为圆形的话同样是上两步的那个路径下添加如下代码\n ```\n .site-author-image {\n   border-radius: 100%;\n   padding: 2px;\n   border: 2px dashed #fff;\n   animation: cycle 2s 0.5s forwards;\n   transition: border-radius 2s;\n }\n ```\n 保存 -> 三步 即可看到效果\n\n ![](https://ws2.sinaimg.cn/large/006tKfTcly1fnxgsh0p7bj308e06jq3t.jpg)\n\n #### 七：添加背景动画\n\n 背景动画使用Js来处理，会JS的同学可以自己写喜欢的动画，我这边就用了网上比较通用的动画。找到以下路径 `themes\\next\\layout\\_layout.swig` 在文章 `</body>`的上面添加如下代码\n ```\n <script type=\"text/javascript\"\n color=\"255,255,255\" opacity='1' zIndex=\"-2\" count=\"100\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"></script>\n {% endif %}\n\n ```\n 然后 保存 -> 三步即可看到效果 其中src为JS的路径，有兴趣的可以自定义效果。\n\n #### 八：添加评论页面\n\n HEXO的评论页面官方推荐了disqus，无奈已经被墙，即使开发时候自己有克服的方法但是也不能保证所有看你博客的人都有克服的方法。所有我们打算采用其他的的一些第三方来实现，首先先对市面上的几个产品做下对比：\n\n###### 比较：\n* disqus\n\n 比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。暂不考虑\n\n* 多说\n国内比较出名的评论系统，已经关闭服务暂不考虑。\n\n* gitment\n一款基于github issue的评论系统，风格很像github，只是目前还不是太稳定，且界面无法自定，可能会于博客有些不协调。而且评论需要github账号\n\n* livere\n中文名字叫来必力，是一款韩国的评论系统，在不带有任何民族情感的前提下来看确实棒子的东西还是不错的，也是我目前在使用的一款，我主要用它的原因有几点\n  * 支持很多种格式的评论导入，你可以很方便的吧之前在其他平台上的评论数据导入进来，支持多种json格式。\n\n  * 简介的UI提供多种主题。\n\n  * 国外的东西不受国内的限制。\n\n###### 集成：\n先去[livere的官网](https://livere.com)注册m，具体过程我就不讲了，一步一步安她的来就行，之后他会给你一个安装代码，像这样：\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnxhkvhulnj30pt0ikq5e.jpg)\n\n里面主要的信息就是data-uid。\nNEXT主题本身是已经集成了livere评论的，只不过被注释掉了。找到主题配置文件 `_config.yml` 找到如下代码\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fnxhhj8slmj312o06kmyi.jpg)\n\n打开注释填入你在livere中注册后它给你的UID即可。然后 保存 -> 三步即可。\n\n## 九：多终端操作\n\n#### 背景\n\n大家都知道HEXO是静态博客，所有的页面都是静态的通过本地文件渲染然后再部署上去，这就带来一个多终端部署的问题，比如公司电脑配置好了，想回家在进行写作，发现家里什么都没有还需要重新配置环境，不过这倒是次要，关键是如果不能保证两个终端的内容完全一样就会造成服务器上的数据会被最后一次部署覆盖，导致前几次的都被覆盖掉。\n\n#### 解决\n\n其实大家应该也看出HEXO整体的一套流程下来就是git的工作流程，不管你用github还是bitbucket都是遵循gitflow的，而gitflow就是一种多终端多人协同工作的解决方案。所以我们可以用它来解决多终端同步的问题。\n\n#### 流程\n\n我们先来了解下hexo的整体流程。我们正常的为文件夹结构如图：\n\n ![](https://ws3.sinaimg.cn/large/006tNc79ly1fnyf572x8nj30bu0fqgn0.jpg)\n\n###### 第一步：hexo g\n\n source文件夹下存放着我们的文章，tag、归档之类的信息，也就是我们的博客的内容。当我们在终端执行 `hexo g` 的时候会被source中的文件按照某种规则方式渲染成静态的页面文件放到public中：\n\n ![](https://ws3.sinaimg.cn/large/006tNc79ly1fnyf8eyhjdj30mw0e876h.jpg)\n\n###### 第二步：hexo d\n\n 然后我们执行 `hexo d` 这一步暂时我们可以认为就是对public中的文件进行push到我们的git仓库的过程。所以在我们的仓库中 `XXXXXX.bitbucket.io` 大家看到的文件只有public中的文件。\n\n###### 附加：hexo clean\n\n 其实这一步是和gitflow没有关系的，但是既然讲到流程我这边也在说下，之前说过这步是用来清理缓存的，其实他的作用是运行在第一步之前，将整个public文件删除，然后我们再执行 `hexo g` 重新渲染进public，之后再 `hexo d` 进行部署，这样就避免之前的内容对我们造成影响。\n\n\n#### 具体操作\n\n 通过上一步流程我们知道如果git服务器上只有public是不够的，我们需要有我们整个博客文件夹下的所有文件才能进行多终端操作。所有这边有两个方法：\n * 新建另一个仓库我们暂时命名为MyProject，把我们所有的文件传到这个Git仓库上，当我们换另一台电脑时候我们直接拉这个新仓库的代码然后进行写作 -> 三步走最后在将所有文件推到MyProject以后所有的git操作都在这个仓库中进行。\n\n * git给我们提供了多分支操作，我们可以做xxxx.github.io这个仓库中创建一个新的分支暂时命名为hexo分支，这个分支的作用和上一个方法里MyProject的作用以及里面的文件一模一样，只不过我们这个方法就省的我们再创建一个仓库了。以后所有的git操作都去这个分支进行，本地的文件一直保持在这个分支就行，不过有一点需要注意的就是，即使所有的操作都在hexo分支下进行也必须保证master分支为主分支(default branch)，不然你就打不开你的博客了。\n\n 以上两种都是属于基本的git操作，本文不再赘述。不过有一点这里要强调下，还记一开始我跟大家说的主题的是推荐大家直接去主题所在的repo下载zip然后解压拖进博客目录里面吗？如果你不是拖拽进来的而是clone下来的话在这一步你会涉及到git的 add submodule操作。其实操作不难，具体的命令网上也是大把。不过如果你像我一样使用bitbucket的话可能发现无法进行submodule操作，不知道这个是bitbucket的BUG还是什么其他原因，同样的命令使用github托管博客的时候是没有问题的，而bitbucket就不行，当你使用另一台电脑的进行拉去的时候执行 `git submodule init` 操作的时候他会提示找不到。至今未解决，如果哪位大神有什么方法及时联系我。\n\n## 十：绑定个人域名\n\n#### <font color=red>注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明</font>\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7pq9gdqzj31a20psaf0.jpg)\n\n#### 准备工作\n\n在github上创建仓库，仓库的名字为 username.github.io。然后修改站点配置文件中部署地址（repo对应的字段），将原本的bitbucket的仓库地址改为github的地址\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7pve5iwgj312u0a0401.jpg)\n\n之后进行保存然后三步走，部署成功后你的博客就从bitbucket上迁移到github中了，这样一来，你整体的博客仓库还是在bitbucket中的私有库中，但是public文件夹中的公开文件已经被你部署到github的仓库中。该保密的信息仍然保密，同时也不影响你绑定自己的域名，一举两得。正常情况下按照上面步骤完成后的博客地址是 xxx.github.io，下面就开始绑定自己的域名。\n\n#### 域名购买\n\n这个渠道有很多，我就不再一一赘述，我这边以[阿里云的万网域名购买](https://wanwang.aliyun.com/domain/searchresult/?keyword=nihyao&suffix=.cn&domaintype=zh%2Cen#/?keyword=test&suffix=cn)为例,找到合适自己的域名\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7pjuuq4mj313u0hkqdt.jpg)\n\n#### 域名解析\n\n购买域名并且按照他的步骤实名认证之后，需要把域名解析到我们的博客中，在阿里云的控制台找到域名右侧对应的解析按钮。点击然后添加解析\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7q32hh49j31800h5ae1.jpg)\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7q3yyhfij31780anq46.jpg)\n\n然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7q5sss5oj30kr0bkq3n.jpg)\n\n之后记得启用该记录，不过如果你像我一样是阿里云购买并且配置的话是不需要启用的，默认帮你启用。\n\n#### 仓库配置\n\n然后回到你的github仓库，进入你的仓库设置页面，找到如下字段，在红框处添加你的域名，然后保存即可\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7qbo2111j30t10i7goa.jpg)\n\n#### 博客配置\n\n回到你的博客目录，在source目录下创建一个<font color=red>不带任何后缀的</font>文件，命名为 CNAME，里面填写你的域名，我是这样，只添加你的域名不要添加其他东西。然后保存 执行三步之后就可以通过你的域名访问你的博客啦，如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以了。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7qe2vzuzj30s202ydfw.jpg)\n\n## 十一：实现https协议\n\n按照以上步骤完成后可以通过域名访问，但是有个问题就是如果你用谷歌浏览器或者Safari，他就会提示你网站不被信任，只有你点击仍要继续才会展示你的博客，并且地址栏里面还是有个红色的×，虽说不影响使用和阅读，但是还是感觉别扭，这次我们来讲如何将自己的博客协议改为Https。这里有几种方法：\n\n* 购买证书\n\n* 使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制\n\n* 使用CDN进行反向代理\n\n如果使用上两步的话基本上证书的服务商都会告诉你如何配置，他们的文档讲的一定比我的详细，不过主要原因是我们使用的github Page是不支持上传证书的，所以这里主要说下第三步，通过CDN配置反向代理，这里就需要用到一个国外的CDN服务提供商[Cloudflare](https://www.cloudflare.com/):\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7utpfih2j30wz07mju7.jpg)\n\n#### 原理\n\n[Cloudflare](https://www.cloudflare.com/) 提供DNS解析服务，而且速度很快，在阿里云半个小时才能生效的解析在它这里瞬间就生效，它提供了免费的https服务(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7v9apbogj30t004ydg6.jpg)\n\n用户看到的小锁其实是用户连接到Cloudflare的证书，而由Cloudflare到github是没有https的，不过对于我们静态博客已经够了。\n\n#### 配置\n\n###### 第一步：\n\n还是先去官网注册，然后添加你的域名，注意添加的是你购买的域名。\n\n###### 第二步：\n\n进入DNS解析界面填入如下解析，因为我们使用clouldflare做DNS解析所以一会我们需要把我们购买域名的那个地方的解析删掉。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7vibz0a6j30rv0kagns.jpg)\n\n其中前两个是使你的域名指向github的服务器地址，github文档中给的就是这个两个地址，最后那个CNAME记录指向的是你的github仓库域名username.github.io。一定要严格按照这个来配置。\n\n###### 第三步：\n\n记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把你域名购买处（我的是阿里云）的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为我们以后就靠clouleflare来解析DNS啦。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7vnm5itzj30qy03c74a.jpg)\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7vqjin22j316i0ib77n.jpg)\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7vse0wewj316u09tmys.jpg)\n\n###### 第四步：\n\n回到clouldflare 上面选择crypto选项然后下面选择full或者是Flexible\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7vwnoasij30wx0f8myk.jpg)\n\n选项中几个的区别如下图\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7vxck29zj30k00cv0sp.jpg)\n\n最后那个是需要证书支持的。然后滚动到下面打开always use HTTPS开关\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7vy66223j30rn06dwet.jpg)\n\n###### 第五步：\n\n以上步骤配置好之后基本就完成了，但是如果直接有人在地址栏里面输入http://XXXXX 进入你的博客的话你这边还是会出现非Https的效果，所以我们这里要做一个强制跳转。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7w1ksr94j30uu0ir76a.jpg)\n\n这样就万无一失了。\n\n###### 坑点：\n\n我之前按照以上步骤操作完成后发现首页虽然是https了也不显示红叉了，但是也没有显示绿色的小锁，而是一个叹号，但是有些博文页面可以正常显示https绿锁。后来发现是因为当前页面中有非https的链接导致，比如图片图床不是https的，或者评论插件不支持https，不过我博客中使用的来必力评论是支持https，只是我当时的图床无都是http所以只能是显示叹号了，后来把所有图片图床换成https的就好啦。\n\n## 十二：为博客添加音乐\n\nHEXO博客添加的音乐的地方有两个。一个个首页侧边栏，另一个是每个页面里面。但是个人觉得添加侧边栏里面并不好，因为添加侧边栏的话用户只有在浏览你首页的时候才能听到音乐，而且期间不能点击任何站内链接，否则音乐就会中断，试想下，一般首页都是文章列表，点击文章里面之后才是正文，所以用户在首页停留的时间很短，基本上找到自己想看的文章就会马上点进去看，所以这里放音乐没有太大意义；而页面内插入音乐会更好点，读者可以一边浏览文章一边听音乐，这也正是我们想要的。不过解决前者问题的办法也不是没有，比如点击链接的话直接开另一个浏览器标签来打开新页面也可以做到不中断音乐，但是总觉得有点小题大做了。总不能读者看个你的博客而占用了一堆标签。\n\n#### 网易云音乐外链\n\n这个是最简单的方法，通过网易云音乐官网生成播放器外链。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fordugrc80j315s0swthy.jpg)\n\n可以自己配置一些属性，然后自动生成配置代码，放到你的博客里面就行啦，粘贴到你文章中想要的地方\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1forduyu7laj31hm0zkaft.jpg)\n\n优点缺点截图上也有，不过网上也说这样的方式会影响SEO，具体什么原理也不太清楚。总之简单便捷，不过网易的logo去不掉。\n\n#### [aplayer](https://aplayer.js.org/docs/#/?id=options)添加音乐\n\n这个算是HEXO最常用也是最出名名的播放器了，还有Dpleyer是用来视屏播放的，暂时我们不说。首先需要安装aplayer依赖，终端中切换到你的博客根目录执行 `npm install aplayer --save` 安装成功后就可以了。参数就不给大家一一讲解了，官方文档都有，我这里只提供一个例子。\n\n###### 页面中添加音乐\n\n```\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"에필로그 (Epilogue)\",\n            \"author\": \"이동준\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\n            \"lrc\": \"https://歌词.lrc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n\n```\n以上代码插到文章中任意一个你想的地方就可以\n\npic就是歌曲显示图片的链接。大家可以看到music是个数组，所以想添加列表的话就在数组中再添加个歌曲字典就好了。建议歌词lrc要用URL形式，不然txt格式可能要编辑死。。好多人问歌曲的MP3外链从哪里来。这个其实很简单，首先把歌曲下载下来然后上传到七牛云就可以在七牛云生成外链啦，七牛云有免费的存储空间，只存歌曲的话足够啦。歌词URL\n\n###### 侧边栏中添加音乐\n\n其实之前讲过，不建议在侧边栏中添加，但是这里还是简单介绍下。首先要做的是在`node_modules` 目录下找到 `APlayer.min.js` 文件，将其复制到 `theme/next/source/js/src/` 目录下。然后打开 `theme/next/layout/_custom/` 文件夹下的 `sidebar.swig` 文件，向其中添加以下代码：\n\n```\n<div id=\"player1\" class=\"aplayer\"></div>\n<script src=\"/js/src/APlayer.min.js\"></script>\n<script type=\"text/javascript\">\nvar ap = new APlayer({\n    element: document.getElementById('player1'),                       // Optional, player element\n    narrow: false,                                                     // Optional, narrow style\n    autoplay: false,                                                    // Optional, autoplay song(s), not supported by mobile browsers\n    showlrc: 0,                                                        // Optional, show lrc, can be 0, 1, 2, see: ###With lrc\n    mutex: true,                                                       // Optional, pause other players when this player playing\n    theme: '#e6d0b2',                                                  // Optional, theme color, default: #b7daff\n    mode: 'random',                                                    // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`\n    preload: 'metadata',                                               // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'\n    listmaxheight: '513px',                                             // Optional, max height of play list\n    music: [\n    {                                                           // Required, music info, see: ###With playlist\n        title: 'Sometimes When We Touch',                                          // Required, music title\n        author: 'Oliveia',                                              // Required, music author\n        url: 'https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/SometimesWhenWeTouch.mp3',  // Required, music url\n        pic: 'https://y.gtimg.cn/music/photo_new/T002R300x300M000003LIDEL0NQInJ.jpg?max_age=2592000',  // Optional, music picture\n        lrc: 'https://歌词.lrc'                   // Optional, lrc, see: ###With lrc\n    },\n    {\n        \"title\": \"大鱼\",\n        \"author\": \"周深\",\n        \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\n        \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\n        \"lrc\": \"https://歌词.lrc\"\n    }\n    ]\n});\n</script>\n\n```\n只是换成了JS的语法，其实原理，参数都一样。然后执行三步走就可以看到啦，注意有浏览器缓存，所以多刷新几次就会有了。\n\n###### 歌词、音乐外链相关\n\n歌曲说过大家可以用七牛的免费存储功能，但是会发现一个问题七牛的歌曲外链不支持https，这会导致配置有ssl证书的人掉绿锁，其实如果有这个需求的大家可以放弃七牛，改用腾讯云，这样就OK啦，一样的操作。\n\n好多人问歌词的URL好难找啊，去哪里找呢，大家可以看下这个 [MeetingJS](https://github.com/metowolf/MetingJS)这个其实是基于Aplayer的一个小封装，目的是简化Aplayer的接入成本，但是因为之前我介绍了接入步骤所以这里我们只用它的歌词API就可以。`ttps://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv` 其中要改的只有两个参数seaver是音乐平台包含百度、网易、QQ音乐等平台\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1forkjr7da0j31be0ns43n.jpg)\n\nid字段对应的是歌曲的ID 这个你只要打开个歌曲网页链接里面应该都包含id。文章结尾的播放就是这么加入的\n\n## 最后\n\n整篇文章只有开始一小部分在讲解如何搭建博客，后续的基本都是交给大家如何优化，调整一些细节问题如UI、用户体验之类的，当然我们能做的远远不止这些，如果有什么问题欢迎与我探讨。下面的留言我都会看的。此外当本人对HEXO有新的看法或者玩法的话该文章会不断的更新，希望大家关注我的[小站](https://oliverqueen.cn/)，感谢。\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"凉城\",\n            \"author\": \"任然\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/liangcheng.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M0000008nl2Y1HlxUm.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002SKEeh1VzObP\"\n        },\n        {\n            \"title\": \"Love Story\",\n            \"author\": \"린 (LYn)\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"\n        },\n        {\n            \"title\": \"大鱼\",\n            \"author\": \"周深\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/2018-01-25-可能是最全的使用HEXO搭建个人博客教程.md","raw":"---\ntitle: 可能是最全的使用HEXO搭建个人博客教程\ncategories: 通用开发\ndate: 2018-01-25 15:43:15\ntags:\n - Hexo\n - 个人博客\n - 网站\ncomments:\n---\n## 背景\n\n作为一个开发者不能没有博客，最近花了几天的时间搭建了这个博客，处理了很多细节，在这篇文章中我会把我从开始到现在以及后续的优化整理出来，帮助更多的人搭建、维护、更新、自己的博客。\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fnsy5fhyhsj31hc0xchdt.jpg)\n\n一开始我所有的博客都写在新浪微博，因为微博上更容易推广自己的文章，微博用户量大，但是后来微博的弊端慢慢的显示出来了，毕竟不是开发者的天地，我的博客中经常会插入大量的代码，而微博不支持markdown编辑，普通的编辑器对代码块的兼容性非常差，别说高亮了，有时候排版都会错乱，最后外观很不好看，如下图：\n\n<!--more-->\n\n![微博代码](https://ws4.sinaimg.cn/large/006tNc79ly1fnsxwzb745j31i20tuad4.jpg)\n\n而且微博的账号系统也存在一定的弊端，所以后来转向简书、掘金等技术平台，不得不承认相对于微博来说这些平台对开发者就要友好多了，不过后来又发现一个问题。因为我在写文章的时候使用的是本地的markdown编辑器，而这些平台对markdown语法的一些小细节并不严谨或者说统一如下图：\n\n\n![简书VS掘金](https://ws3.sinaimg.cn/large/006tNc79ly1fnsy0p6no4j316q0nsn2v.jpg)\n\n两个平台的编辑器无法做到统一，以至于每次写完文章都需要针对两个平台做不同的修改。\n\n综上所述，最简单的也最一劳永逸的方法就是搭建自己的博客平台，而HEXO很好的帮我们解决了这个问题，其实对于一个开发者来说并不是什么难事，整个流程对于大部分有代码基础的开发者来说一上午时间就可以搞定，不过最难的也是最头痛的就是对细节的调整，对UI的修改、优化等，不过本文会对此逐一讲解。\n\n## 环境配置\n\n\n* [Node.js](https://nodejs.org/en/)\n\n cURL:\n\n `$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n`\n\n Wget:\n\n `$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n`\n\n 安装完成后，重启终端并执行下列命令即可安装 Node.js。\n\n `$ nvm install stable`\n\n\n* [Git](https://git-scm.com/)\n\n 一般的开发者不会没有这个吧，我是安装Xcode就会有这个了，\n\n 使用 Homebrew, MacPorts ：brew install git;或下载 [安装程序](https://sourceforge.net/directory/) 安装\n\n* [bitbucket](https://bitbucket.org/)账号\n\n 一般都会使用HEXO+GitHub page的形式搭建自己的博客，但是这里有个问题就是GitHub是开源的，任何人都能在上面看到你的源代码，虽然这并没有什么太大的影响，不过对于我来说感觉怪怪的，所以我就用了bitbucket page来处理我的博客，所有的东西都一样只不过这个是个私有库罢了（免费五个人）\n\n ![](https://ws3.sinaimg.cn/large/006tNc79ly1fnt1nn8k9uj30b308amye.jpg)\n\n\n## 开始建站\n\n#### 第一步：创建仓库\n\n进入github/bitbucket（后续都以github为例）新建repo，这里要注意repo的名字一定要满足`your Account Name`/github.io。如果是bitbucket那就是`your Account Name`/bitbucket.io，因为只有这样的仓库名称最后才能以静态页面展示。如图：XXX的内容一定要与红色的框里的文本一致。\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fntzjgvzvyj30q006nmy0.jpg)\n\n#### 第二步：创建本地文件夹\n\n创建文件夹之后CD到你创建的文件夹中执行hexo的初始化相关命令\n\n```\n$ hexo init\n$ npm install\n```\n\n执行完毕之后你的文件夹里就有内容了，标准的目录结构是这样（只列出几个必要的文件夹及其子目录）\n\n```\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n * _config.yml：\n 其中我们以后的大部分操作都会在`_config.yml`中进行，这个文件是我们的站点的配置文件。\n\n * scaffolds：\n 模板文件，规定了我们创建一篇文章的时候最开始的样子，\n\n * source：\n 可以暂时的理解成我们文章的存放处\n\n * themes：\n 主题文件\n\n#### 第三步：部署到Git\n\n修改我们的的站点配置文件`_config.yml`中如下字段\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fntzzwn8dkj30w0058wga.jpg)\n其中：\n  * `type`值对应的是你所部署的的服务器类型，我们这里填写git就可以。\n\n  * `repo`是你的仓库地址，也就是仓库克隆的地址，推荐用https的链接。\n\n  * `branch`不写默认是master，通常我们写成master就可以。\n\n以上配置完成后保存 然后回到终端执行`npm install hexo-deployer-git --save`安装一个插件，这样才能将你写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)\n  * `hexo clean`  清理缓存  \n\n  * `hexo generate` 进行渲染 简写 `hexo g`\n\n  * `hexo server` 部署到本地(调试使用) 简写 `hexo s`。然后浏览器输入 `http://localhost:4000` 就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得 `control + C` 关闭本地端口，不然下次就进不去啦)\n\n  * 调试完毕后使用 `hexo deploy` 简写为 `hexo d`来部署到git服务器。\n\n执行完以上操作后打开浏览器地址了输入`http://你github名字.github.io`就可以看看到效果啦，这回是所有人都能看到的，用手机也可以。至此第三步已经完成,最终的结果如下图：\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu0jxw383j310l0gcdrk.jpg)\n\n#### 第四步：写文章\n\n使用如下命令 `hexo new post “文章名字”` 就可新建文章啦，建立好的文章在 `source/_posts` 中，你可以用markdown语法编辑内容就可以。编辑完成后执行第三步中终端的操作就可以啦，刷新下浏览器就可看到你的新文章啦。如下图:\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu0ml6lp4j310n0g9tjv.jpg)\n\n## 个性化\n\n#### 一：主题\n\n###### 获取\n\n主题是我么个性化的基础和前提，我们想做任何个性化上的修改基本上都是在我们主题上的修改，先找到一个自己满意的主题是首要任务。关于主题网上有很多很多，[HEXO官方的主题目录](https://hexo.io/themes/)也收录了好多来着世界各地开发者的主题。或者开发者也可以直接去网上搜索HEXO theme关键字来获取主题。\n\n###### 安装\n\n主题一般都是repo，只要讲起clone到博客目录themes/XXXX下就可了，XXXX对应的就是你给主题起的名字，像这样：`git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet` 这样就可以保证每次主题的作者有更新了我们就可以 pull获取更新。不过这样有个问题后面我会在HEXO多终端同步一栏讲到，所以这里我们选择另一种方式去安装，就是直接把主题的repo下载下来\n然后解压放到themes中。其实对于已经稳定的主题作者一般不会频繁更新，不稳定的主题我们也不会用，所以用后者安装也是一样的。\n\n然后我们回到刚才的站点配置文件中`_config.yml`修改如下字段，对应的名字就是你刚才那个主题文件夹的名字：我这边是next，\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fnu5dr697rj312006a0tp.jpg)\n\n然后保存，再去终端执行那三步，接着刷新网页就可以看到新的界面啦。下面是我换了NEXT主题刷新后的效果。因为该注意已经非常完善，所有后续用该主题做例子来讲\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu5ohsltng30go097e83.gif)\n\n#### 二：主题菜单\n\n###### 添加按钮\n\n主题菜单也可以说是主题按钮。也就是上面顶部的两个，next主题默认的两个是Home、Archive，我们一般会加上tag about category等。这些都是需要在主题上进行修改，我们需要修改主题的配置文件，首先在主题的文件夹下找到`_config.yml`文件，没错和之前的站点配置文件同名，只不过他们的路径不同，大家千万不要弄混，站点配置文件是配置站点通用的东西，而主题配置文件是配置一些主题的元素。在主题配置文件找到menu字段\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu69gaksbj312s0cijtz.jpg)\n\n可以看到主题作者注释掉了一部分按钮只保留了两个最基本的，这里需要注意前面的Key并不是代表的是按钮名字，因为该主题是支持多语言，所以这个key只是个标识，具体的按钮名字要去该路径下查找\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fnu6e4quu7j30fa0zkwgi.jpg)\n\n其中每一个文件对应了不同的语言，我们以汉语为例，进入`zh-Hans.yml`中修改这些字段\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fnu6fypjr7j30ay054wes.jpg)\n\n其中key就是之前我们在主题配置文件中的key，而后面的value则是简体中文状态下按钮的名字。修改完成后我们保存执行那三步就可以看到我们新添加的按钮了。\n\n###### 添加页面\n\n添加按钮后我们需要点击按钮显示统一的页面。这时候我们需要添加页面。以tag页面为例，hexo中添加页面的命令是`hexo new page XXXXX` 后面XXX则是要添加页面的名称，我们这里写tags。为了测试新建的tag页面我们对之前的页面添加个tag。去 source/_post中找一篇文章我们在开头添加如下字段,多标签以此类推\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fnu6nmt2ywj30v00f4jsi.jpg)\n\n然后编辑我们刚才生成的tag页面(`source/tags/index.md`)指定其type为tags\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu6q39ak4j310y09e3zb.jpg)\n\n然后保存执行那三步就会有如下效果\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fnu6vtcn1og30gn07fhe0.gif)\n\n点击对应的tag即可跳转到改tag所对应的文章。其他页面同理。\n\n#### 三：添加阅读更多button\n\n我们在首页的时候其实就是我们的文章列表，但是这时候有个问题，如果我们某一篇或者某几篇文章很长，那首页是不是更长呢？其实在首页我们可以只显示文章部分内容，通过点击阅读更多按钮来进入文章详情。这个时候就需要截断文章。我们在文章的合适地方采用`<!--more-->`来截断,用默认文章来看\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu73u6xghj313o0hujuz.jpg)\n\n然后执行那三步就会如下效果\n\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fnu75xee1rj31kw0iomzf.jpg)\n\n点击阅读更多。\n\n#### 四：更改主题背景\n\n首先找到如下路径 `themes\\next\\source\\css_custom\\custom.styl` 会发现里面是空的，这个文件是Next主题为我们预留的做一些自定的css样式的地方，我们添加如下代码。\n\n```\n//背景图片相关\n@media screen and (min-width:1200px) {\n\n    body {\n    background-image:url(/images/bg.jpg);\n    background-repeat: no-repeat;\n    background-attachment:fixed;\n    background-position:50% 50%;\n    background-size: cover\n    }\n\n    #footer a {\n        color:#eee;\n    }\n}\n```\n这里大家应该就可以看出括号里面的图片路径就是我们的背景图片，我们只需把图片放入 `themes\\next\\source\\images` 中即可，记住图片名字要写对，要有后缀。同理括号里面我们可以直接放一个图片的链接比如 `https://tpc.googlesyndication.com/simgad/6893153702744595670` 做完这些操作保存，然后执行那三步即可看到效果，不过可能浏览器有缓存，可以清理下缓存再刷新看看。\n\n#### 五：修改博客背景透明度\n\n既然再上一步中修改了背景图片，如果被NExt本身的白色挡住确实不好看，我们可以尝试把本身的白色背景变成透明的，这样会美观很多，同样还是修改刚才的文件 `themes\\next\\source\\css_custom\\custom.styl` 在上一步的基础上我们可以添加如下代码\n ```\n //改变背景色和透明度\n .main-inner {\n     background: #fff;\n     opacity: 0.9;\n }\n ```\n 其中第一个属性为颜色值，第二个属性就是我们的透明度啦。适当修改，不然会适得其反连字都看不清啦。做完上两步就是我的这个博客的效果。\n\n #### 六：修改作者头像为圆形，\n\n 我们默认是方形的头像，想修改为圆形的话同样是上两步的那个路径下添加如下代码\n ```\n .site-author-image {\n   border-radius: 100%;\n   padding: 2px;\n   border: 2px dashed #fff;\n   animation: cycle 2s 0.5s forwards;\n   transition: border-radius 2s;\n }\n ```\n 保存 -> 三步 即可看到效果\n\n ![](https://ws2.sinaimg.cn/large/006tKfTcly1fnxgsh0p7bj308e06jq3t.jpg)\n\n #### 七：添加背景动画\n\n 背景动画使用Js来处理，会JS的同学可以自己写喜欢的动画，我这边就用了网上比较通用的动画。找到以下路径 `themes\\next\\layout\\_layout.swig` 在文章 `</body>`的上面添加如下代码\n ```\n <script type=\"text/javascript\"\n color=\"255,255,255\" opacity='1' zIndex=\"-2\" count=\"100\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"></script>\n {% endif %}\n\n ```\n 然后 保存 -> 三步即可看到效果 其中src为JS的路径，有兴趣的可以自定义效果。\n\n #### 八：添加评论页面\n\n HEXO的评论页面官方推荐了disqus，无奈已经被墙，即使开发时候自己有克服的方法但是也不能保证所有看你博客的人都有克服的方法。所有我们打算采用其他的的一些第三方来实现，首先先对市面上的几个产品做下对比：\n\n###### 比较：\n* disqus\n\n 比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。暂不考虑\n\n* 多说\n国内比较出名的评论系统，已经关闭服务暂不考虑。\n\n* gitment\n一款基于github issue的评论系统，风格很像github，只是目前还不是太稳定，且界面无法自定，可能会于博客有些不协调。而且评论需要github账号\n\n* livere\n中文名字叫来必力，是一款韩国的评论系统，在不带有任何民族情感的前提下来看确实棒子的东西还是不错的，也是我目前在使用的一款，我主要用它的原因有几点\n  * 支持很多种格式的评论导入，你可以很方便的吧之前在其他平台上的评论数据导入进来，支持多种json格式。\n\n  * 简介的UI提供多种主题。\n\n  * 国外的东西不受国内的限制。\n\n###### 集成：\n先去[livere的官网](https://livere.com)注册m，具体过程我就不讲了，一步一步安她的来就行，之后他会给你一个安装代码，像这样：\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnxhkvhulnj30pt0ikq5e.jpg)\n\n里面主要的信息就是data-uid。\nNEXT主题本身是已经集成了livere评论的，只不过被注释掉了。找到主题配置文件 `_config.yml` 找到如下代码\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fnxhhj8slmj312o06kmyi.jpg)\n\n打开注释填入你在livere中注册后它给你的UID即可。然后 保存 -> 三步即可。\n\n## 九：多终端操作\n\n#### 背景\n\n大家都知道HEXO是静态博客，所有的页面都是静态的通过本地文件渲染然后再部署上去，这就带来一个多终端部署的问题，比如公司电脑配置好了，想回家在进行写作，发现家里什么都没有还需要重新配置环境，不过这倒是次要，关键是如果不能保证两个终端的内容完全一样就会造成服务器上的数据会被最后一次部署覆盖，导致前几次的都被覆盖掉。\n\n#### 解决\n\n其实大家应该也看出HEXO整体的一套流程下来就是git的工作流程，不管你用github还是bitbucket都是遵循gitflow的，而gitflow就是一种多终端多人协同工作的解决方案。所以我们可以用它来解决多终端同步的问题。\n\n#### 流程\n\n我们先来了解下hexo的整体流程。我们正常的为文件夹结构如图：\n\n ![](https://ws3.sinaimg.cn/large/006tNc79ly1fnyf572x8nj30bu0fqgn0.jpg)\n\n###### 第一步：hexo g\n\n source文件夹下存放着我们的文章，tag、归档之类的信息，也就是我们的博客的内容。当我们在终端执行 `hexo g` 的时候会被source中的文件按照某种规则方式渲染成静态的页面文件放到public中：\n\n ![](https://ws3.sinaimg.cn/large/006tNc79ly1fnyf8eyhjdj30mw0e876h.jpg)\n\n###### 第二步：hexo d\n\n 然后我们执行 `hexo d` 这一步暂时我们可以认为就是对public中的文件进行push到我们的git仓库的过程。所以在我们的仓库中 `XXXXXX.bitbucket.io` 大家看到的文件只有public中的文件。\n\n###### 附加：hexo clean\n\n 其实这一步是和gitflow没有关系的，但是既然讲到流程我这边也在说下，之前说过这步是用来清理缓存的，其实他的作用是运行在第一步之前，将整个public文件删除，然后我们再执行 `hexo g` 重新渲染进public，之后再 `hexo d` 进行部署，这样就避免之前的内容对我们造成影响。\n\n\n#### 具体操作\n\n 通过上一步流程我们知道如果git服务器上只有public是不够的，我们需要有我们整个博客文件夹下的所有文件才能进行多终端操作。所有这边有两个方法：\n * 新建另一个仓库我们暂时命名为MyProject，把我们所有的文件传到这个Git仓库上，当我们换另一台电脑时候我们直接拉这个新仓库的代码然后进行写作 -> 三步走最后在将所有文件推到MyProject以后所有的git操作都在这个仓库中进行。\n\n * git给我们提供了多分支操作，我们可以做xxxx.github.io这个仓库中创建一个新的分支暂时命名为hexo分支，这个分支的作用和上一个方法里MyProject的作用以及里面的文件一模一样，只不过我们这个方法就省的我们再创建一个仓库了。以后所有的git操作都去这个分支进行，本地的文件一直保持在这个分支就行，不过有一点需要注意的就是，即使所有的操作都在hexo分支下进行也必须保证master分支为主分支(default branch)，不然你就打不开你的博客了。\n\n 以上两种都是属于基本的git操作，本文不再赘述。不过有一点这里要强调下，还记一开始我跟大家说的主题的是推荐大家直接去主题所在的repo下载zip然后解压拖进博客目录里面吗？如果你不是拖拽进来的而是clone下来的话在这一步你会涉及到git的 add submodule操作。其实操作不难，具体的命令网上也是大把。不过如果你像我一样使用bitbucket的话可能发现无法进行submodule操作，不知道这个是bitbucket的BUG还是什么其他原因，同样的命令使用github托管博客的时候是没有问题的，而bitbucket就不行，当你使用另一台电脑的进行拉去的时候执行 `git submodule init` 操作的时候他会提示找不到。至今未解决，如果哪位大神有什么方法及时联系我。\n\n## 十：绑定个人域名\n\n#### <font color=red>注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明</font>\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7pq9gdqzj31a20psaf0.jpg)\n\n#### 准备工作\n\n在github上创建仓库，仓库的名字为 username.github.io。然后修改站点配置文件中部署地址（repo对应的字段），将原本的bitbucket的仓库地址改为github的地址\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7pve5iwgj312u0a0401.jpg)\n\n之后进行保存然后三步走，部署成功后你的博客就从bitbucket上迁移到github中了，这样一来，你整体的博客仓库还是在bitbucket中的私有库中，但是public文件夹中的公开文件已经被你部署到github的仓库中。该保密的信息仍然保密，同时也不影响你绑定自己的域名，一举两得。正常情况下按照上面步骤完成后的博客地址是 xxx.github.io，下面就开始绑定自己的域名。\n\n#### 域名购买\n\n这个渠道有很多，我就不再一一赘述，我这边以[阿里云的万网域名购买](https://wanwang.aliyun.com/domain/searchresult/?keyword=nihyao&suffix=.cn&domaintype=zh%2Cen#/?keyword=test&suffix=cn)为例,找到合适自己的域名\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7pjuuq4mj313u0hkqdt.jpg)\n\n#### 域名解析\n\n购买域名并且按照他的步骤实名认证之后，需要把域名解析到我们的博客中，在阿里云的控制台找到域名右侧对应的解析按钮。点击然后添加解析\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7q32hh49j31800h5ae1.jpg)\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7q3yyhfij31780anq46.jpg)\n\n然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7q5sss5oj30kr0bkq3n.jpg)\n\n之后记得启用该记录，不过如果你像我一样是阿里云购买并且配置的话是不需要启用的，默认帮你启用。\n\n#### 仓库配置\n\n然后回到你的github仓库，进入你的仓库设置页面，找到如下字段，在红框处添加你的域名，然后保存即可\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7qbo2111j30t10i7goa.jpg)\n\n#### 博客配置\n\n回到你的博客目录，在source目录下创建一个<font color=red>不带任何后缀的</font>文件，命名为 CNAME，里面填写你的域名，我是这样，只添加你的域名不要添加其他东西。然后保存 执行三步之后就可以通过你的域名访问你的博客啦，如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以了。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7qe2vzuzj30s202ydfw.jpg)\n\n## 十一：实现https协议\n\n按照以上步骤完成后可以通过域名访问，但是有个问题就是如果你用谷歌浏览器或者Safari，他就会提示你网站不被信任，只有你点击仍要继续才会展示你的博客，并且地址栏里面还是有个红色的×，虽说不影响使用和阅读，但是还是感觉别扭，这次我们来讲如何将自己的博客协议改为Https。这里有几种方法：\n\n* 购买证书\n\n* 使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制\n\n* 使用CDN进行反向代理\n\n如果使用上两步的话基本上证书的服务商都会告诉你如何配置，他们的文档讲的一定比我的详细，不过主要原因是我们使用的github Page是不支持上传证书的，所以这里主要说下第三步，通过CDN配置反向代理，这里就需要用到一个国外的CDN服务提供商[Cloudflare](https://www.cloudflare.com/):\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7utpfih2j30wz07mju7.jpg)\n\n#### 原理\n\n[Cloudflare](https://www.cloudflare.com/) 提供DNS解析服务，而且速度很快，在阿里云半个小时才能生效的解析在它这里瞬间就生效，它提供了免费的https服务(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7v9apbogj30t004ydg6.jpg)\n\n用户看到的小锁其实是用户连接到Cloudflare的证书，而由Cloudflare到github是没有https的，不过对于我们静态博客已经够了。\n\n#### 配置\n\n###### 第一步：\n\n还是先去官网注册，然后添加你的域名，注意添加的是你购买的域名。\n\n###### 第二步：\n\n进入DNS解析界面填入如下解析，因为我们使用clouldflare做DNS解析所以一会我们需要把我们购买域名的那个地方的解析删掉。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7vibz0a6j30rv0kagns.jpg)\n\n其中前两个是使你的域名指向github的服务器地址，github文档中给的就是这个两个地址，最后那个CNAME记录指向的是你的github仓库域名username.github.io。一定要严格按照这个来配置。\n\n###### 第三步：\n\n记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把你域名购买处（我的是阿里云）的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为我们以后就靠clouleflare来解析DNS啦。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7vnm5itzj30qy03c74a.jpg)\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7vqjin22j316i0ib77n.jpg)\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7vse0wewj316u09tmys.jpg)\n\n###### 第四步：\n\n回到clouldflare 上面选择crypto选项然后下面选择full或者是Flexible\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fo7vwnoasij30wx0f8myk.jpg)\n\n选项中几个的区别如下图\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fo7vxck29zj30k00cv0sp.jpg)\n\n最后那个是需要证书支持的。然后滚动到下面打开always use HTTPS开关\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fo7vy66223j30rn06dwet.jpg)\n\n###### 第五步：\n\n以上步骤配置好之后基本就完成了，但是如果直接有人在地址栏里面输入http://XXXXX 进入你的博客的话你这边还是会出现非Https的效果，所以我们这里要做一个强制跳转。\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fo7w1ksr94j30uu0ir76a.jpg)\n\n这样就万无一失了。\n\n###### 坑点：\n\n我之前按照以上步骤操作完成后发现首页虽然是https了也不显示红叉了，但是也没有显示绿色的小锁，而是一个叹号，但是有些博文页面可以正常显示https绿锁。后来发现是因为当前页面中有非https的链接导致，比如图片图床不是https的，或者评论插件不支持https，不过我博客中使用的来必力评论是支持https，只是我当时的图床无都是http所以只能是显示叹号了，后来把所有图片图床换成https的就好啦。\n\n## 十二：为博客添加音乐\n\nHEXO博客添加的音乐的地方有两个。一个个首页侧边栏，另一个是每个页面里面。但是个人觉得添加侧边栏里面并不好，因为添加侧边栏的话用户只有在浏览你首页的时候才能听到音乐，而且期间不能点击任何站内链接，否则音乐就会中断，试想下，一般首页都是文章列表，点击文章里面之后才是正文，所以用户在首页停留的时间很短，基本上找到自己想看的文章就会马上点进去看，所以这里放音乐没有太大意义；而页面内插入音乐会更好点，读者可以一边浏览文章一边听音乐，这也正是我们想要的。不过解决前者问题的办法也不是没有，比如点击链接的话直接开另一个浏览器标签来打开新页面也可以做到不中断音乐，但是总觉得有点小题大做了。总不能读者看个你的博客而占用了一堆标签。\n\n#### 网易云音乐外链\n\n这个是最简单的方法，通过网易云音乐官网生成播放器外链。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fordugrc80j315s0swthy.jpg)\n\n可以自己配置一些属性，然后自动生成配置代码，放到你的博客里面就行啦，粘贴到你文章中想要的地方\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1forduyu7laj31hm0zkaft.jpg)\n\n优点缺点截图上也有，不过网上也说这样的方式会影响SEO，具体什么原理也不太清楚。总之简单便捷，不过网易的logo去不掉。\n\n#### [aplayer](https://aplayer.js.org/docs/#/?id=options)添加音乐\n\n这个算是HEXO最常用也是最出名名的播放器了，还有Dpleyer是用来视屏播放的，暂时我们不说。首先需要安装aplayer依赖，终端中切换到你的博客根目录执行 `npm install aplayer --save` 安装成功后就可以了。参数就不给大家一一讲解了，官方文档都有，我这里只提供一个例子。\n\n###### 页面中添加音乐\n\n```\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"에필로그 (Epilogue)\",\n            \"author\": \"이동준\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\n            \"lrc\": \"https://歌词.lrc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n\n```\n以上代码插到文章中任意一个你想的地方就可以\n\npic就是歌曲显示图片的链接。大家可以看到music是个数组，所以想添加列表的话就在数组中再添加个歌曲字典就好了。建议歌词lrc要用URL形式，不然txt格式可能要编辑死。。好多人问歌曲的MP3外链从哪里来。这个其实很简单，首先把歌曲下载下来然后上传到七牛云就可以在七牛云生成外链啦，七牛云有免费的存储空间，只存歌曲的话足够啦。歌词URL\n\n###### 侧边栏中添加音乐\n\n其实之前讲过，不建议在侧边栏中添加，但是这里还是简单介绍下。首先要做的是在`node_modules` 目录下找到 `APlayer.min.js` 文件，将其复制到 `theme/next/source/js/src/` 目录下。然后打开 `theme/next/layout/_custom/` 文件夹下的 `sidebar.swig` 文件，向其中添加以下代码：\n\n```\n<div id=\"player1\" class=\"aplayer\"></div>\n<script src=\"/js/src/APlayer.min.js\"></script>\n<script type=\"text/javascript\">\nvar ap = new APlayer({\n    element: document.getElementById('player1'),                       // Optional, player element\n    narrow: false,                                                     // Optional, narrow style\n    autoplay: false,                                                    // Optional, autoplay song(s), not supported by mobile browsers\n    showlrc: 0,                                                        // Optional, show lrc, can be 0, 1, 2, see: ###With lrc\n    mutex: true,                                                       // Optional, pause other players when this player playing\n    theme: '#e6d0b2',                                                  // Optional, theme color, default: #b7daff\n    mode: 'random',                                                    // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`\n    preload: 'metadata',                                               // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'\n    listmaxheight: '513px',                                             // Optional, max height of play list\n    music: [\n    {                                                           // Required, music info, see: ###With playlist\n        title: 'Sometimes When We Touch',                                          // Required, music title\n        author: 'Oliveia',                                              // Required, music author\n        url: 'https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/SometimesWhenWeTouch.mp3',  // Required, music url\n        pic: 'https://y.gtimg.cn/music/photo_new/T002R300x300M000003LIDEL0NQInJ.jpg?max_age=2592000',  // Optional, music picture\n        lrc: 'https://歌词.lrc'                   // Optional, lrc, see: ###With lrc\n    },\n    {\n        \"title\": \"大鱼\",\n        \"author\": \"周深\",\n        \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\n        \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\n        \"lrc\": \"https://歌词.lrc\"\n    }\n    ]\n});\n</script>\n\n```\n只是换成了JS的语法，其实原理，参数都一样。然后执行三步走就可以看到啦，注意有浏览器缓存，所以多刷新几次就会有了。\n\n###### 歌词、音乐外链相关\n\n歌曲说过大家可以用七牛的免费存储功能，但是会发现一个问题七牛的歌曲外链不支持https，这会导致配置有ssl证书的人掉绿锁，其实如果有这个需求的大家可以放弃七牛，改用腾讯云，这样就OK啦，一样的操作。\n\n好多人问歌词的URL好难找啊，去哪里找呢，大家可以看下这个 [MeetingJS](https://github.com/metowolf/MetingJS)这个其实是基于Aplayer的一个小封装，目的是简化Aplayer的接入成本，但是因为之前我介绍了接入步骤所以这里我们只用它的歌词API就可以。`ttps://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv` 其中要改的只有两个参数seaver是音乐平台包含百度、网易、QQ音乐等平台\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1forkjr7da0j31be0ns43n.jpg)\n\nid字段对应的是歌曲的ID 这个你只要打开个歌曲网页链接里面应该都包含id。文章结尾的播放就是这么加入的\n\n## 最后\n\n整篇文章只有开始一小部分在讲解如何搭建博客，后续的基本都是交给大家如何优化，调整一些细节问题如UI、用户体验之类的，当然我们能做的远远不止这些，如果有什么问题欢迎与我探讨。下面的留言我都会看的。此外当本人对HEXO有新的看法或者玩法的话该文章会不断的更新，希望大家关注我的[小站](https://oliverqueen.cn/)，感谢。\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"凉城\",\n            \"author\": \"任然\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/liangcheng.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M0000008nl2Y1HlxUm.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002SKEeh1VzObP\"\n        },\n        {\n            \"title\": \"Love Story\",\n            \"author\": \"린 (LYn)\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"\n        },\n        {\n            \"title\": \"大鱼\",\n            \"author\": \"周深\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"可能是最全的使用HEXO搭建个人博客教程","published":1,"updated":"2019-02-02T03:22:53.083Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lg001ea04wtv07hd7y","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>作为一个开发者不能没有博客，最近花了几天的时间搭建了这个博客，处理了很多细节，在这篇文章中我会把我从开始到现在以及后续的优化整理出来，帮助更多的人搭建、维护、更新、自己的博客。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnsy5fhyhsj31hc0xchdt.jpg\" alt=\"\"></p>\n<p>一开始我所有的博客都写在新浪微博，因为微博上更容易推广自己的文章，微博用户量大，但是后来微博的弊端慢慢的显示出来了，毕竟不是开发者的天地，我的博客中经常会插入大量的代码，而微博不支持markdown编辑，普通的编辑器对代码块的兼容性非常差，别说高亮了，有时候排版都会错乱，最后外观很不好看，如下图：</p>\n<a id=\"more\"></a>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnsxwzb745j31i20tuad4.jpg\" alt=\"微博代码\"></p>\n<p>而且微博的账号系统也存在一定的弊端，所以后来转向简书、掘金等技术平台，不得不承认相对于微博来说这些平台对开发者就要友好多了，不过后来又发现一个问题。因为我在写文章的时候使用的是本地的markdown编辑器，而这些平台对markdown语法的一些小细节并不严谨或者说统一如下图：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnsy0p6no4j316q0nsn2v.jpg\" alt=\"简书VS掘金\"></p>\n<p>两个平台的编辑器无法做到统一，以至于每次写完文章都需要针对两个平台做不同的修改。</p>\n<p>综上所述，最简单的也最一劳永逸的方法就是搭建自己的博客平台，而HEXO很好的帮我们解决了这个问题，其实对于一个开发者来说并不是什么难事，整个流程对于大部分有代码基础的开发者来说一上午时间就可以搞定，不过最难的也是最头痛的就是对细节的调整，对UI的修改、优化等，不过本文会对此逐一讲解。</p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ul>\n<li><p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a></p>\n<p>cURL:</p>\n<p><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p>\n<p>Wget:</p>\n<p><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p>\n<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>\n<p><code>$ nvm install stable</code></p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a></p>\n<p>一般的开发者不会没有这个吧，我是安装Xcode就会有这个了，</p>\n<p>使用 Homebrew, MacPorts ：brew install git;或下载 <a href=\"https://sourceforge.net/directory/\" target=\"_blank\" rel=\"noopener\">安装程序</a> 安装</p>\n</li>\n<li><p><a href=\"https://bitbucket.org/\" target=\"_blank\" rel=\"noopener\">bitbucket</a>账号</p>\n<p>一般都会使用HEXO+GitHub page的形式搭建自己的博客，但是这里有个问题就是GitHub是开源的，任何人都能在上面看到你的源代码，虽然这并没有什么太大的影响，不过对于我来说感觉怪怪的，所以我就用了bitbucket page来处理我的博客，所有的东西都一样只不过这个是个私有库罢了（免费五个人）</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnt1nn8k9uj30b308amye.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"开始建站\"><a href=\"#开始建站\" class=\"headerlink\" title=\"开始建站\"></a>开始建站</h2><h4 id=\"第一步：创建仓库\"><a href=\"#第一步：创建仓库\" class=\"headerlink\" title=\"第一步：创建仓库\"></a>第一步：创建仓库</h4><p>进入github/bitbucket（后续都以github为例）新建repo，这里要注意repo的名字一定要满足<code>your Account Name</code>/github.io。如果是bitbucket那就是<code>your Account Name</code>/bitbucket.io，因为只有这样的仓库名称最后才能以静态页面展示。如图：XXX的内容一定要与红色的框里的文本一致。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fntzjgvzvyj30q006nmy0.jpg\" alt=\"\"></p>\n<h4 id=\"第二步：创建本地文件夹\"><a href=\"#第二步：创建本地文件夹\" class=\"headerlink\" title=\"第二步：创建本地文件夹\"></a>第二步：创建本地文件夹</h4><p>创建文件夹之后CD到你创建的文件夹中执行hexo的初始化相关命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n<p>执行完毕之后你的文件夹里就有内容了，标准的目录结构是这样（只列出几个必要的文件夹及其子目录）</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── <span class=\"variable\">_config</span>.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── <span class=\"variable\">_drafts</span></span><br><span class=\"line\">|   └── <span class=\"variable\">_posts</span></span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>_config.yml：<br>其中我们以后的大部分操作都会在<code>_config.yml</code>中进行，这个文件是我们的站点的配置文件。</p>\n</li>\n<li><p>scaffolds：<br>模板文件，规定了我们创建一篇文章的时候最开始的样子，</p>\n</li>\n<li><p>source：<br>可以暂时的理解成我们文章的存放处</p>\n</li>\n<li><p>themes：<br>主题文件</p>\n</li>\n</ul>\n<h4 id=\"第三步：部署到Git\"><a href=\"#第三步：部署到Git\" class=\"headerlink\" title=\"第三步：部署到Git\"></a>第三步：部署到Git</h4><p>修改我们的的站点配置文件<code>_config.yml</code>中如下字段</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fntzzwn8dkj30w0058wga.jpg\" alt=\"\"><br>其中：</p>\n<ul>\n<li><p><code>type</code>值对应的是你所部署的的服务器类型，我们这里填写git就可以。</p>\n</li>\n<li><p><code>repo</code>是你的仓库地址，也就是仓库克隆的地址，推荐用https的链接。</p>\n</li>\n<li><p><code>branch</code>不写默认是master，通常我们写成master就可以。</p>\n</li>\n</ul>\n<p>以上配置完成后保存 然后回到终端执行<code>npm install hexo-deployer-git --save</code>安装一个插件，这样才能将你写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)</p>\n<ul>\n<li><p><code>hexo clean</code>  清理缓存  </p>\n</li>\n<li><p><code>hexo generate</code> 进行渲染 简写 <code>hexo g</code></p>\n</li>\n<li><p><code>hexo server</code> 部署到本地(调试使用) 简写 <code>hexo s</code>。然后浏览器输入 <code>http://localhost:4000</code> 就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得 <code>control + C</code> 关闭本地端口，不然下次就进不去啦)</p>\n</li>\n<li><p>调试完毕后使用 <code>hexo deploy</code> 简写为 <code>hexo d</code>来部署到git服务器。</p>\n</li>\n</ul>\n<p>执行完以上操作后打开浏览器地址了输入<code>http://你github名字.github.io</code>就可以看看到效果啦，这回是所有人都能看到的，用手机也可以。至此第三步已经完成,最终的结果如下图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu0jxw383j310l0gcdrk.jpg\" alt=\"\"></p>\n<h4 id=\"第四步：写文章\"><a href=\"#第四步：写文章\" class=\"headerlink\" title=\"第四步：写文章\"></a>第四步：写文章</h4><p>使用如下命令 <code>hexo new post “文章名字”</code> 就可新建文章啦，建立好的文章在 <code>source/_posts</code> 中，你可以用markdown语法编辑内容就可以。编辑完成后执行第三步中终端的操作就可以啦，刷新下浏览器就可看到你的新文章啦。如下图:</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu0ml6lp4j310n0g9tjv.jpg\" alt=\"\"></p>\n<h2 id=\"个性化\"><a href=\"#个性化\" class=\"headerlink\" title=\"个性化\"></a>个性化</h2><h4 id=\"一：主题\"><a href=\"#一：主题\" class=\"headerlink\" title=\"一：主题\"></a>一：主题</h4><h6 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h6><p>主题是我么个性化的基础和前提，我们想做任何个性化上的修改基本上都是在我们主题上的修改，先找到一个自己满意的主题是首要任务。关于主题网上有很多很多，<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">HEXO官方的主题目录</a>也收录了好多来着世界各地开发者的主题。或者开发者也可以直接去网上搜索HEXO theme关键字来获取主题。</p>\n<h6 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h6><p>主题一般都是repo，只要讲起clone到博客目录themes/XXXX下就可了，XXXX对应的就是你给主题起的名字，像这样：<code>git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet</code> 这样就可以保证每次主题的作者有更新了我们就可以 pull获取更新。不过这样有个问题后面我会在HEXO多终端同步一栏讲到，所以这里我们选择另一种方式去安装，就是直接把主题的repo下载下来<br>然后解压放到themes中。其实对于已经稳定的主题作者一般不会频繁更新，不稳定的主题我们也不会用，所以用后者安装也是一样的。</p>\n<p>然后我们回到刚才的站点配置文件中<code>_config.yml</code>修改如下字段，对应的名字就是你刚才那个主题文件夹的名字：我这边是next，</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fnu5dr697rj312006a0tp.jpg\" alt=\"\"></p>\n<p>然后保存，再去终端执行那三步，接着刷新网页就可以看到新的界面啦。下面是我换了NEXT主题刷新后的效果。因为该注意已经非常完善，所有后续用该主题做例子来讲</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu5ohsltng30go097e83.gif\" alt=\"\"></p>\n<h4 id=\"二：主题菜单\"><a href=\"#二：主题菜单\" class=\"headerlink\" title=\"二：主题菜单\"></a>二：主题菜单</h4><h6 id=\"添加按钮\"><a href=\"#添加按钮\" class=\"headerlink\" title=\"添加按钮\"></a>添加按钮</h6><p>主题菜单也可以说是主题按钮。也就是上面顶部的两个，next主题默认的两个是Home、Archive，我们一般会加上tag about category等。这些都是需要在主题上进行修改，我们需要修改主题的配置文件，首先在主题的文件夹下找到<code>_config.yml</code>文件，没错和之前的站点配置文件同名，只不过他们的路径不同，大家千万不要弄混，站点配置文件是配置站点通用的东西，而主题配置文件是配置一些主题的元素。在主题配置文件找到menu字段</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu69gaksbj312s0cijtz.jpg\" alt=\"\"></p>\n<p>可以看到主题作者注释掉了一部分按钮只保留了两个最基本的，这里需要注意前面的Key并不是代表的是按钮名字，因为该主题是支持多语言，所以这个key只是个标识，具体的按钮名字要去该路径下查找</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu6e4quu7j30fa0zkwgi.jpg\" alt=\"\"></p>\n<p>其中每一个文件对应了不同的语言，我们以汉语为例，进入<code>zh-Hans.yml</code>中修改这些字段</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnu6fypjr7j30ay054wes.jpg\" alt=\"\"></p>\n<p>其中key就是之前我们在主题配置文件中的key，而后面的value则是简体中文状态下按钮的名字。修改完成后我们保存执行那三步就可以看到我们新添加的按钮了。</p>\n<h6 id=\"添加页面\"><a href=\"#添加页面\" class=\"headerlink\" title=\"添加页面\"></a>添加页面</h6><p>添加按钮后我们需要点击按钮显示统一的页面。这时候我们需要添加页面。以tag页面为例，hexo中添加页面的命令是<code>hexo new page XXXXX</code> 后面XXX则是要添加页面的名称，我们这里写tags。为了测试新建的tag页面我们对之前的页面添加个tag。去 source/_post中找一篇文章我们在开头添加如下字段,多标签以此类推</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnu6nmt2ywj30v00f4jsi.jpg\" alt=\"\"></p>\n<p>然后编辑我们刚才生成的tag页面(<code>source/tags/index.md</code>)指定其type为tags</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu6q39ak4j310y09e3zb.jpg\" alt=\"\"></p>\n<p>然后保存执行那三步就会有如下效果</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fnu6vtcn1og30gn07fhe0.gif\" alt=\"\"></p>\n<p>点击对应的tag即可跳转到改tag所对应的文章。其他页面同理。</p>\n<h4 id=\"三：添加阅读更多button\"><a href=\"#三：添加阅读更多button\" class=\"headerlink\" title=\"三：添加阅读更多button\"></a>三：添加阅读更多button</h4><p>我们在首页的时候其实就是我们的文章列表，但是这时候有个问题，如果我们某一篇或者某几篇文章很长，那首页是不是更长呢？其实在首页我们可以只显示文章部分内容，通过点击阅读更多按钮来进入文章详情。这个时候就需要截断文章。我们在文章的合适地方采用<code>&lt;!--more--&gt;</code>来截断,用默认文章来看</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu73u6xghj313o0hujuz.jpg\" alt=\"\"></p>\n<p>然后执行那三步就会如下效果</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu75xee1rj31kw0iomzf.jpg\" alt=\"\"></p>\n<p>点击阅读更多。</p>\n<h4 id=\"四：更改主题背景\"><a href=\"#四：更改主题背景\" class=\"headerlink\" title=\"四：更改主题背景\"></a>四：更改主题背景</h4><p>首先找到如下路径 <code>themes\\next\\source\\css_custom\\custom.styl</code> 会发现里面是空的，这个文件是Next主题为我们预留的做一些自定的css样式的地方，我们添加如下代码。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//背景图片相关</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (min-width:<span class=\"number\">1200px</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:url(/images/bg.jpg);</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-attachment</span>:fixed;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>:<span class=\"number\">50%</span> <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">#f</span>ooter a &#123;</span><br><span class=\"line\">        color:<span class=\"number\">#eee</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里大家应该就可以看出括号里面的图片路径就是我们的背景图片，我们只需把图片放入 <code>themes\\next\\source\\images</code> 中即可，记住图片名字要写对，要有后缀。同理括号里面我们可以直接放一个图片的链接比如 <code>https://tpc.googlesyndication.com/simgad/6893153702744595670</code> 做完这些操作保存，然后执行那三步即可看到效果，不过可能浏览器有缓存，可以清理下缓存再刷新看看。</p>\n<h4 id=\"五：修改博客背景透明度\"><a href=\"#五：修改博客背景透明度\" class=\"headerlink\" title=\"五：修改博客背景透明度\"></a>五：修改博客背景透明度</h4><p>既然再上一步中修改了背景图片，如果被NExt本身的白色挡住确实不好看，我们可以尝试把本身的白色背景变成透明的，这样会美观很多，同样还是修改刚才的文件 <code>themes\\next\\source\\css_custom\\custom.styl</code> 在上一步的基础上我们可以添加如下代码<br> <figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改变背景色和透明度</span></span><br><span class=\"line\"><span class=\"selector-class\">.main-inner</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0.9</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 其中第一个属性为颜色值，第二个属性就是我们的透明度啦。适当修改，不然会适得其反连字都看不清啦。做完上两步就是我的这个博客的效果。</p>\n<h4 id=\"六：修改作者头像为圆形，\"><a href=\"#六：修改作者头像为圆形，\" class=\"headerlink\" title=\"六：修改作者头像为圆形，\"></a>六：修改作者头像为圆形，</h4><p> 我们默认是方形的头像，想修改为圆形的话同样是上两步的那个路径下添加如下代码<br> <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.site-author-image</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> dashed <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: cycle <span class=\"number\">2s</span> <span class=\"number\">0.5s</span> forwards;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-radius <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 保存 -&gt; 三步 即可看到效果</p>\n<p> <img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fnxgsh0p7bj308e06jq3t.jpg\" alt=\"\"></p>\n<h4 id=\"七：添加背景动画\"><a href=\"#七：添加背景动画\" class=\"headerlink\" title=\"七：添加背景动画\"></a>七：添加背景动画</h4><p> 背景动画使用Js来处理，会JS的同学可以自己写喜欢的动画，我这边就用了网上比较通用的动画。找到以下路径 <code>themes\\next\\layout\\_layout.swig</code> 在文章 <code>&lt;/body&gt;</code>的上面添加如下代码<br> <figure class=\"highlight django\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span></span></span></span><br><span class=\"line\"><span class=\"xml\">color=\"255,255,255\" opacity='1' zIndex=\"-2\" count=\"100\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;<span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endif</span></span> %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure></p>\n<p> 然后 保存 -&gt; 三步即可看到效果 其中src为JS的路径，有兴趣的可以自定义效果。</p>\n<h4 id=\"八：添加评论页面\"><a href=\"#八：添加评论页面\" class=\"headerlink\" title=\"八：添加评论页面\"></a>八：添加评论页面</h4><p> HEXO的评论页面官方推荐了disqus，无奈已经被墙，即使开发时候自己有克服的方法但是也不能保证所有看你博客的人都有克服的方法。所有我们打算采用其他的的一些第三方来实现，首先先对市面上的几个产品做下对比：</p>\n<h6 id=\"比较：\"><a href=\"#比较：\" class=\"headerlink\" title=\"比较：\"></a>比较：</h6><ul>\n<li><p>disqus</p>\n<p>比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。暂不考虑</p>\n</li>\n<li><p>多说<br>国内比较出名的评论系统，已经关闭服务暂不考虑。</p>\n</li>\n<li><p>gitment<br>一款基于github issue的评论系统，风格很像github，只是目前还不是太稳定，且界面无法自定，可能会于博客有些不协调。而且评论需要github账号</p>\n</li>\n<li><p>livere<br>中文名字叫来必力，是一款韩国的评论系统，在不带有任何民族情感的前提下来看确实棒子的东西还是不错的，也是我目前在使用的一款，我主要用它的原因有几点</p>\n<ul>\n<li><p>支持很多种格式的评论导入，你可以很方便的吧之前在其他平台上的评论数据导入进来，支持多种json格式。</p>\n</li>\n<li><p>简介的UI提供多种主题。</p>\n</li>\n<li><p>国外的东西不受国内的限制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"集成：\"><a href=\"#集成：\" class=\"headerlink\" title=\"集成：\"></a>集成：</h6><p>先去<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">livere的官网</a>注册m，具体过程我就不讲了，一步一步安她的来就行，之后他会给你一个安装代码，像这样：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnxhkvhulnj30pt0ikq5e.jpg\" alt=\"\"></p>\n<p>里面主要的信息就是data-uid。<br>NEXT主题本身是已经集成了livere评论的，只不过被注释掉了。找到主题配置文件 <code>_config.yml</code> 找到如下代码</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnxhhj8slmj312o06kmyi.jpg\" alt=\"\"></p>\n<p>打开注释填入你在livere中注册后它给你的UID即可。然后 保存 -&gt; 三步即可。</p>\n<h2 id=\"九：多终端操作\"><a href=\"#九：多终端操作\" class=\"headerlink\" title=\"九：多终端操作\"></a>九：多终端操作</h2><h4 id=\"背景-1\"><a href=\"#背景-1\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>大家都知道HEXO是静态博客，所有的页面都是静态的通过本地文件渲染然后再部署上去，这就带来一个多终端部署的问题，比如公司电脑配置好了，想回家在进行写作，发现家里什么都没有还需要重新配置环境，不过这倒是次要，关键是如果不能保证两个终端的内容完全一样就会造成服务器上的数据会被最后一次部署覆盖，导致前几次的都被覆盖掉。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>其实大家应该也看出HEXO整体的一套流程下来就是git的工作流程，不管你用github还是bitbucket都是遵循gitflow的，而gitflow就是一种多终端多人协同工作的解决方案。所以我们可以用它来解决多终端同步的问题。</p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>我们先来了解下hexo的整体流程。我们正常的为文件夹结构如图：</p>\n<p> <img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnyf572x8nj30bu0fqgn0.jpg\" alt=\"\"></p>\n<h6 id=\"第一步：hexo-g\"><a href=\"#第一步：hexo-g\" class=\"headerlink\" title=\"第一步：hexo g\"></a>第一步：hexo g</h6><p> source文件夹下存放着我们的文章，tag、归档之类的信息，也就是我们的博客的内容。当我们在终端执行 <code>hexo g</code> 的时候会被source中的文件按照某种规则方式渲染成静态的页面文件放到public中：</p>\n<p> <img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnyf8eyhjdj30mw0e876h.jpg\" alt=\"\"></p>\n<h6 id=\"第二步：hexo-d\"><a href=\"#第二步：hexo-d\" class=\"headerlink\" title=\"第二步：hexo d\"></a>第二步：hexo d</h6><p> 然后我们执行 <code>hexo d</code> 这一步暂时我们可以认为就是对public中的文件进行push到我们的git仓库的过程。所以在我们的仓库中 <code>XXXXXX.bitbucket.io</code> 大家看到的文件只有public中的文件。</p>\n<h6 id=\"附加：hexo-clean\"><a href=\"#附加：hexo-clean\" class=\"headerlink\" title=\"附加：hexo clean\"></a>附加：hexo clean</h6><p> 其实这一步是和gitflow没有关系的，但是既然讲到流程我这边也在说下，之前说过这步是用来清理缓存的，其实他的作用是运行在第一步之前，将整个public文件删除，然后我们再执行 <code>hexo g</code> 重新渲染进public，之后再 <code>hexo d</code> 进行部署，这样就避免之前的内容对我们造成影响。</p>\n<h4 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h4><p> 通过上一步流程我们知道如果git服务器上只有public是不够的，我们需要有我们整个博客文件夹下的所有文件才能进行多终端操作。所有这边有两个方法：</p>\n<ul>\n<li><p>新建另一个仓库我们暂时命名为MyProject，把我们所有的文件传到这个Git仓库上，当我们换另一台电脑时候我们直接拉这个新仓库的代码然后进行写作 -&gt; 三步走最后在将所有文件推到MyProject以后所有的git操作都在这个仓库中进行。</p>\n</li>\n<li><p>git给我们提供了多分支操作，我们可以做xxxx.github.io这个仓库中创建一个新的分支暂时命名为hexo分支，这个分支的作用和上一个方法里MyProject的作用以及里面的文件一模一样，只不过我们这个方法就省的我们再创建一个仓库了。以后所有的git操作都去这个分支进行，本地的文件一直保持在这个分支就行，不过有一点需要注意的就是，即使所有的操作都在hexo分支下进行也必须保证master分支为主分支(default branch)，不然你就打不开你的博客了。</p>\n<p>以上两种都是属于基本的git操作，本文不再赘述。不过有一点这里要强调下，还记一开始我跟大家说的主题的是推荐大家直接去主题所在的repo下载zip然后解压拖进博客目录里面吗？如果你不是拖拽进来的而是clone下来的话在这一步你会涉及到git的 add submodule操作。其实操作不难，具体的命令网上也是大把。不过如果你像我一样使用bitbucket的话可能发现无法进行submodule操作，不知道这个是bitbucket的BUG还是什么其他原因，同样的命令使用github托管博客的时候是没有问题的，而bitbucket就不行，当你使用另一台电脑的进行拉去的时候执行 <code>git submodule init</code> 操作的时候他会提示找不到。至今未解决，如果哪位大神有什么方法及时联系我。</p>\n</li>\n</ul>\n<h2 id=\"十：绑定个人域名\"><a href=\"#十：绑定个人域名\" class=\"headerlink\" title=\"十：绑定个人域名\"></a>十：绑定个人域名</h2><h4 id=\"注意：bitbucket-从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明\"><a href=\"#注意：bitbucket-从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明\" class=\"headerlink\" title=\"注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明\"></a><font color=\"red\">注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明</font></h4><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7pq9gdqzj31a20psaf0.jpg\" alt=\"\"></p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>在github上创建仓库，仓库的名字为 username.github.io。然后修改站点配置文件中部署地址（repo对应的字段），将原本的bitbucket的仓库地址改为github的地址</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7pve5iwgj312u0a0401.jpg\" alt=\"\"></p>\n<p>之后进行保存然后三步走，部署成功后你的博客就从bitbucket上迁移到github中了，这样一来，你整体的博客仓库还是在bitbucket中的私有库中，但是public文件夹中的公开文件已经被你部署到github的仓库中。该保密的信息仍然保密，同时也不影响你绑定自己的域名，一举两得。正常情况下按照上面步骤完成后的博客地址是 xxx.github.io，下面就开始绑定自己的域名。</p>\n<h4 id=\"域名购买\"><a href=\"#域名购买\" class=\"headerlink\" title=\"域名购买\"></a>域名购买</h4><p>这个渠道有很多，我就不再一一赘述，我这边以<a href=\"https://wanwang.aliyun.com/domain/searchresult/?keyword=nihyao&amp;suffix=.cn&amp;domaintype=zh%2Cen#/?keyword=test&amp;suffix=cn\" target=\"_blank\" rel=\"noopener\">阿里云的万网域名购买</a>为例,找到合适自己的域名</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7pjuuq4mj313u0hkqdt.jpg\" alt=\"\"></p>\n<h4 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h4><p>购买域名并且按照他的步骤实名认证之后，需要把域名解析到我们的博客中，在阿里云的控制台找到域名右侧对应的解析按钮。点击然后添加解析</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7q32hh49j31800h5ae1.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7q3yyhfij31780anq46.jpg\" alt=\"\"></p>\n<p>然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7q5sss5oj30kr0bkq3n.jpg\" alt=\"\"></p>\n<p>之后记得启用该记录，不过如果你像我一样是阿里云购买并且配置的话是不需要启用的，默认帮你启用。</p>\n<h4 id=\"仓库配置\"><a href=\"#仓库配置\" class=\"headerlink\" title=\"仓库配置\"></a>仓库配置</h4><p>然后回到你的github仓库，进入你的仓库设置页面，找到如下字段，在红框处添加你的域名，然后保存即可</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7qbo2111j30t10i7goa.jpg\" alt=\"\"></p>\n<h4 id=\"博客配置\"><a href=\"#博客配置\" class=\"headerlink\" title=\"博客配置\"></a>博客配置</h4><p>回到你的博客目录，在source目录下创建一个<font color=\"red\">不带任何后缀的</font>文件，命名为 CNAME，里面填写你的域名，我是这样，只添加你的域名不要添加其他东西。然后保存 执行三步之后就可以通过你的域名访问你的博客啦，如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7qe2vzuzj30s202ydfw.jpg\" alt=\"\"></p>\n<h2 id=\"十一：实现https协议\"><a href=\"#十一：实现https协议\" class=\"headerlink\" title=\"十一：实现https协议\"></a>十一：实现https协议</h2><p>按照以上步骤完成后可以通过域名访问，但是有个问题就是如果你用谷歌浏览器或者Safari，他就会提示你网站不被信任，只有你点击仍要继续才会展示你的博客，并且地址栏里面还是有个红色的×，虽说不影响使用和阅读，但是还是感觉别扭，这次我们来讲如何将自己的博客协议改为Https。这里有几种方法：</p>\n<ul>\n<li><p>购买证书</p>\n</li>\n<li><p>使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制</p>\n</li>\n<li><p>使用CDN进行反向代理</p>\n</li>\n</ul>\n<p>如果使用上两步的话基本上证书的服务商都会告诉你如何配置，他们的文档讲的一定比我的详细，不过主要原因是我们使用的github Page是不支持上传证书的，所以这里主要说下第三步，通过CDN配置反向代理，这里就需要用到一个国外的CDN服务提供商<a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"noopener\">Cloudflare</a>:</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7utpfih2j30wz07mju7.jpg\" alt=\"\"></p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"noopener\">Cloudflare</a> 提供DNS解析服务，而且速度很快，在阿里云半个小时才能生效的解析在它这里瞬间就生效，它提供了免费的https服务(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7v9apbogj30t004ydg6.jpg\" alt=\"\"></p>\n<p>用户看到的小锁其实是用户连接到Cloudflare的证书，而由Cloudflare到github是没有https的，不过对于我们静态博客已经够了。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><h6 id=\"第一步：\"><a href=\"#第一步：\" class=\"headerlink\" title=\"第一步：\"></a>第一步：</h6><p>还是先去官网注册，然后添加你的域名，注意添加的是你购买的域名。</p>\n<h6 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h6><p>进入DNS解析界面填入如下解析，因为我们使用clouldflare做DNS解析所以一会我们需要把我们购买域名的那个地方的解析删掉。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7vibz0a6j30rv0kagns.jpg\" alt=\"\"></p>\n<p>其中前两个是使你的域名指向github的服务器地址，github文档中给的就是这个两个地址，最后那个CNAME记录指向的是你的github仓库域名username.github.io。一定要严格按照这个来配置。</p>\n<h6 id=\"第三步：\"><a href=\"#第三步：\" class=\"headerlink\" title=\"第三步：\"></a>第三步：</h6><p>记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把你域名购买处（我的是阿里云）的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为我们以后就靠clouleflare来解析DNS啦。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7vnm5itzj30qy03c74a.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7vqjin22j316i0ib77n.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7vse0wewj316u09tmys.jpg\" alt=\"\"></p>\n<h6 id=\"第四步：\"><a href=\"#第四步：\" class=\"headerlink\" title=\"第四步：\"></a>第四步：</h6><p>回到clouldflare 上面选择crypto选项然后下面选择full或者是Flexible</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7vwnoasij30wx0f8myk.jpg\" alt=\"\"></p>\n<p>选项中几个的区别如下图</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7vxck29zj30k00cv0sp.jpg\" alt=\"\"></p>\n<p>最后那个是需要证书支持的。然后滚动到下面打开always use HTTPS开关</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7vy66223j30rn06dwet.jpg\" alt=\"\"></p>\n<h6 id=\"第五步：\"><a href=\"#第五步：\" class=\"headerlink\" title=\"第五步：\"></a>第五步：</h6><p>以上步骤配置好之后基本就完成了，但是如果直接有人在地址栏里面输入<a href=\"http://XXXXX\" target=\"_blank\" rel=\"noopener\">http://XXXXX</a> 进入你的博客的话你这边还是会出现非Https的效果，所以我们这里要做一个强制跳转。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7w1ksr94j30uu0ir76a.jpg\" alt=\"\"></p>\n<p>这样就万无一失了。</p>\n<h6 id=\"坑点：\"><a href=\"#坑点：\" class=\"headerlink\" title=\"坑点：\"></a>坑点：</h6><p>我之前按照以上步骤操作完成后发现首页虽然是https了也不显示红叉了，但是也没有显示绿色的小锁，而是一个叹号，但是有些博文页面可以正常显示https绿锁。后来发现是因为当前页面中有非https的链接导致，比如图片图床不是https的，或者评论插件不支持https，不过我博客中使用的来必力评论是支持https，只是我当时的图床无都是http所以只能是显示叹号了，后来把所有图片图床换成https的就好啦。</p>\n<h2 id=\"十二：为博客添加音乐\"><a href=\"#十二：为博客添加音乐\" class=\"headerlink\" title=\"十二：为博客添加音乐\"></a>十二：为博客添加音乐</h2><p>HEXO博客添加的音乐的地方有两个。一个个首页侧边栏，另一个是每个页面里面。但是个人觉得添加侧边栏里面并不好，因为添加侧边栏的话用户只有在浏览你首页的时候才能听到音乐，而且期间不能点击任何站内链接，否则音乐就会中断，试想下，一般首页都是文章列表，点击文章里面之后才是正文，所以用户在首页停留的时间很短，基本上找到自己想看的文章就会马上点进去看，所以这里放音乐没有太大意义；而页面内插入音乐会更好点，读者可以一边浏览文章一边听音乐，这也正是我们想要的。不过解决前者问题的办法也不是没有，比如点击链接的话直接开另一个浏览器标签来打开新页面也可以做到不中断音乐，但是总觉得有点小题大做了。总不能读者看个你的博客而占用了一堆标签。</p>\n<h4 id=\"网易云音乐外链\"><a href=\"#网易云音乐外链\" class=\"headerlink\" title=\"网易云音乐外链\"></a>网易云音乐外链</h4><p>这个是最简单的方法，通过网易云音乐官网生成播放器外链。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fordugrc80j315s0swthy.jpg\" alt=\"\"></p>\n<p>可以自己配置一些属性，然后自动生成配置代码，放到你的博客里面就行啦，粘贴到你文章中想要的地方</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1forduyu7laj31hm0zkaft.jpg\" alt=\"\"></p>\n<p>优点缺点截图上也有，不过网上也说这样的方式会影响SEO，具体什么原理也不太清楚。总之简单便捷，不过网易的logo去不掉。</p>\n<h4 id=\"aplayer添加音乐\"><a href=\"#aplayer添加音乐\" class=\"headerlink\" title=\"aplayer添加音乐\"></a><a href=\"https://aplayer.js.org/docs/#/?id=options\" target=\"_blank\" rel=\"noopener\">aplayer</a>添加音乐</h4><p>这个算是HEXO最常用也是最出名名的播放器了，还有Dpleyer是用来视屏播放的，暂时我们不说。首先需要安装aplayer依赖，终端中切换到你的博客根目录执行 <code>npm install aplayer --save</code> 安装成功后就可以了。参数就不给大家一一讲解了，官方文档都有，我这里只提供一个例子。</p>\n<h6 id=\"页面中添加音乐\"><a href=\"#页面中添加音乐\" class=\"headerlink\" title=\"页面中添加音乐\"></a>页面中添加音乐</h6><figure class=\"highlight perl\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% aplayerlist %&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"autoplay\"</span>: true,</span><br><span class=\"line\">    <span class=\"string\">\"showlrc\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">\"mutex\"</span>: true,</span><br><span class=\"line\">    <span class=\"string\">\"music\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"title\"</span>: <span class=\"string\">\"에필로그 (Epilogue)\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"author\"</span>: <span class=\"string\">\"이동준\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"pic\"</span>: <span class=\"string\">\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"lrc\"</span>: <span class=\"string\">\"https://歌词.lrc\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码插到文章中任意一个你想的地方就可以</p>\n<p>pic就是歌曲显示图片的链接。大家可以看到music是个数组，所以想添加列表的话就在数组中再添加个歌曲字典就好了。建议歌词lrc要用URL形式，不然txt格式可能要编辑死。。好多人问歌曲的MP3外链从哪里来。这个其实很简单，首先把歌曲下载下来然后上传到七牛云就可以在七牛云生成外链啦，七牛云有免费的存储空间，只存歌曲的话足够啦。歌词URL</p>\n<h6 id=\"侧边栏中添加音乐\"><a href=\"#侧边栏中添加音乐\" class=\"headerlink\" title=\"侧边栏中添加音乐\"></a>侧边栏中添加音乐</h6><p>其实之前讲过，不建议在侧边栏中添加，但是这里还是简单介绍下。首先要做的是在<code>node_modules</code> 目录下找到 <code>APlayer.min.js</code> 文件，将其复制到 <code>theme/next/source/js/src/</code> 目录下。然后打开 <code>theme/next/layout/_custom/</code> 文件夹下的 <code>sidebar.swig</code> 文件，向其中添加以下代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aplayer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/js/src/APlayer.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\"><span class=\"keyword\">var</span> ap = <span class=\"keyword\">new</span> APlayer(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    element: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'player1'</span>),                       <span class=\"comment\">// Optional, player element</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    narrow: <span class=\"literal\">false</span>,                                                     <span class=\"comment\">// Optional, narrow style</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    autoplay: <span class=\"literal\">false</span>,                                                    <span class=\"comment\">// Optional, autoplay song(s), not supported by mobile browsers</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    showlrc: <span class=\"number\">0</span>,                                                        <span class=\"comment\">// Optional, show lrc, can be 0, 1, 2, see: ###With lrc</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    mutex: <span class=\"literal\">true</span>,                                                       <span class=\"comment\">// Optional, pause other players when this player playing</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    theme: <span class=\"string\">'#e6d0b2'</span>,                                                  <span class=\"comment\">// Optional, theme color, default: #b7daff</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    mode: <span class=\"string\">'random'</span>,                                                    <span class=\"comment\">// Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    preload: <span class=\"string\">'metadata'</span>,                                               <span class=\"comment\">// Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    listmaxheight: <span class=\"string\">'513px'</span>,                                             <span class=\"comment\">// Optional, max height of play list</span></span></span><br><span class=\"line\"><span class=\"undefined\">    music: [</span></span><br><span class=\"line\"><span class=\"actionscript\">    &#123;                                                           <span class=\"comment\">// Required, music info, see: ###With playlist</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        title: <span class=\"string\">'Sometimes When We Touch'</span>,                                          <span class=\"comment\">// Required, music title</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        author: <span class=\"string\">'Oliveia'</span>,                                              <span class=\"comment\">// Required, music author</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        url: <span class=\"string\">'https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/SometimesWhenWeTouch.mp3'</span>,  <span class=\"comment\">// Required, music url</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        pic: <span class=\"string\">'https://y.gtimg.cn/music/photo_new/T002R300x300M000003LIDEL0NQInJ.jpg?max_age=2592000'</span>,  <span class=\"comment\">// Optional, music picture</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        lrc: <span class=\"string\">'https://歌词.lrc'</span>                   <span class=\"comment\">// Optional, lrc, see: ###With lrc</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">    &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"title\"</span>: <span class=\"string\">\"大鱼\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"author\"</span>: <span class=\"string\">\"周深\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"pic\"</span>: <span class=\"string\">\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"lrc\"</span>: <span class=\"string\">\"https://歌词.lrc\"</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    ]</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>只是换成了JS的语法，其实原理，参数都一样。然后执行三步走就可以看到啦，注意有浏览器缓存，所以多刷新几次就会有了。</p>\n<h6 id=\"歌词、音乐外链相关\"><a href=\"#歌词、音乐外链相关\" class=\"headerlink\" title=\"歌词、音乐外链相关\"></a>歌词、音乐外链相关</h6><p>歌曲说过大家可以用七牛的免费存储功能，但是会发现一个问题七牛的歌曲外链不支持https，这会导致配置有ssl证书的人掉绿锁，其实如果有这个需求的大家可以放弃七牛，改用腾讯云，这样就OK啦，一样的操作。</p>\n<p>好多人问歌词的URL好难找啊，去哪里找呢，大家可以看下这个 <a href=\"https://github.com/metowolf/MetingJS\" target=\"_blank\" rel=\"noopener\">MeetingJS</a>这个其实是基于Aplayer的一个小封装，目的是简化Aplayer的接入成本，但是因为之前我介绍了接入步骤所以这里我们只用它的歌词API就可以。<code>ttps://demo.meting.api.meto.moe/action/metingapi?server=tencent&amp;type=lrc&amp;id=004OQ5Mt0EmEzv</code> 其中要改的只有两个参数seaver是音乐平台包含百度、网易、QQ音乐等平台</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1forkjr7da0j31be0ns43n.jpg\" alt=\"\"></p>\n<p>id字段对应的是歌曲的ID 这个你只要打开个歌曲网页链接里面应该都包含id。文章结尾的播放就是这么加入的</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>整篇文章只有开始一小部分在讲解如何搭建博客，后续的基本都是交给大家如何优化，调整一些细节问题如UI、用户体验之类的，当然我们能做的远远不止这些，如果有什么问题欢迎与我探讨。下面的留言我都会看的。此外当本人对HEXO有新的看法或者玩法的话该文章会不断的更新，希望大家关注我的<a href=\"https://oliverqueen.cn/\">小站</a>，感谢。</p>\n\n\t\t\t<div id=\"aplayer1\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"凉城\",\"author\":\"任然\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/liangcheng.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000008nl2Y1HlxUm.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002SKEeh1VzObP\"},{\"title\":\"Love Story\",\"author\":\"린 (LYn)\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"},{\"title\":\"大鱼\",\"author\":\"周深\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer1\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>作为一个开发者不能没有博客，最近花了几天的时间搭建了这个博客，处理了很多细节，在这篇文章中我会把我从开始到现在以及后续的优化整理出来，帮助更多的人搭建、维护、更新、自己的博客。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnsy5fhyhsj31hc0xchdt.jpg\" alt=\"\"></p>\n<p>一开始我所有的博客都写在新浪微博，因为微博上更容易推广自己的文章，微博用户量大，但是后来微博的弊端慢慢的显示出来了，毕竟不是开发者的天地，我的博客中经常会插入大量的代码，而微博不支持markdown编辑，普通的编辑器对代码块的兼容性非常差，别说高亮了，有时候排版都会错乱，最后外观很不好看，如下图：</p>","more":"<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnsxwzb745j31i20tuad4.jpg\" alt=\"微博代码\"></p>\n<p>而且微博的账号系统也存在一定的弊端，所以后来转向简书、掘金等技术平台，不得不承认相对于微博来说这些平台对开发者就要友好多了，不过后来又发现一个问题。因为我在写文章的时候使用的是本地的markdown编辑器，而这些平台对markdown语法的一些小细节并不严谨或者说统一如下图：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnsy0p6no4j316q0nsn2v.jpg\" alt=\"简书VS掘金\"></p>\n<p>两个平台的编辑器无法做到统一，以至于每次写完文章都需要针对两个平台做不同的修改。</p>\n<p>综上所述，最简单的也最一劳永逸的方法就是搭建自己的博客平台，而HEXO很好的帮我们解决了这个问题，其实对于一个开发者来说并不是什么难事，整个流程对于大部分有代码基础的开发者来说一上午时间就可以搞定，不过最难的也是最头痛的就是对细节的调整，对UI的修改、优化等，不过本文会对此逐一讲解。</p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ul>\n<li><p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a></p>\n<p>cURL:</p>\n<p><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p>\n<p>Wget:</p>\n<p><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p>\n<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>\n<p><code>$ nvm install stable</code></p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a></p>\n<p>一般的开发者不会没有这个吧，我是安装Xcode就会有这个了，</p>\n<p>使用 Homebrew, MacPorts ：brew install git;或下载 <a href=\"https://sourceforge.net/directory/\" target=\"_blank\" rel=\"noopener\">安装程序</a> 安装</p>\n</li>\n<li><p><a href=\"https://bitbucket.org/\" target=\"_blank\" rel=\"noopener\">bitbucket</a>账号</p>\n<p>一般都会使用HEXO+GitHub page的形式搭建自己的博客，但是这里有个问题就是GitHub是开源的，任何人都能在上面看到你的源代码，虽然这并没有什么太大的影响，不过对于我来说感觉怪怪的，所以我就用了bitbucket page来处理我的博客，所有的东西都一样只不过这个是个私有库罢了（免费五个人）</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnt1nn8k9uj30b308amye.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"开始建站\"><a href=\"#开始建站\" class=\"headerlink\" title=\"开始建站\"></a>开始建站</h2><h4 id=\"第一步：创建仓库\"><a href=\"#第一步：创建仓库\" class=\"headerlink\" title=\"第一步：创建仓库\"></a>第一步：创建仓库</h4><p>进入github/bitbucket（后续都以github为例）新建repo，这里要注意repo的名字一定要满足<code>your Account Name</code>/github.io。如果是bitbucket那就是<code>your Account Name</code>/bitbucket.io，因为只有这样的仓库名称最后才能以静态页面展示。如图：XXX的内容一定要与红色的框里的文本一致。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fntzjgvzvyj30q006nmy0.jpg\" alt=\"\"></p>\n<h4 id=\"第二步：创建本地文件夹\"><a href=\"#第二步：创建本地文件夹\" class=\"headerlink\" title=\"第二步：创建本地文件夹\"></a>第二步：创建本地文件夹</h4><p>创建文件夹之后CD到你创建的文件夹中执行hexo的初始化相关命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install</span></span><br></pre></td></tr></table></figure>\n<p>执行完毕之后你的文件夹里就有内容了，标准的目录结构是这样（只列出几个必要的文件夹及其子目录）</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── <span class=\"variable\">_config</span>.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── <span class=\"variable\">_drafts</span></span><br><span class=\"line\">|   └── <span class=\"variable\">_posts</span></span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>_config.yml：<br>其中我们以后的大部分操作都会在<code>_config.yml</code>中进行，这个文件是我们的站点的配置文件。</p>\n</li>\n<li><p>scaffolds：<br>模板文件，规定了我们创建一篇文章的时候最开始的样子，</p>\n</li>\n<li><p>source：<br>可以暂时的理解成我们文章的存放处</p>\n</li>\n<li><p>themes：<br>主题文件</p>\n</li>\n</ul>\n<h4 id=\"第三步：部署到Git\"><a href=\"#第三步：部署到Git\" class=\"headerlink\" title=\"第三步：部署到Git\"></a>第三步：部署到Git</h4><p>修改我们的的站点配置文件<code>_config.yml</code>中如下字段</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fntzzwn8dkj30w0058wga.jpg\" alt=\"\"><br>其中：</p>\n<ul>\n<li><p><code>type</code>值对应的是你所部署的的服务器类型，我们这里填写git就可以。</p>\n</li>\n<li><p><code>repo</code>是你的仓库地址，也就是仓库克隆的地址，推荐用https的链接。</p>\n</li>\n<li><p><code>branch</code>不写默认是master，通常我们写成master就可以。</p>\n</li>\n</ul>\n<p>以上配置完成后保存 然后回到终端执行<code>npm install hexo-deployer-git --save</code>安装一个插件，这样才能将你写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步)</p>\n<ul>\n<li><p><code>hexo clean</code>  清理缓存  </p>\n</li>\n<li><p><code>hexo generate</code> 进行渲染 简写 <code>hexo g</code></p>\n</li>\n<li><p><code>hexo server</code> 部署到本地(调试使用) 简写 <code>hexo s</code>。然后浏览器输入 <code>http://localhost:4000</code> 就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得 <code>control + C</code> 关闭本地端口，不然下次就进不去啦)</p>\n</li>\n<li><p>调试完毕后使用 <code>hexo deploy</code> 简写为 <code>hexo d</code>来部署到git服务器。</p>\n</li>\n</ul>\n<p>执行完以上操作后打开浏览器地址了输入<code>http://你github名字.github.io</code>就可以看看到效果啦，这回是所有人都能看到的，用手机也可以。至此第三步已经完成,最终的结果如下图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu0jxw383j310l0gcdrk.jpg\" alt=\"\"></p>\n<h4 id=\"第四步：写文章\"><a href=\"#第四步：写文章\" class=\"headerlink\" title=\"第四步：写文章\"></a>第四步：写文章</h4><p>使用如下命令 <code>hexo new post “文章名字”</code> 就可新建文章啦，建立好的文章在 <code>source/_posts</code> 中，你可以用markdown语法编辑内容就可以。编辑完成后执行第三步中终端的操作就可以啦，刷新下浏览器就可看到你的新文章啦。如下图:</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu0ml6lp4j310n0g9tjv.jpg\" alt=\"\"></p>\n<h2 id=\"个性化\"><a href=\"#个性化\" class=\"headerlink\" title=\"个性化\"></a>个性化</h2><h4 id=\"一：主题\"><a href=\"#一：主题\" class=\"headerlink\" title=\"一：主题\"></a>一：主题</h4><h6 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h6><p>主题是我么个性化的基础和前提，我们想做任何个性化上的修改基本上都是在我们主题上的修改，先找到一个自己满意的主题是首要任务。关于主题网上有很多很多，<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">HEXO官方的主题目录</a>也收录了好多来着世界各地开发者的主题。或者开发者也可以直接去网上搜索HEXO theme关键字来获取主题。</p>\n<h6 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h6><p>主题一般都是repo，只要讲起clone到博客目录themes/XXXX下就可了，XXXX对应的就是你给主题起的名字，像这样：<code>git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet</code> 这样就可以保证每次主题的作者有更新了我们就可以 pull获取更新。不过这样有个问题后面我会在HEXO多终端同步一栏讲到，所以这里我们选择另一种方式去安装，就是直接把主题的repo下载下来<br>然后解压放到themes中。其实对于已经稳定的主题作者一般不会频繁更新，不稳定的主题我们也不会用，所以用后者安装也是一样的。</p>\n<p>然后我们回到刚才的站点配置文件中<code>_config.yml</code>修改如下字段，对应的名字就是你刚才那个主题文件夹的名字：我这边是next，</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fnu5dr697rj312006a0tp.jpg\" alt=\"\"></p>\n<p>然后保存，再去终端执行那三步，接着刷新网页就可以看到新的界面啦。下面是我换了NEXT主题刷新后的效果。因为该注意已经非常完善，所有后续用该主题做例子来讲</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu5ohsltng30go097e83.gif\" alt=\"\"></p>\n<h4 id=\"二：主题菜单\"><a href=\"#二：主题菜单\" class=\"headerlink\" title=\"二：主题菜单\"></a>二：主题菜单</h4><h6 id=\"添加按钮\"><a href=\"#添加按钮\" class=\"headerlink\" title=\"添加按钮\"></a>添加按钮</h6><p>主题菜单也可以说是主题按钮。也就是上面顶部的两个，next主题默认的两个是Home、Archive，我们一般会加上tag about category等。这些都是需要在主题上进行修改，我们需要修改主题的配置文件，首先在主题的文件夹下找到<code>_config.yml</code>文件，没错和之前的站点配置文件同名，只不过他们的路径不同，大家千万不要弄混，站点配置文件是配置站点通用的东西，而主题配置文件是配置一些主题的元素。在主题配置文件找到menu字段</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu69gaksbj312s0cijtz.jpg\" alt=\"\"></p>\n<p>可以看到主题作者注释掉了一部分按钮只保留了两个最基本的，这里需要注意前面的Key并不是代表的是按钮名字，因为该主题是支持多语言，所以这个key只是个标识，具体的按钮名字要去该路径下查找</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fnu6e4quu7j30fa0zkwgi.jpg\" alt=\"\"></p>\n<p>其中每一个文件对应了不同的语言，我们以汉语为例，进入<code>zh-Hans.yml</code>中修改这些字段</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnu6fypjr7j30ay054wes.jpg\" alt=\"\"></p>\n<p>其中key就是之前我们在主题配置文件中的key，而后面的value则是简体中文状态下按钮的名字。修改完成后我们保存执行那三步就可以看到我们新添加的按钮了。</p>\n<h6 id=\"添加页面\"><a href=\"#添加页面\" class=\"headerlink\" title=\"添加页面\"></a>添加页面</h6><p>添加按钮后我们需要点击按钮显示统一的页面。这时候我们需要添加页面。以tag页面为例，hexo中添加页面的命令是<code>hexo new page XXXXX</code> 后面XXX则是要添加页面的名称，我们这里写tags。为了测试新建的tag页面我们对之前的页面添加个tag。去 source/_post中找一篇文章我们在开头添加如下字段,多标签以此类推</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnu6nmt2ywj30v00f4jsi.jpg\" alt=\"\"></p>\n<p>然后编辑我们刚才生成的tag页面(<code>source/tags/index.md</code>)指定其type为tags</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu6q39ak4j310y09e3zb.jpg\" alt=\"\"></p>\n<p>然后保存执行那三步就会有如下效果</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fnu6vtcn1og30gn07fhe0.gif\" alt=\"\"></p>\n<p>点击对应的tag即可跳转到改tag所对应的文章。其他页面同理。</p>\n<h4 id=\"三：添加阅读更多button\"><a href=\"#三：添加阅读更多button\" class=\"headerlink\" title=\"三：添加阅读更多button\"></a>三：添加阅读更多button</h4><p>我们在首页的时候其实就是我们的文章列表，但是这时候有个问题，如果我们某一篇或者某几篇文章很长，那首页是不是更长呢？其实在首页我们可以只显示文章部分内容，通过点击阅读更多按钮来进入文章详情。这个时候就需要截断文章。我们在文章的合适地方采用<code>&lt;!--more--&gt;</code>来截断,用默认文章来看</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu73u6xghj313o0hujuz.jpg\" alt=\"\"></p>\n<p>然后执行那三步就会如下效果</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fnu75xee1rj31kw0iomzf.jpg\" alt=\"\"></p>\n<p>点击阅读更多。</p>\n<h4 id=\"四：更改主题背景\"><a href=\"#四：更改主题背景\" class=\"headerlink\" title=\"四：更改主题背景\"></a>四：更改主题背景</h4><p>首先找到如下路径 <code>themes\\next\\source\\css_custom\\custom.styl</code> 会发现里面是空的，这个文件是Next主题为我们预留的做一些自定的css样式的地方，我们添加如下代码。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//背景图片相关</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (min-width:<span class=\"number\">1200px</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:url(/images/bg.jpg);</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-attachment</span>:fixed;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>:<span class=\"number\">50%</span> <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">#f</span>ooter a &#123;</span><br><span class=\"line\">        color:<span class=\"number\">#eee</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里大家应该就可以看出括号里面的图片路径就是我们的背景图片，我们只需把图片放入 <code>themes\\next\\source\\images</code> 中即可，记住图片名字要写对，要有后缀。同理括号里面我们可以直接放一个图片的链接比如 <code>https://tpc.googlesyndication.com/simgad/6893153702744595670</code> 做完这些操作保存，然后执行那三步即可看到效果，不过可能浏览器有缓存，可以清理下缓存再刷新看看。</p>\n<h4 id=\"五：修改博客背景透明度\"><a href=\"#五：修改博客背景透明度\" class=\"headerlink\" title=\"五：修改博客背景透明度\"></a>五：修改博客背景透明度</h4><p>既然再上一步中修改了背景图片，如果被NExt本身的白色挡住确实不好看，我们可以尝试把本身的白色背景变成透明的，这样会美观很多，同样还是修改刚才的文件 <code>themes\\next\\source\\css_custom\\custom.styl</code> 在上一步的基础上我们可以添加如下代码<br> <figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改变背景色和透明度</span></span><br><span class=\"line\"><span class=\"selector-class\">.main-inner</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0.9</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 其中第一个属性为颜色值，第二个属性就是我们的透明度啦。适当修改，不然会适得其反连字都看不清啦。做完上两步就是我的这个博客的效果。</p>\n<h4 id=\"六：修改作者头像为圆形，\"><a href=\"#六：修改作者头像为圆形，\" class=\"headerlink\" title=\"六：修改作者头像为圆形，\"></a>六：修改作者头像为圆形，</h4><p> 我们默认是方形的头像，想修改为圆形的话同样是上两步的那个路径下添加如下代码<br> <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.site-author-image</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> dashed <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: cycle <span class=\"number\">2s</span> <span class=\"number\">0.5s</span> forwards;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-radius <span class=\"number\">2s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 保存 -&gt; 三步 即可看到效果</p>\n<p> <img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fnxgsh0p7bj308e06jq3t.jpg\" alt=\"\"></p>\n<h4 id=\"七：添加背景动画\"><a href=\"#七：添加背景动画\" class=\"headerlink\" title=\"七：添加背景动画\"></a>七：添加背景动画</h4><p> 背景动画使用Js来处理，会JS的同学可以自己写喜欢的动画，我这边就用了网上比较通用的动画。找到以下路径 <code>themes\\next\\layout\\_layout.swig</code> 在文章 <code>&lt;/body&gt;</code>的上面添加如下代码<br> <figure class=\"highlight django\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span></span></span></span><br><span class=\"line\"><span class=\"xml\">color=\"255,255,255\" opacity='1' zIndex=\"-2\" count=\"100\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;<span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endif</span></span> %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure></p>\n<p> 然后 保存 -&gt; 三步即可看到效果 其中src为JS的路径，有兴趣的可以自定义效果。</p>\n<h4 id=\"八：添加评论页面\"><a href=\"#八：添加评论页面\" class=\"headerlink\" title=\"八：添加评论页面\"></a>八：添加评论页面</h4><p> HEXO的评论页面官方推荐了disqus，无奈已经被墙，即使开发时候自己有克服的方法但是也不能保证所有看你博客的人都有克服的方法。所有我们打算采用其他的的一些第三方来实现，首先先对市面上的几个产品做下对比：</p>\n<h6 id=\"比较：\"><a href=\"#比较：\" class=\"headerlink\" title=\"比较：\"></a>比较：</h6><ul>\n<li><p>disqus</p>\n<p>比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。暂不考虑</p>\n</li>\n<li><p>多说<br>国内比较出名的评论系统，已经关闭服务暂不考虑。</p>\n</li>\n<li><p>gitment<br>一款基于github issue的评论系统，风格很像github，只是目前还不是太稳定，且界面无法自定，可能会于博客有些不协调。而且评论需要github账号</p>\n</li>\n<li><p>livere<br>中文名字叫来必力，是一款韩国的评论系统，在不带有任何民族情感的前提下来看确实棒子的东西还是不错的，也是我目前在使用的一款，我主要用它的原因有几点</p>\n<ul>\n<li><p>支持很多种格式的评论导入，你可以很方便的吧之前在其他平台上的评论数据导入进来，支持多种json格式。</p>\n</li>\n<li><p>简介的UI提供多种主题。</p>\n</li>\n<li><p>国外的东西不受国内的限制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"集成：\"><a href=\"#集成：\" class=\"headerlink\" title=\"集成：\"></a>集成：</h6><p>先去<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">livere的官网</a>注册m，具体过程我就不讲了，一步一步安她的来就行，之后他会给你一个安装代码，像这样：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnxhkvhulnj30pt0ikq5e.jpg\" alt=\"\"></p>\n<p>里面主要的信息就是data-uid。<br>NEXT主题本身是已经集成了livere评论的，只不过被注释掉了。找到主题配置文件 <code>_config.yml</code> 找到如下代码</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnxhhj8slmj312o06kmyi.jpg\" alt=\"\"></p>\n<p>打开注释填入你在livere中注册后它给你的UID即可。然后 保存 -&gt; 三步即可。</p>\n<h2 id=\"九：多终端操作\"><a href=\"#九：多终端操作\" class=\"headerlink\" title=\"九：多终端操作\"></a>九：多终端操作</h2><h4 id=\"背景-1\"><a href=\"#背景-1\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>大家都知道HEXO是静态博客，所有的页面都是静态的通过本地文件渲染然后再部署上去，这就带来一个多终端部署的问题，比如公司电脑配置好了，想回家在进行写作，发现家里什么都没有还需要重新配置环境，不过这倒是次要，关键是如果不能保证两个终端的内容完全一样就会造成服务器上的数据会被最后一次部署覆盖，导致前几次的都被覆盖掉。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>其实大家应该也看出HEXO整体的一套流程下来就是git的工作流程，不管你用github还是bitbucket都是遵循gitflow的，而gitflow就是一种多终端多人协同工作的解决方案。所以我们可以用它来解决多终端同步的问题。</p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>我们先来了解下hexo的整体流程。我们正常的为文件夹结构如图：</p>\n<p> <img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnyf572x8nj30bu0fqgn0.jpg\" alt=\"\"></p>\n<h6 id=\"第一步：hexo-g\"><a href=\"#第一步：hexo-g\" class=\"headerlink\" title=\"第一步：hexo g\"></a>第一步：hexo g</h6><p> source文件夹下存放着我们的文章，tag、归档之类的信息，也就是我们的博客的内容。当我们在终端执行 <code>hexo g</code> 的时候会被source中的文件按照某种规则方式渲染成静态的页面文件放到public中：</p>\n<p> <img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fnyf8eyhjdj30mw0e876h.jpg\" alt=\"\"></p>\n<h6 id=\"第二步：hexo-d\"><a href=\"#第二步：hexo-d\" class=\"headerlink\" title=\"第二步：hexo d\"></a>第二步：hexo d</h6><p> 然后我们执行 <code>hexo d</code> 这一步暂时我们可以认为就是对public中的文件进行push到我们的git仓库的过程。所以在我们的仓库中 <code>XXXXXX.bitbucket.io</code> 大家看到的文件只有public中的文件。</p>\n<h6 id=\"附加：hexo-clean\"><a href=\"#附加：hexo-clean\" class=\"headerlink\" title=\"附加：hexo clean\"></a>附加：hexo clean</h6><p> 其实这一步是和gitflow没有关系的，但是既然讲到流程我这边也在说下，之前说过这步是用来清理缓存的，其实他的作用是运行在第一步之前，将整个public文件删除，然后我们再执行 <code>hexo g</code> 重新渲染进public，之后再 <code>hexo d</code> 进行部署，这样就避免之前的内容对我们造成影响。</p>\n<h4 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h4><p> 通过上一步流程我们知道如果git服务器上只有public是不够的，我们需要有我们整个博客文件夹下的所有文件才能进行多终端操作。所有这边有两个方法：</p>\n<ul>\n<li><p>新建另一个仓库我们暂时命名为MyProject，把我们所有的文件传到这个Git仓库上，当我们换另一台电脑时候我们直接拉这个新仓库的代码然后进行写作 -&gt; 三步走最后在将所有文件推到MyProject以后所有的git操作都在这个仓库中进行。</p>\n</li>\n<li><p>git给我们提供了多分支操作，我们可以做xxxx.github.io这个仓库中创建一个新的分支暂时命名为hexo分支，这个分支的作用和上一个方法里MyProject的作用以及里面的文件一模一样，只不过我们这个方法就省的我们再创建一个仓库了。以后所有的git操作都去这个分支进行，本地的文件一直保持在这个分支就行，不过有一点需要注意的就是，即使所有的操作都在hexo分支下进行也必须保证master分支为主分支(default branch)，不然你就打不开你的博客了。</p>\n<p>以上两种都是属于基本的git操作，本文不再赘述。不过有一点这里要强调下，还记一开始我跟大家说的主题的是推荐大家直接去主题所在的repo下载zip然后解压拖进博客目录里面吗？如果你不是拖拽进来的而是clone下来的话在这一步你会涉及到git的 add submodule操作。其实操作不难，具体的命令网上也是大把。不过如果你像我一样使用bitbucket的话可能发现无法进行submodule操作，不知道这个是bitbucket的BUG还是什么其他原因，同样的命令使用github托管博客的时候是没有问题的，而bitbucket就不行，当你使用另一台电脑的进行拉去的时候执行 <code>git submodule init</code> 操作的时候他会提示找不到。至今未解决，如果哪位大神有什么方法及时联系我。</p>\n</li>\n</ul>\n<h2 id=\"十：绑定个人域名\"><a href=\"#十：绑定个人域名\" class=\"headerlink\" title=\"十：绑定个人域名\"></a>十：绑定个人域名</h2><h4 id=\"注意：bitbucket-从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明\"><a href=\"#注意：bitbucket-从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明\" class=\"headerlink\" title=\"注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明\"></a><font color=\"red\">注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明</font></h4><p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7pq9gdqzj31a20psaf0.jpg\" alt=\"\"></p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>在github上创建仓库，仓库的名字为 username.github.io。然后修改站点配置文件中部署地址（repo对应的字段），将原本的bitbucket的仓库地址改为github的地址</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7pve5iwgj312u0a0401.jpg\" alt=\"\"></p>\n<p>之后进行保存然后三步走，部署成功后你的博客就从bitbucket上迁移到github中了，这样一来，你整体的博客仓库还是在bitbucket中的私有库中，但是public文件夹中的公开文件已经被你部署到github的仓库中。该保密的信息仍然保密，同时也不影响你绑定自己的域名，一举两得。正常情况下按照上面步骤完成后的博客地址是 xxx.github.io，下面就开始绑定自己的域名。</p>\n<h4 id=\"域名购买\"><a href=\"#域名购买\" class=\"headerlink\" title=\"域名购买\"></a>域名购买</h4><p>这个渠道有很多，我就不再一一赘述，我这边以<a href=\"https://wanwang.aliyun.com/domain/searchresult/?keyword=nihyao&amp;suffix=.cn&amp;domaintype=zh%2Cen#/?keyword=test&amp;suffix=cn\" target=\"_blank\" rel=\"noopener\">阿里云的万网域名购买</a>为例,找到合适自己的域名</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7pjuuq4mj313u0hkqdt.jpg\" alt=\"\"></p>\n<h4 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h4><p>购买域名并且按照他的步骤实名认证之后，需要把域名解析到我们的博客中，在阿里云的控制台找到域名右侧对应的解析按钮。点击然后添加解析</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7q32hh49j31800h5ae1.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7q3yyhfij31780anq46.jpg\" alt=\"\"></p>\n<p>然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7q5sss5oj30kr0bkq3n.jpg\" alt=\"\"></p>\n<p>之后记得启用该记录，不过如果你像我一样是阿里云购买并且配置的话是不需要启用的，默认帮你启用。</p>\n<h4 id=\"仓库配置\"><a href=\"#仓库配置\" class=\"headerlink\" title=\"仓库配置\"></a>仓库配置</h4><p>然后回到你的github仓库，进入你的仓库设置页面，找到如下字段，在红框处添加你的域名，然后保存即可</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7qbo2111j30t10i7goa.jpg\" alt=\"\"></p>\n<h4 id=\"博客配置\"><a href=\"#博客配置\" class=\"headerlink\" title=\"博客配置\"></a>博客配置</h4><p>回到你的博客目录，在source目录下创建一个<font color=\"red\">不带任何后缀的</font>文件，命名为 CNAME，里面填写你的域名，我是这样，只添加你的域名不要添加其他东西。然后保存 执行三步之后就可以通过你的域名访问你的博客啦，如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7qe2vzuzj30s202ydfw.jpg\" alt=\"\"></p>\n<h2 id=\"十一：实现https协议\"><a href=\"#十一：实现https协议\" class=\"headerlink\" title=\"十一：实现https协议\"></a>十一：实现https协议</h2><p>按照以上步骤完成后可以通过域名访问，但是有个问题就是如果你用谷歌浏览器或者Safari，他就会提示你网站不被信任，只有你点击仍要继续才会展示你的博客，并且地址栏里面还是有个红色的×，虽说不影响使用和阅读，但是还是感觉别扭，这次我们来讲如何将自己的博客协议改为Https。这里有几种方法：</p>\n<ul>\n<li><p>购买证书</p>\n</li>\n<li><p>使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制</p>\n</li>\n<li><p>使用CDN进行反向代理</p>\n</li>\n</ul>\n<p>如果使用上两步的话基本上证书的服务商都会告诉你如何配置，他们的文档讲的一定比我的详细，不过主要原因是我们使用的github Page是不支持上传证书的，所以这里主要说下第三步，通过CDN配置反向代理，这里就需要用到一个国外的CDN服务提供商<a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"noopener\">Cloudflare</a>:</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7utpfih2j30wz07mju7.jpg\" alt=\"\"></p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"noopener\">Cloudflare</a> 提供DNS解析服务，而且速度很快，在阿里云半个小时才能生效的解析在它这里瞬间就生效，它提供了免费的https服务(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7v9apbogj30t004ydg6.jpg\" alt=\"\"></p>\n<p>用户看到的小锁其实是用户连接到Cloudflare的证书，而由Cloudflare到github是没有https的，不过对于我们静态博客已经够了。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><h6 id=\"第一步：\"><a href=\"#第一步：\" class=\"headerlink\" title=\"第一步：\"></a>第一步：</h6><p>还是先去官网注册，然后添加你的域名，注意添加的是你购买的域名。</p>\n<h6 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h6><p>进入DNS解析界面填入如下解析，因为我们使用clouldflare做DNS解析所以一会我们需要把我们购买域名的那个地方的解析删掉。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7vibz0a6j30rv0kagns.jpg\" alt=\"\"></p>\n<p>其中前两个是使你的域名指向github的服务器地址，github文档中给的就是这个两个地址，最后那个CNAME记录指向的是你的github仓库域名username.github.io。一定要严格按照这个来配置。</p>\n<h6 id=\"第三步：\"><a href=\"#第三步：\" class=\"headerlink\" title=\"第三步：\"></a>第三步：</h6><p>记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把你域名购买处（我的是阿里云）的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为我们以后就靠clouleflare来解析DNS啦。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7vnm5itzj30qy03c74a.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7vqjin22j316i0ib77n.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7vse0wewj316u09tmys.jpg\" alt=\"\"></p>\n<h6 id=\"第四步：\"><a href=\"#第四步：\" class=\"headerlink\" title=\"第四步：\"></a>第四步：</h6><p>回到clouldflare 上面选择crypto选项然后下面选择full或者是Flexible</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fo7vwnoasij30wx0f8myk.jpg\" alt=\"\"></p>\n<p>选项中几个的区别如下图</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fo7vxck29zj30k00cv0sp.jpg\" alt=\"\"></p>\n<p>最后那个是需要证书支持的。然后滚动到下面打开always use HTTPS开关</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fo7vy66223j30rn06dwet.jpg\" alt=\"\"></p>\n<h6 id=\"第五步：\"><a href=\"#第五步：\" class=\"headerlink\" title=\"第五步：\"></a>第五步：</h6><p>以上步骤配置好之后基本就完成了，但是如果直接有人在地址栏里面输入<a href=\"http://XXXXX\" target=\"_blank\" rel=\"noopener\">http://XXXXX</a> 进入你的博客的话你这边还是会出现非Https的效果，所以我们这里要做一个强制跳转。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fo7w1ksr94j30uu0ir76a.jpg\" alt=\"\"></p>\n<p>这样就万无一失了。</p>\n<h6 id=\"坑点：\"><a href=\"#坑点：\" class=\"headerlink\" title=\"坑点：\"></a>坑点：</h6><p>我之前按照以上步骤操作完成后发现首页虽然是https了也不显示红叉了，但是也没有显示绿色的小锁，而是一个叹号，但是有些博文页面可以正常显示https绿锁。后来发现是因为当前页面中有非https的链接导致，比如图片图床不是https的，或者评论插件不支持https，不过我博客中使用的来必力评论是支持https，只是我当时的图床无都是http所以只能是显示叹号了，后来把所有图片图床换成https的就好啦。</p>\n<h2 id=\"十二：为博客添加音乐\"><a href=\"#十二：为博客添加音乐\" class=\"headerlink\" title=\"十二：为博客添加音乐\"></a>十二：为博客添加音乐</h2><p>HEXO博客添加的音乐的地方有两个。一个个首页侧边栏，另一个是每个页面里面。但是个人觉得添加侧边栏里面并不好，因为添加侧边栏的话用户只有在浏览你首页的时候才能听到音乐，而且期间不能点击任何站内链接，否则音乐就会中断，试想下，一般首页都是文章列表，点击文章里面之后才是正文，所以用户在首页停留的时间很短，基本上找到自己想看的文章就会马上点进去看，所以这里放音乐没有太大意义；而页面内插入音乐会更好点，读者可以一边浏览文章一边听音乐，这也正是我们想要的。不过解决前者问题的办法也不是没有，比如点击链接的话直接开另一个浏览器标签来打开新页面也可以做到不中断音乐，但是总觉得有点小题大做了。总不能读者看个你的博客而占用了一堆标签。</p>\n<h4 id=\"网易云音乐外链\"><a href=\"#网易云音乐外链\" class=\"headerlink\" title=\"网易云音乐外链\"></a>网易云音乐外链</h4><p>这个是最简单的方法，通过网易云音乐官网生成播放器外链。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fordugrc80j315s0swthy.jpg\" alt=\"\"></p>\n<p>可以自己配置一些属性，然后自动生成配置代码，放到你的博客里面就行啦，粘贴到你文章中想要的地方</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1forduyu7laj31hm0zkaft.jpg\" alt=\"\"></p>\n<p>优点缺点截图上也有，不过网上也说这样的方式会影响SEO，具体什么原理也不太清楚。总之简单便捷，不过网易的logo去不掉。</p>\n<h4 id=\"aplayer添加音乐\"><a href=\"#aplayer添加音乐\" class=\"headerlink\" title=\"aplayer添加音乐\"></a><a href=\"https://aplayer.js.org/docs/#/?id=options\" target=\"_blank\" rel=\"noopener\">aplayer</a>添加音乐</h4><p>这个算是HEXO最常用也是最出名名的播放器了，还有Dpleyer是用来视屏播放的，暂时我们不说。首先需要安装aplayer依赖，终端中切换到你的博客根目录执行 <code>npm install aplayer --save</code> 安装成功后就可以了。参数就不给大家一一讲解了，官方文档都有，我这里只提供一个例子。</p>\n<h6 id=\"页面中添加音乐\"><a href=\"#页面中添加音乐\" class=\"headerlink\" title=\"页面中添加音乐\"></a>页面中添加音乐</h6><figure class=\"highlight perl\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% aplayerlist %&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"autoplay\"</span>: true,</span><br><span class=\"line\">    <span class=\"string\">\"showlrc\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">\"mutex\"</span>: true,</span><br><span class=\"line\">    <span class=\"string\">\"music\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"title\"</span>: <span class=\"string\">\"에필로그 (Epilogue)\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"author\"</span>: <span class=\"string\">\"이동준\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"pic\"</span>: <span class=\"string\">\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"lrc\"</span>: <span class=\"string\">\"https://歌词.lrc\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码插到文章中任意一个你想的地方就可以</p>\n<p>pic就是歌曲显示图片的链接。大家可以看到music是个数组，所以想添加列表的话就在数组中再添加个歌曲字典就好了。建议歌词lrc要用URL形式，不然txt格式可能要编辑死。。好多人问歌曲的MP3外链从哪里来。这个其实很简单，首先把歌曲下载下来然后上传到七牛云就可以在七牛云生成外链啦，七牛云有免费的存储空间，只存歌曲的话足够啦。歌词URL</p>\n<h6 id=\"侧边栏中添加音乐\"><a href=\"#侧边栏中添加音乐\" class=\"headerlink\" title=\"侧边栏中添加音乐\"></a>侧边栏中添加音乐</h6><p>其实之前讲过，不建议在侧边栏中添加，但是这里还是简单介绍下。首先要做的是在<code>node_modules</code> 目录下找到 <code>APlayer.min.js</code> 文件，将其复制到 <code>theme/next/source/js/src/</code> 目录下。然后打开 <code>theme/next/layout/_custom/</code> 文件夹下的 <code>sidebar.swig</code> 文件，向其中添加以下代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"aplayer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/js/src/APlayer.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\"><span class=\"keyword\">var</span> ap = <span class=\"keyword\">new</span> APlayer(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    element: <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'player1'</span>),                       <span class=\"comment\">// Optional, player element</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    narrow: <span class=\"literal\">false</span>,                                                     <span class=\"comment\">// Optional, narrow style</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    autoplay: <span class=\"literal\">false</span>,                                                    <span class=\"comment\">// Optional, autoplay song(s), not supported by mobile browsers</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    showlrc: <span class=\"number\">0</span>,                                                        <span class=\"comment\">// Optional, show lrc, can be 0, 1, 2, see: ###With lrc</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    mutex: <span class=\"literal\">true</span>,                                                       <span class=\"comment\">// Optional, pause other players when this player playing</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    theme: <span class=\"string\">'#e6d0b2'</span>,                                                  <span class=\"comment\">// Optional, theme color, default: #b7daff</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    mode: <span class=\"string\">'random'</span>,                                                    <span class=\"comment\">// Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    preload: <span class=\"string\">'metadata'</span>,                                               <span class=\"comment\">// Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">    listmaxheight: <span class=\"string\">'513px'</span>,                                             <span class=\"comment\">// Optional, max height of play list</span></span></span><br><span class=\"line\"><span class=\"undefined\">    music: [</span></span><br><span class=\"line\"><span class=\"actionscript\">    &#123;                                                           <span class=\"comment\">// Required, music info, see: ###With playlist</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        title: <span class=\"string\">'Sometimes When We Touch'</span>,                                          <span class=\"comment\">// Required, music title</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        author: <span class=\"string\">'Oliveia'</span>,                                              <span class=\"comment\">// Required, music author</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        url: <span class=\"string\">'https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/SometimesWhenWeTouch.mp3'</span>,  <span class=\"comment\">// Required, music url</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        pic: <span class=\"string\">'https://y.gtimg.cn/music/photo_new/T002R300x300M000003LIDEL0NQInJ.jpg?max_age=2592000'</span>,  <span class=\"comment\">// Optional, music picture</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        lrc: <span class=\"string\">'https://歌词.lrc'</span>                   <span class=\"comment\">// Optional, lrc, see: ###With lrc</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">    &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"title\"</span>: <span class=\"string\">\"大鱼\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"author\"</span>: <span class=\"string\">\"周深\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"pic\"</span>: <span class=\"string\">\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\"</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"string\">\"lrc\"</span>: <span class=\"string\">\"https://歌词.lrc\"</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    ]</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>只是换成了JS的语法，其实原理，参数都一样。然后执行三步走就可以看到啦，注意有浏览器缓存，所以多刷新几次就会有了。</p>\n<h6 id=\"歌词、音乐外链相关\"><a href=\"#歌词、音乐外链相关\" class=\"headerlink\" title=\"歌词、音乐外链相关\"></a>歌词、音乐外链相关</h6><p>歌曲说过大家可以用七牛的免费存储功能，但是会发现一个问题七牛的歌曲外链不支持https，这会导致配置有ssl证书的人掉绿锁，其实如果有这个需求的大家可以放弃七牛，改用腾讯云，这样就OK啦，一样的操作。</p>\n<p>好多人问歌词的URL好难找啊，去哪里找呢，大家可以看下这个 <a href=\"https://github.com/metowolf/MetingJS\" target=\"_blank\" rel=\"noopener\">MeetingJS</a>这个其实是基于Aplayer的一个小封装，目的是简化Aplayer的接入成本，但是因为之前我介绍了接入步骤所以这里我们只用它的歌词API就可以。<code>ttps://demo.meting.api.meto.moe/action/metingapi?server=tencent&amp;type=lrc&amp;id=004OQ5Mt0EmEzv</code> 其中要改的只有两个参数seaver是音乐平台包含百度、网易、QQ音乐等平台</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1forkjr7da0j31be0ns43n.jpg\" alt=\"\"></p>\n<p>id字段对应的是歌曲的ID 这个你只要打开个歌曲网页链接里面应该都包含id。文章结尾的播放就是这么加入的</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>整篇文章只有开始一小部分在讲解如何搭建博客，后续的基本都是交给大家如何优化，调整一些细节问题如UI、用户体验之类的，当然我们能做的远远不止这些，如果有什么问题欢迎与我探讨。下面的留言我都会看的。此外当本人对HEXO有新的看法或者玩法的话该文章会不断的更新，希望大家关注我的<a href=\"https://oliverqueen.cn/\">小站</a>，感谢。</p>\n\n\t\t\t<div id=\"aplayer1\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"凉城\",\"author\":\"任然\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/liangcheng.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000008nl2Y1HlxUm.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002SKEeh1VzObP\"},{\"title\":\"Love Story\",\"author\":\"린 (LYn)\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"},{\"title\":\"大鱼\",\"author\":\"周深\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer1\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>"},{"title":"简单的iOS线上热修复方案","date":"2018-03-14T06:04:46.000Z","comments":1,"_content":"## 向大佬致敬\n总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍Demo和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fpcbkfx1z9j319e0kkdmp.jpg)\n\n以下是** [原文链接](http://limboy.me/tech/2018/03/04/ios-lightweight-hotfix.html)**有兴趣的还可以看下**[大佬博客](http://limboy.me/)**\n<!-- more -->\n\n## 工作原理分析\n要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS的运行时机制可以满足我们的这个要求，但是如果是已经上架了的APP,已经打成了Ipa包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们App内的RunTime机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的JS代码，因为我们知道在iOS中JS代码是可以调用OC的代码。综上所述打到热修复整套流程所需的技术如下：\n* Runtime：\n\n  可以在本站搜索Runtime关键字找到Runtime相关资料\n\n* 与服务器交互：\n\n  现在大部分APP都具有于服务端交互的能力，就是我们常说的网络请求AFNetWorking等\n\n* JS与OC交互：\n\n  大家可以参考[这篇文章](https://www.jianshu.com/p/d19689e0ed83)，主要参考方式二，使用JavaScriptCore进行交互\n\n进行了上述操作后每次用户启动，App都会进行如下操作\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fpcce8vzimj30vg0t0wva.jpg)\n\n这样一来如果开发在项目发布出去后发现有Crash那么可以立即通过服务器下发JS代码来制定APp每次执行新方法(新方法的定义也是在下发的JS代码中)，可以避免一些问题。\n\n## 实际使用\n\n#### 第三方\n\n这里用到一个第三方库[Aspects](https://github.com/steipete/Aspects)这个库可以理解为一个iOS中的Runtime库，我们不用写繁琐的代码，直接调用他的接口即可，\n\n```\n+ (id<AspectToken>)aspect_hookSelector:(SEL)selector\n                           withOptions:(AspectOptions)options\n                            usingBlock:(id)block\n                                 error:(NSError **)error;\n```\n\n其中的枚举就是选择我们要插入方法的位置，其中包含\n\n```\ntypedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// Called after the original implementation (default)\n    AspectPositionInstead = 1,            /// Will replace the original implementation.\n    AspectPositionBefore  = 2,            /// Called before the original implementation.\n\n    AspectOptionAutomaticRemoval = 1 << 3 /// Will remove the hook after the first execution.\n};\n\n```\n这个库据说是对上线没有影响。\n\n#### 配置工程\n\n用实际代码来证明下，这是我Controller中的一个代码，很明显会产生数组越界的Crash，假如我们在上线后才发现了这个问题，这时候需要修复\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self crashMethod:0];\n\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\n\n\n- (void)crashMethod:(NSInteger)argument\n{\n    if (argument == 0) {\n        NSArray * arr = @[@\"1\"];\n        [arr objectAtIndex:2];\n    }\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n\n@end\n\n```\n导入上面说的那个第三方.h和.m 然后自己建立一个桥接类，用来处理JS和O的交互，大概的结构就是这样\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fpcdbh9ahbj307k0duwfd.jpg)\n\n其中交互类中暴露出如下接口\n\n```\n#import <Foundation/Foundation.h>\n#import \"Aspects.h\"\n#import <objc/runtime.h>\n#import <JavaScriptCore/JavaScriptCore.h>\n@interface Felix : NSObject\n\n/**\n 初始化\n */\n+ (void)fixIt;\n\n\n/**\n 开始执行JS代码\n\n @param javascriptString 需要执行的JS\n */\n+ (void)evalString:(NSString *)javascriptString;\n@end\n\n```\n\n.m文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。\n\n#### 开始使用\n因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在APpdelegate中如下注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n\n\n    [Felix fixIt];\n    NSString *fixScriptString = @\" \\\n    fixInstanceMethodReplace('ViewController', 'crashMethod:', function(instance, originInvocation, originArguments){ \\\n    if (originArguments[0] == 0) { \\\n    console.log('crash！！！！！'); \\\n    } else { \\\n    runInvocation(originInvocation); \\\n    } \\\n    }); \\\n    \\\n    \";\n    [Felix evalString:fixScriptString];\n\n//    如果是多个方法建议用循环执行\n//    NSArray * hotFixStr = @[fixScriptString];\n//    for (int i = 0; i < hotFixStr.count; i ++) {\n//        [Felix evalString:hotFixStr[i]];\n//    }\n\n    return YES;\n}\n\n```\n其中JS的代码就是我们所要修改的内容，可以看到当参数为0的时候输出crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回JS字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个crash！！！！\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fpcdjfkqkmj30i4034t8s.jpg)\n\n## 思考\n\n这个方法相比较之前的JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"不知归期的故人\",\n            \"author\": \"房东的猫\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/2018-03-14-Simple-HotFix-Mtehod.md","raw":"---\ntitle: 简单的iOS线上热修复方案\ncategories: iOS开发\ndate: 2018-03-14 14:04:46\ntags:\n      - 热修复\n      - JSPath\ncomments:\n---\n## 向大佬致敬\n总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍Demo和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fpcbkfx1z9j319e0kkdmp.jpg)\n\n以下是** [原文链接](http://limboy.me/tech/2018/03/04/ios-lightweight-hotfix.html)**有兴趣的还可以看下**[大佬博客](http://limboy.me/)**\n<!-- more -->\n\n## 工作原理分析\n要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS的运行时机制可以满足我们的这个要求，但是如果是已经上架了的APP,已经打成了Ipa包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们App内的RunTime机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的JS代码，因为我们知道在iOS中JS代码是可以调用OC的代码。综上所述打到热修复整套流程所需的技术如下：\n* Runtime：\n\n  可以在本站搜索Runtime关键字找到Runtime相关资料\n\n* 与服务器交互：\n\n  现在大部分APP都具有于服务端交互的能力，就是我们常说的网络请求AFNetWorking等\n\n* JS与OC交互：\n\n  大家可以参考[这篇文章](https://www.jianshu.com/p/d19689e0ed83)，主要参考方式二，使用JavaScriptCore进行交互\n\n进行了上述操作后每次用户启动，App都会进行如下操作\n\n![](https://ws3.sinaimg.cn/large/006tNc79gy1fpcce8vzimj30vg0t0wva.jpg)\n\n这样一来如果开发在项目发布出去后发现有Crash那么可以立即通过服务器下发JS代码来制定APp每次执行新方法(新方法的定义也是在下发的JS代码中)，可以避免一些问题。\n\n## 实际使用\n\n#### 第三方\n\n这里用到一个第三方库[Aspects](https://github.com/steipete/Aspects)这个库可以理解为一个iOS中的Runtime库，我们不用写繁琐的代码，直接调用他的接口即可，\n\n```\n+ (id<AspectToken>)aspect_hookSelector:(SEL)selector\n                           withOptions:(AspectOptions)options\n                            usingBlock:(id)block\n                                 error:(NSError **)error;\n```\n\n其中的枚举就是选择我们要插入方法的位置，其中包含\n\n```\ntypedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// Called after the original implementation (default)\n    AspectPositionInstead = 1,            /// Will replace the original implementation.\n    AspectPositionBefore  = 2,            /// Called before the original implementation.\n\n    AspectOptionAutomaticRemoval = 1 << 3 /// Will remove the hook after the first execution.\n};\n\n```\n这个库据说是对上线没有影响。\n\n#### 配置工程\n\n用实际代码来证明下，这是我Controller中的一个代码，很明显会产生数组越界的Crash，假如我们在上线后才发现了这个问题，这时候需要修复\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self crashMethod:0];\n\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\n\n\n- (void)crashMethod:(NSInteger)argument\n{\n    if (argument == 0) {\n        NSArray * arr = @[@\"1\"];\n        [arr objectAtIndex:2];\n    }\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n\n@end\n\n```\n导入上面说的那个第三方.h和.m 然后自己建立一个桥接类，用来处理JS和O的交互，大概的结构就是这样\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fpcdbh9ahbj307k0duwfd.jpg)\n\n其中交互类中暴露出如下接口\n\n```\n#import <Foundation/Foundation.h>\n#import \"Aspects.h\"\n#import <objc/runtime.h>\n#import <JavaScriptCore/JavaScriptCore.h>\n@interface Felix : NSObject\n\n/**\n 初始化\n */\n+ (void)fixIt;\n\n\n/**\n 开始执行JS代码\n\n @param javascriptString 需要执行的JS\n */\n+ (void)evalString:(NSString *)javascriptString;\n@end\n\n```\n\n.m文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。\n\n#### 开始使用\n因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在APpdelegate中如下注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n\n\n    [Felix fixIt];\n    NSString *fixScriptString = @\" \\\n    fixInstanceMethodReplace('ViewController', 'crashMethod:', function(instance, originInvocation, originArguments){ \\\n    if (originArguments[0] == 0) { \\\n    console.log('crash！！！！！'); \\\n    } else { \\\n    runInvocation(originInvocation); \\\n    } \\\n    }); \\\n    \\\n    \";\n    [Felix evalString:fixScriptString];\n\n//    如果是多个方法建议用循环执行\n//    NSArray * hotFixStr = @[fixScriptString];\n//    for (int i = 0; i < hotFixStr.count; i ++) {\n//        [Felix evalString:hotFixStr[i]];\n//    }\n\n    return YES;\n}\n\n```\n其中JS的代码就是我们所要修改的内容，可以看到当参数为0的时候输出crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回JS字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个crash！！！！\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fpcdjfkqkmj30i4034t8s.jpg)\n\n## 思考\n\n这个方法相比较之前的JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"不知归期的故人\",\n            \"author\": \"房东的猫\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"Simple-HotFix-Mtehod","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2li001ha04whxpb19si","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"向大佬致敬\"><a href=\"#向大佬致敬\" class=\"headerlink\" title=\"向大佬致敬\"></a>向大佬致敬</h2><p>总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍Demo和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fpcbkfx1z9j319e0kkdmp.jpg\" alt=\"\"></p>\n<p>以下是<strong> <a href=\"http://limboy.me/tech/2018/03/04/ios-lightweight-hotfix.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></strong>有兴趣的还可以看下<strong><a href=\"http://limboy.me/\" target=\"_blank\" rel=\"noopener\">大佬博客</a></strong><br><a id=\"more\"></a></p>\n<h2 id=\"工作原理分析\"><a href=\"#工作原理分析\" class=\"headerlink\" title=\"工作原理分析\"></a>工作原理分析</h2><p>要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS的运行时机制可以满足我们的这个要求，但是如果是已经上架了的APP,已经打成了Ipa包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们App内的RunTime机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的JS代码，因为我们知道在iOS中JS代码是可以调用OC的代码。综上所述打到热修复整套流程所需的技术如下：</p>\n<ul>\n<li><p>Runtime：</p>\n<p>可以在本站搜索Runtime关键字找到Runtime相关资料</p>\n</li>\n<li><p>与服务器交互：</p>\n<p>现在大部分APP都具有于服务端交互的能力，就是我们常说的网络请求AFNetWorking等</p>\n</li>\n<li><p>JS与OC交互：</p>\n<p>大家可以参考<a href=\"https://www.jianshu.com/p/d19689e0ed83\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，主要参考方式二，使用JavaScriptCore进行交互</p>\n</li>\n</ul>\n<p>进行了上述操作后每次用户启动，App都会进行如下操作</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fpcce8vzimj30vg0t0wva.jpg\" alt=\"\"></p>\n<p>这样一来如果开发在项目发布出去后发现有Crash那么可以立即通过服务器下发JS代码来制定APp每次执行新方法(新方法的定义也是在下发的JS代码中)，可以避免一些问题。</p>\n<h2 id=\"实际使用\"><a href=\"#实际使用\" class=\"headerlink\" title=\"实际使用\"></a>实际使用</h2><h4 id=\"第三方\"><a href=\"#第三方\" class=\"headerlink\" title=\"第三方\"></a>第三方</h4><p>这里用到一个第三方库<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>这个库可以理解为一个iOS中的Runtime库，我们不用写繁琐的代码，直接调用他的接口即可，</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class=\"line\">                           withOptions:(AspectOptions)options</span><br><span class=\"line\">                            usingBlock:(<span class=\"built_in\">id</span>)block</span><br><span class=\"line\">                                 <span class=\"keyword\">error</span>:(NSError **)<span class=\"keyword\">error</span>;</span><br></pre></td></tr></table></figure>\n<p>其中的枚举就是选择我们要插入方法的位置，其中包含</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class=\"line\">    AspectPositionAfter   = <span class=\"number\">0</span>,            <span class=\"comment\">/// Called after the original implementation (default)</span></span><br><span class=\"line\">    AspectPositionInstead = <span class=\"number\">1</span>,            <span class=\"comment\">/// Will replace the original implementation.</span></span><br><span class=\"line\">    AspectPositionBefore  = <span class=\"number\">2</span>,            <span class=\"comment\">/// Called before the original implementation.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AspectOptionAutomaticRemoval = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span> <span class=\"comment\">/// Will remove the hook after the first execution.</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个库据说是对上线没有影响。</p>\n<h4 id=\"配置工程\"><a href=\"#配置工程\" class=\"headerlink\" title=\"配置工程\"></a>配置工程</h4><p>用实际代码来证明下，这是我Controller中的一个代码，很明显会产生数组越界的Crash，假如我们在上线后才发现了这个问题，这时候需要修复</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> crashMethod:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)crashMethod:(<span class=\"built_in\">NSInteger</span>)argument</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argument == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> * arr = @[<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">        [arr objectAtIndex:<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didReceiveMemoryWarning &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> didReceiveMemoryWarning];</span><br><span class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>导入上面说的那个第三方.h和.m 然后自己建立一个桥接类，用来处理JS和O的交互，大概的结构就是这样</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fpcdbh9ahbj307k0duwfd.jpg\" alt=\"\"></p>\n<p>其中交互类中暴露出如下接口</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Aspects.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Felix</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 初始化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)fixIt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 开始执行JS代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param javascriptString 需要执行的JS</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)evalString:(<span class=\"built_in\">NSString</span> *)javascriptString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。</p>\n<h4 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h4><p>因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在APpdelegate中如下注册</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [Felix fixIt];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *fixScriptString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">    fixInstanceMethodReplace('ViewController', 'crashMethod:', function(instance, originInvocation, originArguments)&#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    if (originArguments[0] == 0) &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    console.log('crash！！！！！'); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; else &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    runInvocation(originInvocation); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125;); \\</span></span><br><span class=\"line\"><span class=\"string\">    \\</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>;</span><br><span class=\"line\">    [Felix evalString:fixScriptString];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    如果是多个方法建议用循环执行</span></span><br><span class=\"line\"><span class=\"comment\">//    NSArray * hotFixStr = @[fixScriptString];</span></span><br><span class=\"line\"><span class=\"comment\">//    for (int i = 0; i &lt; hotFixStr.count; i ++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        [Felix evalString:hotFixStr[i]];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中JS的代码就是我们所要修改的内容，可以看到当参数为0的时候输出crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回JS字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个crash！！！！</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fpcdjfkqkmj30i4034t8s.jpg\" alt=\"\"></p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>这个方法相比较之前的JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。</p>\n\n\t\t\t<div id=\"aplayer2\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"不知归期的故人\",\"author\":\"房东的猫\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer2\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n","site":{"data":{}},"excerpt":"<h2 id=\"向大佬致敬\"><a href=\"#向大佬致敬\" class=\"headerlink\" title=\"向大佬致敬\"></a>向大佬致敬</h2><p>总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍Demo和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fpcbkfx1z9j319e0kkdmp.jpg\" alt=\"\"></p>\n<p>以下是<strong> <a href=\"http://limboy.me/tech/2018/03/04/ios-lightweight-hotfix.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></strong>有兴趣的还可以看下<strong><a href=\"http://limboy.me/\" target=\"_blank\" rel=\"noopener\">大佬博客</a></strong><br>","more":"</p>\n<h2 id=\"工作原理分析\"><a href=\"#工作原理分析\" class=\"headerlink\" title=\"工作原理分析\"></a>工作原理分析</h2><p>要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS的运行时机制可以满足我们的这个要求，但是如果是已经上架了的APP,已经打成了Ipa包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们App内的RunTime机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的JS代码，因为我们知道在iOS中JS代码是可以调用OC的代码。综上所述打到热修复整套流程所需的技术如下：</p>\n<ul>\n<li><p>Runtime：</p>\n<p>可以在本站搜索Runtime关键字找到Runtime相关资料</p>\n</li>\n<li><p>与服务器交互：</p>\n<p>现在大部分APP都具有于服务端交互的能力，就是我们常说的网络请求AFNetWorking等</p>\n</li>\n<li><p>JS与OC交互：</p>\n<p>大家可以参考<a href=\"https://www.jianshu.com/p/d19689e0ed83\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，主要参考方式二，使用JavaScriptCore进行交互</p>\n</li>\n</ul>\n<p>进行了上述操作后每次用户启动，App都会进行如下操作</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fpcce8vzimj30vg0t0wva.jpg\" alt=\"\"></p>\n<p>这样一来如果开发在项目发布出去后发现有Crash那么可以立即通过服务器下发JS代码来制定APp每次执行新方法(新方法的定义也是在下发的JS代码中)，可以避免一些问题。</p>\n<h2 id=\"实际使用\"><a href=\"#实际使用\" class=\"headerlink\" title=\"实际使用\"></a>实际使用</h2><h4 id=\"第三方\"><a href=\"#第三方\" class=\"headerlink\" title=\"第三方\"></a>第三方</h4><p>这里用到一个第三方库<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>这个库可以理解为一个iOS中的Runtime库，我们不用写繁琐的代码，直接调用他的接口即可，</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class=\"line\">                           withOptions:(AspectOptions)options</span><br><span class=\"line\">                            usingBlock:(<span class=\"built_in\">id</span>)block</span><br><span class=\"line\">                                 <span class=\"keyword\">error</span>:(NSError **)<span class=\"keyword\">error</span>;</span><br></pre></td></tr></table></figure>\n<p>其中的枚举就是选择我们要插入方法的位置，其中包含</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class=\"line\">    AspectPositionAfter   = <span class=\"number\">0</span>,            <span class=\"comment\">/// Called after the original implementation (default)</span></span><br><span class=\"line\">    AspectPositionInstead = <span class=\"number\">1</span>,            <span class=\"comment\">/// Will replace the original implementation.</span></span><br><span class=\"line\">    AspectPositionBefore  = <span class=\"number\">2</span>,            <span class=\"comment\">/// Called before the original implementation.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AspectOptionAutomaticRemoval = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span> <span class=\"comment\">/// Will remove the hook after the first execution.</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个库据说是对上线没有影响。</p>\n<h4 id=\"配置工程\"><a href=\"#配置工程\" class=\"headerlink\" title=\"配置工程\"></a>配置工程</h4><p>用实际代码来证明下，这是我Controller中的一个代码，很明显会产生数组越界的Crash，假如我们在上线后才发现了这个问题，这时候需要修复</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> crashMethod:<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)crashMethod:(<span class=\"built_in\">NSInteger</span>)argument</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argument == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> * arr = @[<span class=\"string\">@\"1\"</span>];</span><br><span class=\"line\">        [arr objectAtIndex:<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didReceiveMemoryWarning &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> didReceiveMemoryWarning];</span><br><span class=\"line\">    <span class=\"comment\">// Dispose of any resources that can be recreated.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>导入上面说的那个第三方.h和.m 然后自己建立一个桥接类，用来处理JS和O的交互，大概的结构就是这样</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fpcdbh9ahbj307k0duwfd.jpg\" alt=\"\"></p>\n<p>其中交互类中暴露出如下接口</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Aspects.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Felix</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 初始化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)fixIt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 开始执行JS代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param javascriptString 需要执行的JS</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)evalString:(<span class=\"built_in\">NSString</span> *)javascriptString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>.m文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。</p>\n<h4 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h4><p>因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在APpdelegate中如下注册</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [Felix fixIt];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *fixScriptString = <span class=\"string\">@\" \\</span></span><br><span class=\"line\"><span class=\"string\">    fixInstanceMethodReplace('ViewController', 'crashMethod:', function(instance, originInvocation, originArguments)&#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    if (originArguments[0] == 0) &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    console.log('crash！！！！！'); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; else &#123; \\</span></span><br><span class=\"line\"><span class=\"string\">    runInvocation(originInvocation); \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125; \\</span></span><br><span class=\"line\"><span class=\"string\">    &#125;); \\</span></span><br><span class=\"line\"><span class=\"string\">    \\</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>;</span><br><span class=\"line\">    [Felix evalString:fixScriptString];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    如果是多个方法建议用循环执行</span></span><br><span class=\"line\"><span class=\"comment\">//    NSArray * hotFixStr = @[fixScriptString];</span></span><br><span class=\"line\"><span class=\"comment\">//    for (int i = 0; i &lt; hotFixStr.count; i ++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        [Felix evalString:hotFixStr[i]];</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中JS的代码就是我们所要修改的内容，可以看到当参数为0的时候输出crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回JS字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个crash！！！！</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fpcdjfkqkmj30i4034t8s.jpg\" alt=\"\"></p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>这个方法相比较之前的JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。</p>\n\n\t\t\t<div id=\"aplayer2\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"不知归期的故人\",\"author\":\"房东的猫\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer2\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>"},{"title":"At The End Of 2017","date":"2018-02-12T07:47:45.000Z","comments":1,"_content":"\n## 前言\n\n今天是2017年的最后一个工作日，准确的说是我最后一个工作日，公司的同事都走的差不多了，寥寥无几的办公室显得格外冷清，和安静，不过越是这样的环境越容易让我回忆、感慨，因此便有了这篇文章。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fodqkq8305j31hc0u07fp.jpg)\n\n<!--more-->\n\n我的一些朋友在元旦的时候就做了总结，而我选择在了这个时候，因为我觉得虽然是12月31日，但是我的工作并没有停止，旧的工作没有做完，新的工作还没时间规划，元旦也只是个小长假而已。虽然现在对于明年要做的事情也还是没有详细的定位，但是大致的方向应该算是有了。\n\n## 辞旧\n\n只有辞旧才能迎新，说实话2017年收货真的不小，今年也是我在美图成长最快的一年。2016年6月12日凌晨从北京匆匆赶来深圳，一天的时间紧紧张张，办了户口，办了社保转移之类的手续，下午又来到公司楼下踩点儿，防止第二天入职的时候找不到地方。13号正式成为Meitu的一员，刚开始都是陌生的，也可以说是懵逼的，接触的东西多了就会发现自己欠缺的东西也多了，什么都想要学，从入职到17年其实都是在适应期，没有什么实质性的进步，不过真的是涨了见识，知道了很多东西。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodr6rjwo5j31kw0c5kjl.jpg)\n\n记得来深圳之前一个前辈跟我说过：“当你去到一个新的城市一个新的公司大多数人都需要半年左右的适应期，适应期内会觉得和公司格格不入，各种不爽，等这一阶段过去了那就会突飞猛进。”一开始我还不相信，但是现在真的知道了。半年的适应期过去了，2017年逐渐步入正轨，这也是我在一开始说2017年是我个人成长最快的一年，不光是技术，还包括其他精神层面的一些东西。\n\n#### 学习相关\n\n###### SDK\n\n毕竟是做开发的，还是先从技术说起，这一年完成了iOS端的DNS解析耗时优化SDK，也可以叫做HttpDns。其实这个东西原理很简单(这里就不在赘述，毕竟不是技术文章，想了解更多的可以在我的小站搜索 httpdns 字段)。但是做了很久，刚开始做的时候，我想应该是业内的前几名吧，我只看到过腾讯，阿里有过相关的文档，而阿里的也只是实现了简单的几个功能而已，腾讯的不开源，不过应该也不会有多深入。除此之外没有任何有用的文档，自己一点点摸索，一点点踩坑，项目接了好久都是有问题，也不稳定，那段时间真的很难，很痛苦。好在最后慢慢都克服了，当我把最终的文档放到网上，确实赢来了很多的阅读量，还被推上过头条，我想这就是对我付出努力的回报吧，着实很欣慰。唯一的遗憾就是由于涉及到一些业务的代码，无法做到开源。不过这将是我2018年的目标。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodsdsa6zkj30eq08ct8x.jpg)\n\n###### App\n\n其实完整的App没有做，但是也主要维护了一个App，刚接到代码看了下最早的代码是2012年，一些第三方库也比较老。老旧的代码，无法发挥新设备的性能，于是开始重构、优化，几年前写代码的人大部分离职了，只能自己看，看不懂了就用自己的方式重写。每次App上架后盯着崩溃的后台看，是否产生了新的问题、旧的问题是否修复，然后看App Store用户的评论，用户最关心什么，用户会产生哪些问题，都一一记录，修改，其实每当这个时候感觉还是挺幸福的，而且正好赶上iPhone X发布，新的屏幕适配早就做好了，就等着真机出来去看看，应该也是公司第一个完成适配的App，虽然当时有些小问题还没有发现。后来看着产品越来越稳定心里也是很爽的。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodshg1fk6j31kw13hhdt.jpg)\n\n###### 其他\n\n翻译过几篇文章、尽量保证每周在公司做一次技术分享(感谢我的leader让我养成这个习惯)、建立了个人博客开始记录自己的生活、在一些技术论坛上有了属于自己的粉丝，不过我不是大佬，只是和大家沟通、讨论罢了。\n\n#### 生活相关\n\n###### 情感\n\n2017年首先是换了一个工作的城市，其实是为了逃离北京的雾霾，也是为自己更好的发展，不得不承认南方的环境确实要比北方强一些，政府机关的办事效率也更高一些。三月份妹子为了我也来到了深圳,真的很感动，横跨了整个中国来找我，她虽然没什么怨言，但是我知道对于一个女孩子来说这意味着什么，有时候她开玩笑总是说我没有感情，其实我只是不善表达而已，作为一个军人家庭出身的孩子，我完美的受到了家庭的影响，说一不二，对她从来不惯，从来不哄，不能容忍她矫情，不能容忍她挑食，有时候严厉的真的像我的父亲对我一样，但是同样我也会对她绝对的忠诚，因为还是很爱她，不管以后如何，她已经是我生命中除了母亲之外最重要的人。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fodsmhxyi2j31kw1c4qeh.jpg)\n\n###### 旅游\n\n可能是因为沿海城市很方便的原因，这一年我们去了不少城市，走过不少地方，\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fodt98c9ojj31kw0iab29.jpg)\n\n其实还有很多地方，只是大部分照片没有传到google相册里，google的相册我的初衷是用来保存livephoto的。那天看到妹子用一个本子记着我们一起去过的地方，我才发现我们走过不少地方。我当时想我可以做一个小App把这些地方记录下来，但是遭到拒绝，她说出去旅游就是为了放下工作，去寻找大自然中最原始，最纯净的东西，她不想因为这个增加我的工作量，而且用最原始的纸和笔更符合旅行的意义。\n\n**香港**\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fodtibvhsbj31kw16rx6r.jpg)\n\n**澳门**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtjh9f65j31kw0z9npe.jpg)\n\n\n**上海**\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fodtkpsycej31kw0kl4qr.jpg)\n\n**西塘**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtlu9fq7j31kw15v4qu.jpg)\n\n**Kota Kinabalu**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtmeey2yj31kw0tm4qu.jpg)\n\n**Semporna**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtqde670j31kw15qhdy.jpg)\n\n还有很多地方拍了很多照片，现在看下真的是很美好的回忆，后来我和妹子一直认为，以后即使再忙也一定要多出去走。这也是为什么我过年没有使用年假，因为年假基本会攒到出国。以后我的博客可能会开出相册模块，记录下更多的美好。\n\n###### 其他\n\n2017年也有经常健身吧，因为南方空气潮湿湿气重，如果不让自己保持大汉淋漓的话很容易生病。坚持过几个月，但是后来因为工作忙，加班等借口还是没坚持下来，没有父亲的监督果然靠自己不行。说好的八块腹肌已经要九九归一了。不过也真的明白身在异乡什么时候最孤独，最无助，那就是生病的时候。\n\n我的2017 差不多就这些东西，可能跟大佬们比起来真的是小打小闹，但是过得充实，心里踏实只有自己懂。\n\n## 迎新\n\n2018年在短短的休息之后就会到来，虽说没有做好万全的准备，但是至少不会手足无措。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1foducrbfzwj31hc0xc1jn.jpg)\n\n#### 学习相关\n\n* 还是学习为主，首先要做的就是把自己的apple的开发者账号续费，自己可以做一些练习、App之类的东西，同时把各种证书、打包，持续集成这块整明白。毕竟现在用公司的证书不敢乱弄。\n\n* 自己从零到一做一个直播的App不管是绿色直播还是成人直播，一定要做出来保证完美运行。\n\n* 雅思词汇全掌握。\n\n* 壮大自己的博客。\n\n#### 生活相关\n\n* 去一到两个国家。\n\n* 五公里坚持下来。\n\n* 成都，重庆，云南....\n\n#### 其他\n\n之所以没在迎新中写太多东西并不是因为没计划，而是有些东西不想在这里说出来，用老罗的话说就是万一实现不了，丢人。\n\n我记得看过一本书说“伟大的人不是努力学习新知识的人，而是善于总结的人。”我也不求变成伟大的人，只是希望自己的每一年都有所收货，希望自己做好迎接新一年的打算，希望过得踏实点。\n\n## 最后\n\n**在这里给大家拜个早年：祝大家新年快乐，心想事成。新的一年我会与大家分享更多的东西**\n\n才疏学浅，文笔拙劣，于2018.2.13仓促执笔....\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"에필로그 (Epilogue)\",\n            \"author\": \"이동준\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\n            \"lrc\": \"https://歌词.lrc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/2018-02-12-At-The-End-Of-2017.md","raw":"---\ntitle: At The End Of 2017\ncategories: 闲谈\ndate: 2018-02-12 15:47:45\ntags:\n - 总结\n - 回味2017展望2018\ncomments:\n---\n\n## 前言\n\n今天是2017年的最后一个工作日，准确的说是我最后一个工作日，公司的同事都走的差不多了，寥寥无几的办公室显得格外冷清，和安静，不过越是这样的环境越容易让我回忆、感慨，因此便有了这篇文章。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fodqkq8305j31hc0u07fp.jpg)\n\n<!--more-->\n\n我的一些朋友在元旦的时候就做了总结，而我选择在了这个时候，因为我觉得虽然是12月31日，但是我的工作并没有停止，旧的工作没有做完，新的工作还没时间规划，元旦也只是个小长假而已。虽然现在对于明年要做的事情也还是没有详细的定位，但是大致的方向应该算是有了。\n\n## 辞旧\n\n只有辞旧才能迎新，说实话2017年收货真的不小，今年也是我在美图成长最快的一年。2016年6月12日凌晨从北京匆匆赶来深圳，一天的时间紧紧张张，办了户口，办了社保转移之类的手续，下午又来到公司楼下踩点儿，防止第二天入职的时候找不到地方。13号正式成为Meitu的一员，刚开始都是陌生的，也可以说是懵逼的，接触的东西多了就会发现自己欠缺的东西也多了，什么都想要学，从入职到17年其实都是在适应期，没有什么实质性的进步，不过真的是涨了见识，知道了很多东西。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodr6rjwo5j31kw0c5kjl.jpg)\n\n记得来深圳之前一个前辈跟我说过：“当你去到一个新的城市一个新的公司大多数人都需要半年左右的适应期，适应期内会觉得和公司格格不入，各种不爽，等这一阶段过去了那就会突飞猛进。”一开始我还不相信，但是现在真的知道了。半年的适应期过去了，2017年逐渐步入正轨，这也是我在一开始说2017年是我个人成长最快的一年，不光是技术，还包括其他精神层面的一些东西。\n\n#### 学习相关\n\n###### SDK\n\n毕竟是做开发的，还是先从技术说起，这一年完成了iOS端的DNS解析耗时优化SDK，也可以叫做HttpDns。其实这个东西原理很简单(这里就不在赘述，毕竟不是技术文章，想了解更多的可以在我的小站搜索 httpdns 字段)。但是做了很久，刚开始做的时候，我想应该是业内的前几名吧，我只看到过腾讯，阿里有过相关的文档，而阿里的也只是实现了简单的几个功能而已，腾讯的不开源，不过应该也不会有多深入。除此之外没有任何有用的文档，自己一点点摸索，一点点踩坑，项目接了好久都是有问题，也不稳定，那段时间真的很难，很痛苦。好在最后慢慢都克服了，当我把最终的文档放到网上，确实赢来了很多的阅读量，还被推上过头条，我想这就是对我付出努力的回报吧，着实很欣慰。唯一的遗憾就是由于涉及到一些业务的代码，无法做到开源。不过这将是我2018年的目标。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodsdsa6zkj30eq08ct8x.jpg)\n\n###### App\n\n其实完整的App没有做，但是也主要维护了一个App，刚接到代码看了下最早的代码是2012年，一些第三方库也比较老。老旧的代码，无法发挥新设备的性能，于是开始重构、优化，几年前写代码的人大部分离职了，只能自己看，看不懂了就用自己的方式重写。每次App上架后盯着崩溃的后台看，是否产生了新的问题、旧的问题是否修复，然后看App Store用户的评论，用户最关心什么，用户会产生哪些问题，都一一记录，修改，其实每当这个时候感觉还是挺幸福的，而且正好赶上iPhone X发布，新的屏幕适配早就做好了，就等着真机出来去看看，应该也是公司第一个完成适配的App，虽然当时有些小问题还没有发现。后来看着产品越来越稳定心里也是很爽的。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodshg1fk6j31kw13hhdt.jpg)\n\n###### 其他\n\n翻译过几篇文章、尽量保证每周在公司做一次技术分享(感谢我的leader让我养成这个习惯)、建立了个人博客开始记录自己的生活、在一些技术论坛上有了属于自己的粉丝，不过我不是大佬，只是和大家沟通、讨论罢了。\n\n#### 生活相关\n\n###### 情感\n\n2017年首先是换了一个工作的城市，其实是为了逃离北京的雾霾，也是为自己更好的发展，不得不承认南方的环境确实要比北方强一些，政府机关的办事效率也更高一些。三月份妹子为了我也来到了深圳,真的很感动，横跨了整个中国来找我，她虽然没什么怨言，但是我知道对于一个女孩子来说这意味着什么，有时候她开玩笑总是说我没有感情，其实我只是不善表达而已，作为一个军人家庭出身的孩子，我完美的受到了家庭的影响，说一不二，对她从来不惯，从来不哄，不能容忍她矫情，不能容忍她挑食，有时候严厉的真的像我的父亲对我一样，但是同样我也会对她绝对的忠诚，因为还是很爱她，不管以后如何，她已经是我生命中除了母亲之外最重要的人。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fodsmhxyi2j31kw1c4qeh.jpg)\n\n###### 旅游\n\n可能是因为沿海城市很方便的原因，这一年我们去了不少城市，走过不少地方，\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fodt98c9ojj31kw0iab29.jpg)\n\n其实还有很多地方，只是大部分照片没有传到google相册里，google的相册我的初衷是用来保存livephoto的。那天看到妹子用一个本子记着我们一起去过的地方，我才发现我们走过不少地方。我当时想我可以做一个小App把这些地方记录下来，但是遭到拒绝，她说出去旅游就是为了放下工作，去寻找大自然中最原始，最纯净的东西，她不想因为这个增加我的工作量，而且用最原始的纸和笔更符合旅行的意义。\n\n**香港**\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fodtibvhsbj31kw16rx6r.jpg)\n\n**澳门**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtjh9f65j31kw0z9npe.jpg)\n\n\n**上海**\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fodtkpsycej31kw0kl4qr.jpg)\n\n**西塘**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtlu9fq7j31kw15v4qu.jpg)\n\n**Kota Kinabalu**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtmeey2yj31kw0tm4qu.jpg)\n\n**Semporna**\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fodtqde670j31kw15qhdy.jpg)\n\n还有很多地方拍了很多照片，现在看下真的是很美好的回忆，后来我和妹子一直认为，以后即使再忙也一定要多出去走。这也是为什么我过年没有使用年假，因为年假基本会攒到出国。以后我的博客可能会开出相册模块，记录下更多的美好。\n\n###### 其他\n\n2017年也有经常健身吧，因为南方空气潮湿湿气重，如果不让自己保持大汉淋漓的话很容易生病。坚持过几个月，但是后来因为工作忙，加班等借口还是没坚持下来，没有父亲的监督果然靠自己不行。说好的八块腹肌已经要九九归一了。不过也真的明白身在异乡什么时候最孤独，最无助，那就是生病的时候。\n\n我的2017 差不多就这些东西，可能跟大佬们比起来真的是小打小闹，但是过得充实，心里踏实只有自己懂。\n\n## 迎新\n\n2018年在短短的休息之后就会到来，虽说没有做好万全的准备，但是至少不会手足无措。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1foducrbfzwj31hc0xc1jn.jpg)\n\n#### 学习相关\n\n* 还是学习为主，首先要做的就是把自己的apple的开发者账号续费，自己可以做一些练习、App之类的东西，同时把各种证书、打包，持续集成这块整明白。毕竟现在用公司的证书不敢乱弄。\n\n* 自己从零到一做一个直播的App不管是绿色直播还是成人直播，一定要做出来保证完美运行。\n\n* 雅思词汇全掌握。\n\n* 壮大自己的博客。\n\n#### 生活相关\n\n* 去一到两个国家。\n\n* 五公里坚持下来。\n\n* 成都，重庆，云南....\n\n#### 其他\n\n之所以没在迎新中写太多东西并不是因为没计划，而是有些东西不想在这里说出来，用老罗的话说就是万一实现不了，丢人。\n\n我记得看过一本书说“伟大的人不是努力学习新知识的人，而是善于总结的人。”我也不求变成伟大的人，只是希望自己的每一年都有所收货，希望自己做好迎接新一年的打算，希望过得踏实点。\n\n## 最后\n\n**在这里给大家拜个早年：祝大家新年快乐，心想事成。新的一年我会与大家分享更多的东西**\n\n才疏学浅，文笔拙劣，于2018.2.13仓促执笔....\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"에필로그 (Epilogue)\",\n            \"author\": \"이동준\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\n            \"lrc\": \"https://歌词.lrc\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"At-The-End-Of-2017","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lk001ka04wwn0xjocs","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天是2017年的最后一个工作日，准确的说是我最后一个工作日，公司的同事都走的差不多了，寥寥无几的办公室显得格外冷清，和安静，不过越是这样的环境越容易让我回忆、感慨，因此便有了这篇文章。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fodqkq8305j31hc0u07fp.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>我的一些朋友在元旦的时候就做了总结，而我选择在了这个时候，因为我觉得虽然是12月31日，但是我的工作并没有停止，旧的工作没有做完，新的工作还没时间规划，元旦也只是个小长假而已。虽然现在对于明年要做的事情也还是没有详细的定位，但是大致的方向应该算是有了。</p>\n<h2 id=\"辞旧\"><a href=\"#辞旧\" class=\"headerlink\" title=\"辞旧\"></a>辞旧</h2><p>只有辞旧才能迎新，说实话2017年收货真的不小，今年也是我在美图成长最快的一年。2016年6月12日凌晨从北京匆匆赶来深圳，一天的时间紧紧张张，办了户口，办了社保转移之类的手续，下午又来到公司楼下踩点儿，防止第二天入职的时候找不到地方。13号正式成为Meitu的一员，刚开始都是陌生的，也可以说是懵逼的，接触的东西多了就会发现自己欠缺的东西也多了，什么都想要学，从入职到17年其实都是在适应期，没有什么实质性的进步，不过真的是涨了见识，知道了很多东西。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodr6rjwo5j31kw0c5kjl.jpg\" alt=\"\"></p>\n<p>记得来深圳之前一个前辈跟我说过：“当你去到一个新的城市一个新的公司大多数人都需要半年左右的适应期，适应期内会觉得和公司格格不入，各种不爽，等这一阶段过去了那就会突飞猛进。”一开始我还不相信，但是现在真的知道了。半年的适应期过去了，2017年逐渐步入正轨，这也是我在一开始说2017年是我个人成长最快的一年，不光是技术，还包括其他精神层面的一些东西。</p>\n<h4 id=\"学习相关\"><a href=\"#学习相关\" class=\"headerlink\" title=\"学习相关\"></a>学习相关</h4><h6 id=\"SDK\"><a href=\"#SDK\" class=\"headerlink\" title=\"SDK\"></a>SDK</h6><p>毕竟是做开发的，还是先从技术说起，这一年完成了iOS端的DNS解析耗时优化SDK，也可以叫做HttpDns。其实这个东西原理很简单(这里就不在赘述，毕竟不是技术文章，想了解更多的可以在我的小站搜索 httpdns 字段)。但是做了很久，刚开始做的时候，我想应该是业内的前几名吧，我只看到过腾讯，阿里有过相关的文档，而阿里的也只是实现了简单的几个功能而已，腾讯的不开源，不过应该也不会有多深入。除此之外没有任何有用的文档，自己一点点摸索，一点点踩坑，项目接了好久都是有问题，也不稳定，那段时间真的很难，很痛苦。好在最后慢慢都克服了，当我把最终的文档放到网上，确实赢来了很多的阅读量，还被推上过头条，我想这就是对我付出努力的回报吧，着实很欣慰。唯一的遗憾就是由于涉及到一些业务的代码，无法做到开源。不过这将是我2018年的目标。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodsdsa6zkj30eq08ct8x.jpg\" alt=\"\"></p>\n<h6 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h6><p>其实完整的App没有做，但是也主要维护了一个App，刚接到代码看了下最早的代码是2012年，一些第三方库也比较老。老旧的代码，无法发挥新设备的性能，于是开始重构、优化，几年前写代码的人大部分离职了，只能自己看，看不懂了就用自己的方式重写。每次App上架后盯着崩溃的后台看，是否产生了新的问题、旧的问题是否修复，然后看App Store用户的评论，用户最关心什么，用户会产生哪些问题，都一一记录，修改，其实每当这个时候感觉还是挺幸福的，而且正好赶上iPhone X发布，新的屏幕适配早就做好了，就等着真机出来去看看，应该也是公司第一个完成适配的App，虽然当时有些小问题还没有发现。后来看着产品越来越稳定心里也是很爽的。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodshg1fk6j31kw13hhdt.jpg\" alt=\"\"></p>\n<h6 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h6><p>翻译过几篇文章、尽量保证每周在公司做一次技术分享(感谢我的leader让我养成这个习惯)、建立了个人博客开始记录自己的生活、在一些技术论坛上有了属于自己的粉丝，不过我不是大佬，只是和大家沟通、讨论罢了。</p>\n<h4 id=\"生活相关\"><a href=\"#生活相关\" class=\"headerlink\" title=\"生活相关\"></a>生活相关</h4><h6 id=\"情感\"><a href=\"#情感\" class=\"headerlink\" title=\"情感\"></a>情感</h6><p>2017年首先是换了一个工作的城市，其实是为了逃离北京的雾霾，也是为自己更好的发展，不得不承认南方的环境确实要比北方强一些，政府机关的办事效率也更高一些。三月份妹子为了我也来到了深圳,真的很感动，横跨了整个中国来找我，她虽然没什么怨言，但是我知道对于一个女孩子来说这意味着什么，有时候她开玩笑总是说我没有感情，其实我只是不善表达而已，作为一个军人家庭出身的孩子，我完美的受到了家庭的影响，说一不二，对她从来不惯，从来不哄，不能容忍她矫情，不能容忍她挑食，有时候严厉的真的像我的父亲对我一样，但是同样我也会对她绝对的忠诚，因为还是很爱她，不管以后如何，她已经是我生命中除了母亲之外最重要的人。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fodsmhxyi2j31kw1c4qeh.jpg\" alt=\"\"></p>\n<h6 id=\"旅游\"><a href=\"#旅游\" class=\"headerlink\" title=\"旅游\"></a>旅游</h6><p>可能是因为沿海城市很方便的原因，这一年我们去了不少城市，走过不少地方，</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fodt98c9ojj31kw0iab29.jpg\" alt=\"\"></p>\n<p>其实还有很多地方，只是大部分照片没有传到google相册里，google的相册我的初衷是用来保存livephoto的。那天看到妹子用一个本子记着我们一起去过的地方，我才发现我们走过不少地方。我当时想我可以做一个小App把这些地方记录下来，但是遭到拒绝，她说出去旅游就是为了放下工作，去寻找大自然中最原始，最纯净的东西，她不想因为这个增加我的工作量，而且用最原始的纸和笔更符合旅行的意义。</p>\n<p><strong>香港</strong></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fodtibvhsbj31kw16rx6r.jpg\" alt=\"\"></p>\n<p><strong>澳门</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtjh9f65j31kw0z9npe.jpg\" alt=\"\"></p>\n<p><strong>上海</strong></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fodtkpsycej31kw0kl4qr.jpg\" alt=\"\"></p>\n<p><strong>西塘</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtlu9fq7j31kw15v4qu.jpg\" alt=\"\"></p>\n<p><strong>Kota Kinabalu</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtmeey2yj31kw0tm4qu.jpg\" alt=\"\"></p>\n<p><strong>Semporna</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtqde670j31kw15qhdy.jpg\" alt=\"\"></p>\n<p>还有很多地方拍了很多照片，现在看下真的是很美好的回忆，后来我和妹子一直认为，以后即使再忙也一定要多出去走。这也是为什么我过年没有使用年假，因为年假基本会攒到出国。以后我的博客可能会开出相册模块，记录下更多的美好。</p>\n<h6 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h6><p>2017年也有经常健身吧，因为南方空气潮湿湿气重，如果不让自己保持大汉淋漓的话很容易生病。坚持过几个月，但是后来因为工作忙，加班等借口还是没坚持下来，没有父亲的监督果然靠自己不行。说好的八块腹肌已经要九九归一了。不过也真的明白身在异乡什么时候最孤独，最无助，那就是生病的时候。</p>\n<p>我的2017 差不多就这些东西，可能跟大佬们比起来真的是小打小闹，但是过得充实，心里踏实只有自己懂。</p>\n<h2 id=\"迎新\"><a href=\"#迎新\" class=\"headerlink\" title=\"迎新\"></a>迎新</h2><p>2018年在短短的休息之后就会到来，虽说没有做好万全的准备，但是至少不会手足无措。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1foducrbfzwj31hc0xc1jn.jpg\" alt=\"\"></p>\n<h4 id=\"学习相关-1\"><a href=\"#学习相关-1\" class=\"headerlink\" title=\"学习相关\"></a>学习相关</h4><ul>\n<li><p>还是学习为主，首先要做的就是把自己的apple的开发者账号续费，自己可以做一些练习、App之类的东西，同时把各种证书、打包，持续集成这块整明白。毕竟现在用公司的证书不敢乱弄。</p>\n</li>\n<li><p>自己从零到一做一个直播的App不管是绿色直播还是成人直播，一定要做出来保证完美运行。</p>\n</li>\n<li><p>雅思词汇全掌握。</p>\n</li>\n<li><p>壮大自己的博客。</p>\n</li>\n</ul>\n<h4 id=\"生活相关-1\"><a href=\"#生活相关-1\" class=\"headerlink\" title=\"生活相关\"></a>生活相关</h4><ul>\n<li><p>去一到两个国家。</p>\n</li>\n<li><p>五公里坚持下来。</p>\n</li>\n<li><p>成都，重庆，云南….</p>\n</li>\n</ul>\n<h4 id=\"其他-2\"><a href=\"#其他-2\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>之所以没在迎新中写太多东西并不是因为没计划，而是有些东西不想在这里说出来，用老罗的话说就是万一实现不了，丢人。</p>\n<p>我记得看过一本书说“伟大的人不是努力学习新知识的人，而是善于总结的人。”我也不求变成伟大的人，只是希望自己的每一年都有所收货，希望自己做好迎接新一年的打算，希望过得踏实点。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p><strong>在这里给大家拜个早年：祝大家新年快乐，心想事成。新的一年我会与大家分享更多的东西</strong></p>\n<p>才疏学浅，文笔拙劣，于2018.2.13仓促执笔….</p>\n\n\t\t\t<div id=\"aplayer3\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"에필로그 (Epilogue)\",\"author\":\"이동준\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer3\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天是2017年的最后一个工作日，准确的说是我最后一个工作日，公司的同事都走的差不多了，寥寥无几的办公室显得格外冷清，和安静，不过越是这样的环境越容易让我回忆、感慨，因此便有了这篇文章。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fodqkq8305j31hc0u07fp.jpg\" alt=\"\"></p>","more":"<p>我的一些朋友在元旦的时候就做了总结，而我选择在了这个时候，因为我觉得虽然是12月31日，但是我的工作并没有停止，旧的工作没有做完，新的工作还没时间规划，元旦也只是个小长假而已。虽然现在对于明年要做的事情也还是没有详细的定位，但是大致的方向应该算是有了。</p>\n<h2 id=\"辞旧\"><a href=\"#辞旧\" class=\"headerlink\" title=\"辞旧\"></a>辞旧</h2><p>只有辞旧才能迎新，说实话2017年收货真的不小，今年也是我在美图成长最快的一年。2016年6月12日凌晨从北京匆匆赶来深圳，一天的时间紧紧张张，办了户口，办了社保转移之类的手续，下午又来到公司楼下踩点儿，防止第二天入职的时候找不到地方。13号正式成为Meitu的一员，刚开始都是陌生的，也可以说是懵逼的，接触的东西多了就会发现自己欠缺的东西也多了，什么都想要学，从入职到17年其实都是在适应期，没有什么实质性的进步，不过真的是涨了见识，知道了很多东西。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodr6rjwo5j31kw0c5kjl.jpg\" alt=\"\"></p>\n<p>记得来深圳之前一个前辈跟我说过：“当你去到一个新的城市一个新的公司大多数人都需要半年左右的适应期，适应期内会觉得和公司格格不入，各种不爽，等这一阶段过去了那就会突飞猛进。”一开始我还不相信，但是现在真的知道了。半年的适应期过去了，2017年逐渐步入正轨，这也是我在一开始说2017年是我个人成长最快的一年，不光是技术，还包括其他精神层面的一些东西。</p>\n<h4 id=\"学习相关\"><a href=\"#学习相关\" class=\"headerlink\" title=\"学习相关\"></a>学习相关</h4><h6 id=\"SDK\"><a href=\"#SDK\" class=\"headerlink\" title=\"SDK\"></a>SDK</h6><p>毕竟是做开发的，还是先从技术说起，这一年完成了iOS端的DNS解析耗时优化SDK，也可以叫做HttpDns。其实这个东西原理很简单(这里就不在赘述，毕竟不是技术文章，想了解更多的可以在我的小站搜索 httpdns 字段)。但是做了很久，刚开始做的时候，我想应该是业内的前几名吧，我只看到过腾讯，阿里有过相关的文档，而阿里的也只是实现了简单的几个功能而已，腾讯的不开源，不过应该也不会有多深入。除此之外没有任何有用的文档，自己一点点摸索，一点点踩坑，项目接了好久都是有问题，也不稳定，那段时间真的很难，很痛苦。好在最后慢慢都克服了，当我把最终的文档放到网上，确实赢来了很多的阅读量，还被推上过头条，我想这就是对我付出努力的回报吧，着实很欣慰。唯一的遗憾就是由于涉及到一些业务的代码，无法做到开源。不过这将是我2018年的目标。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodsdsa6zkj30eq08ct8x.jpg\" alt=\"\"></p>\n<h6 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h6><p>其实完整的App没有做，但是也主要维护了一个App，刚接到代码看了下最早的代码是2012年，一些第三方库也比较老。老旧的代码，无法发挥新设备的性能，于是开始重构、优化，几年前写代码的人大部分离职了，只能自己看，看不懂了就用自己的方式重写。每次App上架后盯着崩溃的后台看，是否产生了新的问题、旧的问题是否修复，然后看App Store用户的评论，用户最关心什么，用户会产生哪些问题，都一一记录，修改，其实每当这个时候感觉还是挺幸福的，而且正好赶上iPhone X发布，新的屏幕适配早就做好了，就等着真机出来去看看，应该也是公司第一个完成适配的App，虽然当时有些小问题还没有发现。后来看着产品越来越稳定心里也是很爽的。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodshg1fk6j31kw13hhdt.jpg\" alt=\"\"></p>\n<h6 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h6><p>翻译过几篇文章、尽量保证每周在公司做一次技术分享(感谢我的leader让我养成这个习惯)、建立了个人博客开始记录自己的生活、在一些技术论坛上有了属于自己的粉丝，不过我不是大佬，只是和大家沟通、讨论罢了。</p>\n<h4 id=\"生活相关\"><a href=\"#生活相关\" class=\"headerlink\" title=\"生活相关\"></a>生活相关</h4><h6 id=\"情感\"><a href=\"#情感\" class=\"headerlink\" title=\"情感\"></a>情感</h6><p>2017年首先是换了一个工作的城市，其实是为了逃离北京的雾霾，也是为自己更好的发展，不得不承认南方的环境确实要比北方强一些，政府机关的办事效率也更高一些。三月份妹子为了我也来到了深圳,真的很感动，横跨了整个中国来找我，她虽然没什么怨言，但是我知道对于一个女孩子来说这意味着什么，有时候她开玩笑总是说我没有感情，其实我只是不善表达而已，作为一个军人家庭出身的孩子，我完美的受到了家庭的影响，说一不二，对她从来不惯，从来不哄，不能容忍她矫情，不能容忍她挑食，有时候严厉的真的像我的父亲对我一样，但是同样我也会对她绝对的忠诚，因为还是很爱她，不管以后如何，她已经是我生命中除了母亲之外最重要的人。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fodsmhxyi2j31kw1c4qeh.jpg\" alt=\"\"></p>\n<h6 id=\"旅游\"><a href=\"#旅游\" class=\"headerlink\" title=\"旅游\"></a>旅游</h6><p>可能是因为沿海城市很方便的原因，这一年我们去了不少城市，走过不少地方，</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fodt98c9ojj31kw0iab29.jpg\" alt=\"\"></p>\n<p>其实还有很多地方，只是大部分照片没有传到google相册里，google的相册我的初衷是用来保存livephoto的。那天看到妹子用一个本子记着我们一起去过的地方，我才发现我们走过不少地方。我当时想我可以做一个小App把这些地方记录下来，但是遭到拒绝，她说出去旅游就是为了放下工作，去寻找大自然中最原始，最纯净的东西，她不想因为这个增加我的工作量，而且用最原始的纸和笔更符合旅行的意义。</p>\n<p><strong>香港</strong></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fodtibvhsbj31kw16rx6r.jpg\" alt=\"\"></p>\n<p><strong>澳门</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtjh9f65j31kw0z9npe.jpg\" alt=\"\"></p>\n<p><strong>上海</strong></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fodtkpsycej31kw0kl4qr.jpg\" alt=\"\"></p>\n<p><strong>西塘</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtlu9fq7j31kw15v4qu.jpg\" alt=\"\"></p>\n<p><strong>Kota Kinabalu</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtmeey2yj31kw0tm4qu.jpg\" alt=\"\"></p>\n<p><strong>Semporna</strong></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fodtqde670j31kw15qhdy.jpg\" alt=\"\"></p>\n<p>还有很多地方拍了很多照片，现在看下真的是很美好的回忆，后来我和妹子一直认为，以后即使再忙也一定要多出去走。这也是为什么我过年没有使用年假，因为年假基本会攒到出国。以后我的博客可能会开出相册模块，记录下更多的美好。</p>\n<h6 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h6><p>2017年也有经常健身吧，因为南方空气潮湿湿气重，如果不让自己保持大汉淋漓的话很容易生病。坚持过几个月，但是后来因为工作忙，加班等借口还是没坚持下来，没有父亲的监督果然靠自己不行。说好的八块腹肌已经要九九归一了。不过也真的明白身在异乡什么时候最孤独，最无助，那就是生病的时候。</p>\n<p>我的2017 差不多就这些东西，可能跟大佬们比起来真的是小打小闹，但是过得充实，心里踏实只有自己懂。</p>\n<h2 id=\"迎新\"><a href=\"#迎新\" class=\"headerlink\" title=\"迎新\"></a>迎新</h2><p>2018年在短短的休息之后就会到来，虽说没有做好万全的准备，但是至少不会手足无措。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1foducrbfzwj31hc0xc1jn.jpg\" alt=\"\"></p>\n<h4 id=\"学习相关-1\"><a href=\"#学习相关-1\" class=\"headerlink\" title=\"学习相关\"></a>学习相关</h4><ul>\n<li><p>还是学习为主，首先要做的就是把自己的apple的开发者账号续费，自己可以做一些练习、App之类的东西，同时把各种证书、打包，持续集成这块整明白。毕竟现在用公司的证书不敢乱弄。</p>\n</li>\n<li><p>自己从零到一做一个直播的App不管是绿色直播还是成人直播，一定要做出来保证完美运行。</p>\n</li>\n<li><p>雅思词汇全掌握。</p>\n</li>\n<li><p>壮大自己的博客。</p>\n</li>\n</ul>\n<h4 id=\"生活相关-1\"><a href=\"#生活相关-1\" class=\"headerlink\" title=\"生活相关\"></a>生活相关</h4><ul>\n<li><p>去一到两个国家。</p>\n</li>\n<li><p>五公里坚持下来。</p>\n</li>\n<li><p>成都，重庆，云南….</p>\n</li>\n</ul>\n<h4 id=\"其他-2\"><a href=\"#其他-2\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>之所以没在迎新中写太多东西并不是因为没计划，而是有些东西不想在这里说出来，用老罗的话说就是万一实现不了，丢人。</p>\n<p>我记得看过一本书说“伟大的人不是努力学习新知识的人，而是善于总结的人。”我也不求变成伟大的人，只是希望自己的每一年都有所收货，希望自己做好迎接新一年的打算，希望过得踏实点。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p><strong>在这里给大家拜个早年：祝大家新年快乐，心想事成。新的一年我会与大家分享更多的东西</strong></p>\n<p>才疏学浅，文笔拙劣，于2018.2.13仓促执笔….</p>\n\n\t\t\t<div id=\"aplayer3\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"에필로그 (Epilogue)\",\"author\":\"이동준\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000\",\"lrc\":\"https://歌词.lrc\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer3\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>"},{"title":"关于博客评论插件的讨论","date":"2018-02-11T07:19:31.000Z","comments":1,"_content":"## 参考资料\n\n习惯把参考资料写在文章的前面，毕竟是踩在人家的肩膀上，先有他才有我这文章，前后顺序不能乱。他的这篇[文章](https://blog.shuiba.co/comment-systems-recommendation)总结的很全，但是对于每一个评论还欠缺细致的描述，这篇文章下我会做些补充，\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1focjch8o98j30sg0lcta8.jpg)\n\n<!--more-->\n\n## 之前用的livere\n\n关于博客的评论插件,在最开始的搭建博客之前就有过考虑和纠结，国内的评论界面浮夸流程繁琐，且服务不稳定，说倒就倒，比如多说；国外的又时刻面临着被墙的风险，自己搭建服务器虽说不难，但是也没有精力去搞这些。后来使用了livere，韩国的产品，一开始被他简洁的界面方便的后台吸引，而且还支持各种移动APP登陆，微信、QQ之类的。不过后来使用过程中缺点显现出来了。\n\n#### 缺点\n1：手机端适配不好，手机端无法进行微信登陆。<br>\n2：评论无法导出，不过如果哪天他也要挂了说不定也会支持导出，毕竟实现不难。<br>\n3：经常发评论时候当前页面卡死，其实已经发送成功了，但是界面一直卡在loading。<br>\n4：加载比较慢一些。<br>\n\n## 其他的评论插件\n综上所述我决定换掉它，这种东西要趁早，不然等评论多了还需要朱转移操作。下面说下其他评论插件，因为之前放了大佬的文章，他总结的也很全面，我这边就挑几个大家耳熟能详的来说，而且只说缺点。\n\n#### disqus\n\n他唯一一个缺点就是被墙了，他要求每一个看你博客的读者都要科学上网才可以，对于我的博客来说，不仅仅是写一下技术文档，有时候会更新下照片、游记之类的，所以不想对读者有太高的要求。\n\n#### 搜狐畅言\n\n搜狐旗下的评论系统，比较靠谱，有搜狐做后盾也不会轻易说没就没，但是对于我来说他有着太强烈的中国元素，域名、网站需要备案，而且他的界面是在是夸张，又是盖章，又是浮窗的，有种\"大扎好，我系渣渣辉\"的感觉。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1foche9mncgj31hw0veb29.jpg)\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1focku989hmj312s06044g.jpg)\n\n过年了，放上了红灯了，红鞭炮，而且水印还去不掉。最最关键是你发评论要登录，如果是用微信登陆还必须要先关注他公众号.\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fochbah9doj30ho0ngwo2.jpg)\n\n关注成功后还需要你绑定手机号，虽然不是强制让你绑定，但是如果你不想绑那么好，你每点击一下就会弹出绑定手机号的窗口。对于我一个主打技术的博客来说确实不太适合，如果大家想写一写娱乐微博说不定适合你。\n\n#### Gitment\n\n基于github的issue实现的，唯一一点不好的就是使用Gitment评论一定要用github账号登陆，这点对于读者来说要求有点高吧。\n\n#### Valine\n\n比较优秀的一款轻量级评论插件，这个也是我最后纠结很久的，Valine依赖于Leancloud的后端服务，我们需要去leanclould注册一个账号，里面分为免费版和商业版还有企业版。后两个价格对于我来说有点高，如果有钱的大佬可以无视。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1focgkj2vntj31kw0ry44z.jpg)\n\n免费版有一定限制首先API请求每天30000，你可以暂时理解为每天30000条评论吧(实际不到这个数，你还要刷新之类的)，这个其实对于我来说已经够了，如果你是浏览量非常大的微博 那可能有点悬；10GB的储存空间是我最担心的，永久10G总有一天就会满，到时候只能升级付费版，或者换一个评论平台，不过还好，因为他是支持markdown的，所以图片GIf的之类的都是通过链接形式，10G应该够用一阵了。不过也正是因为这个markdown编辑也需要一定的语法基础，不会markdown的传图片还是麻烦事，多为读者考虑嘛。还有一个最致命的就是他没有管理员的概念，即使你是本文的作者，那你在下面评论或者和网友互动的时候也是没有任何显示的，就像普通评论一样，这个就有点不方便了。\n\n#### Hypercomments\n\n这个也是我最后选择的评论插件，同样也提供付费和免费的服务\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1focm2c591vj31kw152jyr.jpg)\n\n免费版完全满足我的博客使用，没有发现以上一些第三方的缺点，同时界面也不错，唯一不足的就是新评论的邮件提醒不知道怎么调出来，我在后台配置了但是并没有提醒。综上所述整体还是比较稳定的。\n\n## 最后\n大概就这么多，顺便祝大家新年快乐，阖家幸福！\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"Love Story\",\n            \"author\": \"린 (LYn)\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/2018-02-11-关于博客评论插件的问题.md","raw":"---\ntitle: 关于博客评论插件的讨论\ncategories: 通用开发\ndate: 2018-02-11 15:19:31\ntags:\n  - Hexo\n  - 个人博客\n  - 网站\n  - 评论插件\ncomments: true\n---\n## 参考资料\n\n习惯把参考资料写在文章的前面，毕竟是踩在人家的肩膀上，先有他才有我这文章，前后顺序不能乱。他的这篇[文章](https://blog.shuiba.co/comment-systems-recommendation)总结的很全，但是对于每一个评论还欠缺细致的描述，这篇文章下我会做些补充，\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1focjch8o98j30sg0lcta8.jpg)\n\n<!--more-->\n\n## 之前用的livere\n\n关于博客的评论插件,在最开始的搭建博客之前就有过考虑和纠结，国内的评论界面浮夸流程繁琐，且服务不稳定，说倒就倒，比如多说；国外的又时刻面临着被墙的风险，自己搭建服务器虽说不难，但是也没有精力去搞这些。后来使用了livere，韩国的产品，一开始被他简洁的界面方便的后台吸引，而且还支持各种移动APP登陆，微信、QQ之类的。不过后来使用过程中缺点显现出来了。\n\n#### 缺点\n1：手机端适配不好，手机端无法进行微信登陆。<br>\n2：评论无法导出，不过如果哪天他也要挂了说不定也会支持导出，毕竟实现不难。<br>\n3：经常发评论时候当前页面卡死，其实已经发送成功了，但是界面一直卡在loading。<br>\n4：加载比较慢一些。<br>\n\n## 其他的评论插件\n综上所述我决定换掉它，这种东西要趁早，不然等评论多了还需要朱转移操作。下面说下其他评论插件，因为之前放了大佬的文章，他总结的也很全面，我这边就挑几个大家耳熟能详的来说，而且只说缺点。\n\n#### disqus\n\n他唯一一个缺点就是被墙了，他要求每一个看你博客的读者都要科学上网才可以，对于我的博客来说，不仅仅是写一下技术文档，有时候会更新下照片、游记之类的，所以不想对读者有太高的要求。\n\n#### 搜狐畅言\n\n搜狐旗下的评论系统，比较靠谱，有搜狐做后盾也不会轻易说没就没，但是对于我来说他有着太强烈的中国元素，域名、网站需要备案，而且他的界面是在是夸张，又是盖章，又是浮窗的，有种\"大扎好，我系渣渣辉\"的感觉。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1foche9mncgj31hw0veb29.jpg)\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1focku989hmj312s06044g.jpg)\n\n过年了，放上了红灯了，红鞭炮，而且水印还去不掉。最最关键是你发评论要登录，如果是用微信登陆还必须要先关注他公众号.\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fochbah9doj30ho0ngwo2.jpg)\n\n关注成功后还需要你绑定手机号，虽然不是强制让你绑定，但是如果你不想绑那么好，你每点击一下就会弹出绑定手机号的窗口。对于我一个主打技术的博客来说确实不太适合，如果大家想写一写娱乐微博说不定适合你。\n\n#### Gitment\n\n基于github的issue实现的，唯一一点不好的就是使用Gitment评论一定要用github账号登陆，这点对于读者来说要求有点高吧。\n\n#### Valine\n\n比较优秀的一款轻量级评论插件，这个也是我最后纠结很久的，Valine依赖于Leancloud的后端服务，我们需要去leanclould注册一个账号，里面分为免费版和商业版还有企业版。后两个价格对于我来说有点高，如果有钱的大佬可以无视。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1focgkj2vntj31kw0ry44z.jpg)\n\n免费版有一定限制首先API请求每天30000，你可以暂时理解为每天30000条评论吧(实际不到这个数，你还要刷新之类的)，这个其实对于我来说已经够了，如果你是浏览量非常大的微博 那可能有点悬；10GB的储存空间是我最担心的，永久10G总有一天就会满，到时候只能升级付费版，或者换一个评论平台，不过还好，因为他是支持markdown的，所以图片GIf的之类的都是通过链接形式，10G应该够用一阵了。不过也正是因为这个markdown编辑也需要一定的语法基础，不会markdown的传图片还是麻烦事，多为读者考虑嘛。还有一个最致命的就是他没有管理员的概念，即使你是本文的作者，那你在下面评论或者和网友互动的时候也是没有任何显示的，就像普通评论一样，这个就有点不方便了。\n\n#### Hypercomments\n\n这个也是我最后选择的评论插件，同样也提供付费和免费的服务\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1focm2c591vj31kw152jyr.jpg)\n\n免费版完全满足我的博客使用，没有发现以上一些第三方的缺点，同时界面也不错，唯一不足的就是新评论的邮件提醒不知道怎么调出来，我在后台配置了但是并没有提醒。综上所述整体还是比较稳定的。\n\n## 最后\n大概就这么多，顺便祝大家新年快乐，阖家幸福！\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 3,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"Love Story\",\n            \"author\": \"린 (LYn)\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"关于博客评论插件的问题","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lm001oa04wwj9b3dhv","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>习惯把参考资料写在文章的前面，毕竟是踩在人家的肩膀上，先有他才有我这文章，前后顺序不能乱。他的这篇<a href=\"https://blog.shuiba.co/comment-systems-recommendation\" target=\"_blank\" rel=\"noopener\">文章</a>总结的很全，但是对于每一个评论还欠缺细致的描述，这篇文章下我会做些补充，</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1focjch8o98j30sg0lcta8.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"之前用的livere\"><a href=\"#之前用的livere\" class=\"headerlink\" title=\"之前用的livere\"></a>之前用的livere</h2><p>关于博客的评论插件,在最开始的搭建博客之前就有过考虑和纠结，国内的评论界面浮夸流程繁琐，且服务不稳定，说倒就倒，比如多说；国外的又时刻面临着被墙的风险，自己搭建服务器虽说不难，但是也没有精力去搞这些。后来使用了livere，韩国的产品，一开始被他简洁的界面方便的后台吸引，而且还支持各种移动APP登陆，微信、QQ之类的。不过后来使用过程中缺点显现出来了。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>1：手机端适配不好，手机端无法进行微信登陆。<br><br>2：评论无法导出，不过如果哪天他也要挂了说不定也会支持导出，毕竟实现不难。<br><br>3：经常发评论时候当前页面卡死，其实已经发送成功了，但是界面一直卡在loading。<br><br>4：加载比较慢一些。<br></p>\n<h2 id=\"其他的评论插件\"><a href=\"#其他的评论插件\" class=\"headerlink\" title=\"其他的评论插件\"></a>其他的评论插件</h2><p>综上所述我决定换掉它，这种东西要趁早，不然等评论多了还需要朱转移操作。下面说下其他评论插件，因为之前放了大佬的文章，他总结的也很全面，我这边就挑几个大家耳熟能详的来说，而且只说缺点。</p>\n<h4 id=\"disqus\"><a href=\"#disqus\" class=\"headerlink\" title=\"disqus\"></a>disqus</h4><p>他唯一一个缺点就是被墙了，他要求每一个看你博客的读者都要科学上网才可以，对于我的博客来说，不仅仅是写一下技术文档，有时候会更新下照片、游记之类的，所以不想对读者有太高的要求。</p>\n<h4 id=\"搜狐畅言\"><a href=\"#搜狐畅言\" class=\"headerlink\" title=\"搜狐畅言\"></a>搜狐畅言</h4><p>搜狐旗下的评论系统，比较靠谱，有搜狐做后盾也不会轻易说没就没，但是对于我来说他有着太强烈的中国元素，域名、网站需要备案，而且他的界面是在是夸张，又是盖章，又是浮窗的，有种”大扎好，我系渣渣辉”的感觉。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1foche9mncgj31hw0veb29.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1focku989hmj312s06044g.jpg\" alt=\"\"></p>\n<p>过年了，放上了红灯了，红鞭炮，而且水印还去不掉。最最关键是你发评论要登录，如果是用微信登陆还必须要先关注他公众号.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fochbah9doj30ho0ngwo2.jpg\" alt=\"\"></p>\n<p>关注成功后还需要你绑定手机号，虽然不是强制让你绑定，但是如果你不想绑那么好，你每点击一下就会弹出绑定手机号的窗口。对于我一个主打技术的博客来说确实不太适合，如果大家想写一写娱乐微博说不定适合你。</p>\n<h4 id=\"Gitment\"><a href=\"#Gitment\" class=\"headerlink\" title=\"Gitment\"></a>Gitment</h4><p>基于github的issue实现的，唯一一点不好的就是使用Gitment评论一定要用github账号登陆，这点对于读者来说要求有点高吧。</p>\n<h4 id=\"Valine\"><a href=\"#Valine\" class=\"headerlink\" title=\"Valine\"></a>Valine</h4><p>比较优秀的一款轻量级评论插件，这个也是我最后纠结很久的，Valine依赖于Leancloud的后端服务，我们需要去leanclould注册一个账号，里面分为免费版和商业版还有企业版。后两个价格对于我来说有点高，如果有钱的大佬可以无视。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1focgkj2vntj31kw0ry44z.jpg\" alt=\"\"></p>\n<p>免费版有一定限制首先API请求每天30000，你可以暂时理解为每天30000条评论吧(实际不到这个数，你还要刷新之类的)，这个其实对于我来说已经够了，如果你是浏览量非常大的微博 那可能有点悬；10GB的储存空间是我最担心的，永久10G总有一天就会满，到时候只能升级付费版，或者换一个评论平台，不过还好，因为他是支持markdown的，所以图片GIf的之类的都是通过链接形式，10G应该够用一阵了。不过也正是因为这个markdown编辑也需要一定的语法基础，不会markdown的传图片还是麻烦事，多为读者考虑嘛。还有一个最致命的就是他没有管理员的概念，即使你是本文的作者，那你在下面评论或者和网友互动的时候也是没有任何显示的，就像普通评论一样，这个就有点不方便了。</p>\n<h4 id=\"Hypercomments\"><a href=\"#Hypercomments\" class=\"headerlink\" title=\"Hypercomments\"></a>Hypercomments</h4><p>这个也是我最后选择的评论插件，同样也提供付费和免费的服务</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1focm2c591vj31kw152jyr.jpg\" alt=\"\"></p>\n<p>免费版完全满足我的博客使用，没有发现以上一些第三方的缺点，同时界面也不错，唯一不足的就是新评论的邮件提醒不知道怎么调出来，我在后台配置了但是并没有提醒。综上所述整体还是比较稳定的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>大概就这么多，顺便祝大家新年快乐，阖家幸福！</p>\n\n\t\t\t<div id=\"aplayer4\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"Love Story\",\"author\":\"린 (LYn)\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer4\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n","site":{"data":{}},"excerpt":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>习惯把参考资料写在文章的前面，毕竟是踩在人家的肩膀上，先有他才有我这文章，前后顺序不能乱。他的这篇<a href=\"https://blog.shuiba.co/comment-systems-recommendation\" target=\"_blank\" rel=\"noopener\">文章</a>总结的很全，但是对于每一个评论还欠缺细致的描述，这篇文章下我会做些补充，</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1focjch8o98j30sg0lcta8.jpg\" alt=\"\"></p>","more":"<h2 id=\"之前用的livere\"><a href=\"#之前用的livere\" class=\"headerlink\" title=\"之前用的livere\"></a>之前用的livere</h2><p>关于博客的评论插件,在最开始的搭建博客之前就有过考虑和纠结，国内的评论界面浮夸流程繁琐，且服务不稳定，说倒就倒，比如多说；国外的又时刻面临着被墙的风险，自己搭建服务器虽说不难，但是也没有精力去搞这些。后来使用了livere，韩国的产品，一开始被他简洁的界面方便的后台吸引，而且还支持各种移动APP登陆，微信、QQ之类的。不过后来使用过程中缺点显现出来了。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>1：手机端适配不好，手机端无法进行微信登陆。<br><br>2：评论无法导出，不过如果哪天他也要挂了说不定也会支持导出，毕竟实现不难。<br><br>3：经常发评论时候当前页面卡死，其实已经发送成功了，但是界面一直卡在loading。<br><br>4：加载比较慢一些。<br></p>\n<h2 id=\"其他的评论插件\"><a href=\"#其他的评论插件\" class=\"headerlink\" title=\"其他的评论插件\"></a>其他的评论插件</h2><p>综上所述我决定换掉它，这种东西要趁早，不然等评论多了还需要朱转移操作。下面说下其他评论插件，因为之前放了大佬的文章，他总结的也很全面，我这边就挑几个大家耳熟能详的来说，而且只说缺点。</p>\n<h4 id=\"disqus\"><a href=\"#disqus\" class=\"headerlink\" title=\"disqus\"></a>disqus</h4><p>他唯一一个缺点就是被墙了，他要求每一个看你博客的读者都要科学上网才可以，对于我的博客来说，不仅仅是写一下技术文档，有时候会更新下照片、游记之类的，所以不想对读者有太高的要求。</p>\n<h4 id=\"搜狐畅言\"><a href=\"#搜狐畅言\" class=\"headerlink\" title=\"搜狐畅言\"></a>搜狐畅言</h4><p>搜狐旗下的评论系统，比较靠谱，有搜狐做后盾也不会轻易说没就没，但是对于我来说他有着太强烈的中国元素，域名、网站需要备案，而且他的界面是在是夸张，又是盖章，又是浮窗的，有种”大扎好，我系渣渣辉”的感觉。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1foche9mncgj31hw0veb29.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1focku989hmj312s06044g.jpg\" alt=\"\"></p>\n<p>过年了，放上了红灯了，红鞭炮，而且水印还去不掉。最最关键是你发评论要登录，如果是用微信登陆还必须要先关注他公众号.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fochbah9doj30ho0ngwo2.jpg\" alt=\"\"></p>\n<p>关注成功后还需要你绑定手机号，虽然不是强制让你绑定，但是如果你不想绑那么好，你每点击一下就会弹出绑定手机号的窗口。对于我一个主打技术的博客来说确实不太适合，如果大家想写一写娱乐微博说不定适合你。</p>\n<h4 id=\"Gitment\"><a href=\"#Gitment\" class=\"headerlink\" title=\"Gitment\"></a>Gitment</h4><p>基于github的issue实现的，唯一一点不好的就是使用Gitment评论一定要用github账号登陆，这点对于读者来说要求有点高吧。</p>\n<h4 id=\"Valine\"><a href=\"#Valine\" class=\"headerlink\" title=\"Valine\"></a>Valine</h4><p>比较优秀的一款轻量级评论插件，这个也是我最后纠结很久的，Valine依赖于Leancloud的后端服务，我们需要去leanclould注册一个账号，里面分为免费版和商业版还有企业版。后两个价格对于我来说有点高，如果有钱的大佬可以无视。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1focgkj2vntj31kw0ry44z.jpg\" alt=\"\"></p>\n<p>免费版有一定限制首先API请求每天30000，你可以暂时理解为每天30000条评论吧(实际不到这个数，你还要刷新之类的)，这个其实对于我来说已经够了，如果你是浏览量非常大的微博 那可能有点悬；10GB的储存空间是我最担心的，永久10G总有一天就会满，到时候只能升级付费版，或者换一个评论平台，不过还好，因为他是支持markdown的，所以图片GIf的之类的都是通过链接形式，10G应该够用一阵了。不过也正是因为这个markdown编辑也需要一定的语法基础，不会markdown的传图片还是麻烦事，多为读者考虑嘛。还有一个最致命的就是他没有管理员的概念，即使你是本文的作者，那你在下面评论或者和网友互动的时候也是没有任何显示的，就像普通评论一样，这个就有点不方便了。</p>\n<h4 id=\"Hypercomments\"><a href=\"#Hypercomments\" class=\"headerlink\" title=\"Hypercomments\"></a>Hypercomments</h4><p>这个也是我最后选择的评论插件，同样也提供付费和免费的服务</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1focm2c591vj31kw152jyr.jpg\" alt=\"\"></p>\n<p>免费版完全满足我的博客使用，没有发现以上一些第三方的缺点，同时界面也不错，唯一不足的就是新评论的邮件提醒不知道怎么调出来，我在后台配置了但是并没有提醒。综上所述整体还是比较稳定的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>大概就这么多，顺便祝大家新年快乐，阖家幸福！</p>\n\n\t\t\t<div id=\"aplayer4\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mutex\":true,\"music\":[{\"title\":\"Love Story\",\"author\":\"린 (LYn)\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer4\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>"},{"title":"关于RxSwift的一点理解","date":"2018-05-08T02:12:00.000Z","comments":1,"_content":"## Hello RxSwift!\n\n这本书可以让你用Swift来编写响应式编程代码。但是到底什么是RxSwift,这里有很好的定义：\n\n<font color=orange>RxSwift是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。</font> <br>\n\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1525870736284&di=9f373001bac8687d5fe11b3d7b40016f&imgtype=0&src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png)\n\n\n听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。\n\n<!-- more -->\n\n本书的目标就是带你逐步的去理解RxSwift的API，并且去运用每一个API，然后把它们运用到实际的iOSApp中。\n\n你将会从RxSwift中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通RxSwift额思想和使用。其实Rx是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对RX有一个坚实的了解，这样你就能继续提高自己的Rx水平了\n\n其实我们并没有非常确信RxSwift的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。\n\n<font color=orange>RxSwift本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道(队列)里面,以此来达到简化异步并发的过程的目的</font><br>\n\n这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个Action我们用一个管道去装在这些Action，每加一个Action就会把他放管道里面，我们可以理解为管道里面流动的Actions，且管道与管道之间相互独立。同理我们可以吧Button改成一个UITExtField，Action就是每一次输入事件。\n\n作为一个iOS的开发者我相信这已经很好帮你去理解什么是RxSwift了吧，这应该是比你在一开始看到的那些专业术语好理解的多。\n\n如果你还是不清楚，那么你至少应该理解，RxSwift可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。\n\n### 异步编程的介绍\n\n如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个iSO的App，那么你一定想到如下几个东西：\n\n* 接受Button的点击事件\n\n* 当text field的Action和键盘的弹出和收起动画之间的关系\n\n* 从网上下载大图片\n\n* 往硬盘里面存数据\n\n* 播放视频\n\n以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了textfield弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg)\n\n程序里面不同的部分不会阻塞彼此的执行，iOS提供了几种API，通过多核CPU来在不同的线程上进行不同的工作。\n\n其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。\n\n### UIKit中的一些异步的API\n\n苹果在iOS SDK中提供了很多api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。\n\n你一定用过以下几点\n\n* NotificationCenter\n\n* delegate\n\n* Grand Central Dispatch(GCD)\n\n* Closures（Block）\n\n由于大部分的类都是异步的，并且UI在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的APp会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的APp其实代码的执行顺序都是不同的(当然除了一些自动化测试的场景，那些条件都是预先设置好的。)\n\n其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的SDK，而且他们并不统一。如果使用delegate我们需要遵循特制的格式，block，NotificationCenter等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg)\n\n我们来比较两个代码片段来总结下这章。一个是异步一个是同步。\n\n#### 同步代码\n\n对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:\n* 它是同步执行的。\n\n* 在循环遍历时候他是不可变的\n\n花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:\n\n```\nvar array = [1, 2, 3]\nfor number in array {\n  print(number)\n  array = [4, 5, 6]\n}\nprint(array)\n\n```\n最后的输出结果：\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg)\n\n数组在for循环中是不可变的吗？执行顺序是什么？\n\n#### 异步代码\n\n再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：\n```\nvar array = [1, 2, 3]\nvar currentIndex = 0\n\n//this method is connected in IB to a button\n@IBAction func printNext(_ sender: Any) {\n  print(array[currentIndex])\n\n  if currentIndex != array.count-1 {\n    currentIndex += 1\n  }\n}\n```\n试想一下如果放在我们现实的App中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作(增加、删除元素)那么数据就会发生错乱。而且如果currentIndex被另一个线程改变了那么你也不会得到预期的结果。\n\n其实多线程最重要的就是数据争夺的问题，然而RxSwift很好的解决了这个问题\n","source":"_posts/2018-05-08-RX-Swift-Study-One.md","raw":"---\ntitle: 关于RxSwift的一点理解\ncategories: 译文\ndate: 2018-05-08 10:12:00\ntags:\n  - Swift\ncomments:\n---\n## Hello RxSwift!\n\n这本书可以让你用Swift来编写响应式编程代码。但是到底什么是RxSwift,这里有很好的定义：\n\n<font color=orange>RxSwift是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。</font> <br>\n\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1525870736284&di=9f373001bac8687d5fe11b3d7b40016f&imgtype=0&src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png)\n\n\n听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。\n\n<!-- more -->\n\n本书的目标就是带你逐步的去理解RxSwift的API，并且去运用每一个API，然后把它们运用到实际的iOSApp中。\n\n你将会从RxSwift中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通RxSwift额思想和使用。其实Rx是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对RX有一个坚实的了解，这样你就能继续提高自己的Rx水平了\n\n其实我们并没有非常确信RxSwift的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。\n\n<font color=orange>RxSwift本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道(队列)里面,以此来达到简化异步并发的过程的目的</font><br>\n\n这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个Action我们用一个管道去装在这些Action，每加一个Action就会把他放管道里面，我们可以理解为管道里面流动的Actions，且管道与管道之间相互独立。同理我们可以吧Button改成一个UITExtField，Action就是每一次输入事件。\n\n作为一个iOS的开发者我相信这已经很好帮你去理解什么是RxSwift了吧，这应该是比你在一开始看到的那些专业术语好理解的多。\n\n如果你还是不清楚，那么你至少应该理解，RxSwift可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。\n\n### 异步编程的介绍\n\n如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个iSO的App，那么你一定想到如下几个东西：\n\n* 接受Button的点击事件\n\n* 当text field的Action和键盘的弹出和收起动画之间的关系\n\n* 从网上下载大图片\n\n* 往硬盘里面存数据\n\n* 播放视频\n\n以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了textfield弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg)\n\n程序里面不同的部分不会阻塞彼此的执行，iOS提供了几种API，通过多核CPU来在不同的线程上进行不同的工作。\n\n其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。\n\n### UIKit中的一些异步的API\n\n苹果在iOS SDK中提供了很多api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。\n\n你一定用过以下几点\n\n* NotificationCenter\n\n* delegate\n\n* Grand Central Dispatch(GCD)\n\n* Closures（Block）\n\n由于大部分的类都是异步的，并且UI在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的APp会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的APp其实代码的执行顺序都是不同的(当然除了一些自动化测试的场景，那些条件都是预先设置好的。)\n\n其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的SDK，而且他们并不统一。如果使用delegate我们需要遵循特制的格式，block，NotificationCenter等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg)\n\n我们来比较两个代码片段来总结下这章。一个是异步一个是同步。\n\n#### 同步代码\n\n对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:\n* 它是同步执行的。\n\n* 在循环遍历时候他是不可变的\n\n花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:\n\n```\nvar array = [1, 2, 3]\nfor number in array {\n  print(number)\n  array = [4, 5, 6]\n}\nprint(array)\n\n```\n最后的输出结果：\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg)\n\n数组在for循环中是不可变的吗？执行顺序是什么？\n\n#### 异步代码\n\n再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：\n```\nvar array = [1, 2, 3]\nvar currentIndex = 0\n\n//this method is connected in IB to a button\n@IBAction func printNext(_ sender: Any) {\n  print(array[currentIndex])\n\n  if currentIndex != array.count-1 {\n    currentIndex += 1\n  }\n}\n```\n试想一下如果放在我们现实的App中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作(增加、删除元素)那么数据就会发生错乱。而且如果currentIndex被另一个线程改变了那么你也不会得到预期的结果。\n\n其实多线程最重要的就是数据争夺的问题，然而RxSwift很好的解决了这个问题\n","slug":"RX-Swift-Study-One","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lp001ra04wg1w5tq1b","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"Hello-RxSwift\"><a href=\"#Hello-RxSwift\" class=\"headerlink\" title=\"Hello RxSwift!\"></a>Hello RxSwift!</h2><p>这本书可以让你用Swift来编写响应式编程代码。但是到底什么是RxSwift,这里有很好的定义：</p>\n<p><font color=\"orange\">RxSwift是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。</font> <br></p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525870736284&amp;di=9f373001bac8687d5fe11b3d7b40016f&amp;imgtype=0&amp;src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png\" alt=\"\"></p>\n<p>听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。</p>\n<a id=\"more\"></a>\n<p>本书的目标就是带你逐步的去理解RxSwift的API，并且去运用每一个API，然后把它们运用到实际的iOSApp中。</p>\n<p>你将会从RxSwift中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通RxSwift额思想和使用。其实Rx是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对RX有一个坚实的了解，这样你就能继续提高自己的Rx水平了</p>\n<p>其实我们并没有非常确信RxSwift的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。</p>\n<p><font color=\"orange\">RxSwift本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道(队列)里面,以此来达到简化异步并发的过程的目的</font><br></p>\n<p>这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个Action我们用一个管道去装在这些Action，每加一个Action就会把他放管道里面，我们可以理解为管道里面流动的Actions，且管道与管道之间相互独立。同理我们可以吧Button改成一个UITExtField，Action就是每一次输入事件。</p>\n<p>作为一个iOS的开发者我相信这已经很好帮你去理解什么是RxSwift了吧，这应该是比你在一开始看到的那些专业术语好理解的多。</p>\n<p>如果你还是不清楚，那么你至少应该理解，RxSwift可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。</p>\n<h3 id=\"异步编程的介绍\"><a href=\"#异步编程的介绍\" class=\"headerlink\" title=\"异步编程的介绍\"></a>异步编程的介绍</h3><p>如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个iSO的App，那么你一定想到如下几个东西：</p>\n<ul>\n<li><p>接受Button的点击事件</p>\n</li>\n<li><p>当text field的Action和键盘的弹出和收起动画之间的关系</p>\n</li>\n<li><p>从网上下载大图片</p>\n</li>\n<li><p>往硬盘里面存数据</p>\n</li>\n<li><p>播放视频</p>\n</li>\n</ul>\n<p>以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了textfield弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg\" alt=\"\"></p>\n<p>程序里面不同的部分不会阻塞彼此的执行，iOS提供了几种API，通过多核CPU来在不同的线程上进行不同的工作。</p>\n<p>其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。</p>\n<h3 id=\"UIKit中的一些异步的API\"><a href=\"#UIKit中的一些异步的API\" class=\"headerlink\" title=\"UIKit中的一些异步的API\"></a>UIKit中的一些异步的API</h3><p>苹果在iOS SDK中提供了很多api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。</p>\n<p>你一定用过以下几点</p>\n<ul>\n<li><p>NotificationCenter</p>\n</li>\n<li><p>delegate</p>\n</li>\n<li><p>Grand Central Dispatch(GCD)</p>\n</li>\n<li><p>Closures（Block）</p>\n</li>\n</ul>\n<p>由于大部分的类都是异步的，并且UI在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的APp会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的APp其实代码的执行顺序都是不同的(当然除了一些自动化测试的场景，那些条件都是预先设置好的。)</p>\n<p>其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的SDK，而且他们并不统一。如果使用delegate我们需要遵循特制的格式，block，NotificationCenter等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg\" alt=\"\"></p>\n<p>我们来比较两个代码片段来总结下这章。一个是异步一个是同步。</p>\n<h4 id=\"同步代码\"><a href=\"#同步代码\" class=\"headerlink\" title=\"同步代码\"></a>同步代码</h4><p>对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:</p>\n<ul>\n<li><p>它是同步执行的。</p>\n</li>\n<li><p>在循环遍历时候他是不可变的</p>\n</li>\n</ul>\n<p>花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">for number in<span class=\"built_in\"> array </span>&#123;</span><br><span class=\"line\">  print(number)</span><br><span class=\"line\"> <span class=\"built_in\"> array </span>= [4, 5, 6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(array)</span><br></pre></td></tr></table></figure>\n<p>最后的输出结果：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg\" alt=\"\"></p>\n<p>数组在for循环中是不可变的吗？执行顺序是什么？</p>\n<h4 id=\"异步代码\"><a href=\"#异步代码\" class=\"headerlink\" title=\"异步代码\"></a>异步代码</h4><p>再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> currentIndex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//this method is connected in IB to a button</span></span><br><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printNext</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(array[currentIndex])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> currentIndex != array.<span class=\"built_in\">count</span>-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    currentIndex += <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>试想一下如果放在我们现实的App中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作(增加、删除元素)那么数据就会发生错乱。而且如果currentIndex被另一个线程改变了那么你也不会得到预期的结果。</p>\n<p>其实多线程最重要的就是数据争夺的问题，然而RxSwift很好的解决了这个问题</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Hello-RxSwift\"><a href=\"#Hello-RxSwift\" class=\"headerlink\" title=\"Hello RxSwift!\"></a>Hello RxSwift!</h2><p>这本书可以让你用Swift来编写响应式编程代码。但是到底什么是RxSwift,这里有很好的定义：</p>\n<p><font color=\"orange\">RxSwift是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。</font> <br></p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525870736284&amp;di=9f373001bac8687d5fe11b3d7b40016f&amp;imgtype=0&amp;src=http%3A%2F%2Fcode4app.com%2Fdata%2Fattachment%2Fforum%2F201703%2F21%2F210007p6wy7buzq6hqhhdu.png\" alt=\"\"></p>\n<p>听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。</p>","more":"<p>本书的目标就是带你逐步的去理解RxSwift的API，并且去运用每一个API，然后把它们运用到实际的iOSApp中。</p>\n<p>你将会从RxSwift中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通RxSwift额思想和使用。其实Rx是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对RX有一个坚实的了解，这样你就能继续提高自己的Rx水平了</p>\n<p>其实我们并没有非常确信RxSwift的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。</p>\n<p><font color=\"orange\">RxSwift本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道(队列)里面,以此来达到简化异步并发的过程的目的</font><br></p>\n<p>这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个Action我们用一个管道去装在这些Action，每加一个Action就会把他放管道里面，我们可以理解为管道里面流动的Actions，且管道与管道之间相互独立。同理我们可以吧Button改成一个UITExtField，Action就是每一次输入事件。</p>\n<p>作为一个iOS的开发者我相信这已经很好帮你去理解什么是RxSwift了吧，这应该是比你在一开始看到的那些专业术语好理解的多。</p>\n<p>如果你还是不清楚，那么你至少应该理解，RxSwift可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。</p>\n<h3 id=\"异步编程的介绍\"><a href=\"#异步编程的介绍\" class=\"headerlink\" title=\"异步编程的介绍\"></a>异步编程的介绍</h3><p>如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个iSO的App，那么你一定想到如下几个东西：</p>\n<ul>\n<li><p>接受Button的点击事件</p>\n</li>\n<li><p>当text field的Action和键盘的弹出和收起动画之间的关系</p>\n</li>\n<li><p>从网上下载大图片</p>\n</li>\n<li><p>往硬盘里面存数据</p>\n</li>\n<li><p>播放视频</p>\n</li>\n</ul>\n<p>以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了textfield弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图:</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fr41y6xhkij31kw0q0h80.jpg\" alt=\"\"></p>\n<p>程序里面不同的部分不会阻塞彼此的执行，iOS提供了几种API，通过多核CPU来在不同的线程上进行不同的工作。</p>\n<p>其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。</p>\n<h3 id=\"UIKit中的一些异步的API\"><a href=\"#UIKit中的一些异步的API\" class=\"headerlink\" title=\"UIKit中的一些异步的API\"></a>UIKit中的一些异步的API</h3><p>苹果在iOS SDK中提供了很多api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。</p>\n<p>你一定用过以下几点</p>\n<ul>\n<li><p>NotificationCenter</p>\n</li>\n<li><p>delegate</p>\n</li>\n<li><p>Grand Central Dispatch(GCD)</p>\n</li>\n<li><p>Closures（Block）</p>\n</li>\n</ul>\n<p>由于大部分的类都是异步的，并且UI在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的APp会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的APp其实代码的执行顺序都是不同的(当然除了一些自动化测试的场景，那些条件都是预先设置好的。)</p>\n<p>其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的SDK，而且他们并不统一。如果使用delegate我们需要遵循特制的格式，block，NotificationCenter等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图:</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fr4342v718j31kw0nlgzj.jpg\" alt=\"\"></p>\n<p>我们来比较两个代码片段来总结下这章。一个是异步一个是同步。</p>\n<h4 id=\"同步代码\"><a href=\"#同步代码\" class=\"headerlink\" title=\"同步代码\"></a>同步代码</h4><p>对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事:</p>\n<ul>\n<li><p>它是同步执行的。</p>\n</li>\n<li><p>在循环遍历时候他是不可变的</p>\n</li>\n</ul>\n<p>花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码:</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">var<span class=\"built_in\"> array </span>= [1, 2, 3]</span><br><span class=\"line\">for number in<span class=\"built_in\"> array </span>&#123;</span><br><span class=\"line\">  print(number)</span><br><span class=\"line\"> <span class=\"built_in\"> array </span>= [4, 5, 6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(array)</span><br></pre></td></tr></table></figure>\n<p>最后的输出结果：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fr43rz56omj304p02at8i.jpg\" alt=\"\"></p>\n<p>数组在for循环中是不可变的吗？执行顺序是什么？</p>\n<h4 id=\"异步代码\"><a href=\"#异步代码\" class=\"headerlink\" title=\"异步代码\"></a>异步代码</h4><p>再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> currentIndex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//this method is connected in IB to a button</span></span><br><span class=\"line\"><span class=\"meta\">@IBAction</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printNext</span><span class=\"params\">(<span class=\"number\">_</span> sender: Any)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(array[currentIndex])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> currentIndex != array.<span class=\"built_in\">count</span>-<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    currentIndex += <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>试想一下如果放在我们现实的App中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作(增加、删除元素)那么数据就会发生错乱。而且如果currentIndex被另一个线程改变了那么你也不会得到预期的结果。</p>\n<p>其实多线程最重要的就是数据争夺的问题，然而RxSwift很好的解决了这个问题</p>"},{"title":"AlamoFire的使用(下载队列，断点续传)","date":"2018-03-30T09:54:38.000Z","comments":1,"_content":"## 前言\n\n最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。\n\n![](https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png)\n<!--more-->\n\n## 背景\n\n新项目包含了上传下载网络请求相关功能，由于是swift编写所以自然而然选择了 [AlamoFire](https://github.com/Alamofire/Alamofire) (好像也没得选)来做底层，正常的网络请求post、get等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题\n\n## 设置通用超时时间\n\n使用Alamofire发起请求时候有这两个接口\n\n```\n/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,\n/// `method`, `parameters`, `encoding` and `headers`.\n///\n/// - parameter url:        The URL.\n/// - parameter method:     The HTTP method. `.get` by default.\n/// - parameter parameters: The parameters. `nil` by default.\n/// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.\n/// - parameter headers:    The HTTP headers. `nil` by default.\n///\n/// - returns: The created `DataRequest`.\npublic func request(_ url: URLConvertible, method: Alamofire.HTTPMethod = default, parameters: Parameters? = default, encoding: ParameterEncoding = default, headers: HTTPHeaders? = default) -> Alamofire.DataRequest\n\n/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the\n/// specified `urlRequest`.\n///\n/// - parameter urlRequest: The URL request\n///\n/// - returns: The created `DataRequest`.\npublic func request(_ urlRequest: URLRequestConvertible) -> Alamofire.DataRequest\n\n```\n而我们在调用的时候通常会直接这么用\n\n```\nlet req : URLRequest = URLRequest(url: URL(fileURLWithPath: \"32\"), cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10)\n\n        // 第一种方法调用，后面参数直接用default\n        Alamofire.request(URL(fileURLWithPath: \"32\"))\n\n        // 第二中调用，使传入request\n        Alamofire.request(req)\n        let semaphore = DispatchSemaphore(value: 0)\n\n```\n\n其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的URLRequest来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法\n\n* 对生成Request的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.\n\n* 创建 `Alamofire.SessionManager` 通过sessionManager来设置超时时间等一些通用的东西\n\n```\nlet networkManager : SessionManager = {\n        let config : URLSessionConfiguration = URLSessionConfiguration.default\n        config.timeoutIntervalForRequest = 10\n        let manager = Alamofire.SessionManager.init(configuration: config)\n        return manager\n    }()\n```\n\n## 断点续传\nAlamofire支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过data的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传\n\n#### 第一步 断点\n监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的\n\n```\nAlamofire.download(\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\", method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil) { (url, response) -> (destinationURL: URL, options: DownloadRequest.DownloadOptions) in\n            return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, false)[0]+\"123.mp4\")), [.createIntermediateDirectories, .removePreviousFile])\n            }.responseJSON { (response) in\n\n                switch response.result {\n\n                case .success:\n                    print(\"success\")\n                case .failure:\n                    //意外中断后在此处处理下载完成的部分\n                    self.tmpData = response.resumeData\n\n                default:\n                    print(\"failed\")\n                }\n\n        }\n```\n\n#### 第二步 续传\n\n当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用Alamofire这个方法\n```\n/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a\n/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.\n///\n/// If `destination` is not specified, the contents will remain in the temporary location determined by the\n/// underlying URL session.\n///\n/// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken\n/// on background URL session configurations. There's an underlying bug in the `resumeData` generation logic where the\n/// data is written incorrectly and will always fail to resume the download. For more information about the bug and\n/// possible workarounds, please refer to the following Stack Overflow post:\n///\n///    - http://stackoverflow.com/a/39347461/1342462\n///\n/// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`\n///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional\n///                          information.\n/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.\n///\n/// - returns: The created `DownloadRequest`.\npublic func download(resumingWith resumeData: Data, to destination: Alamofire.DownloadRequest.DownloadFileDestination? = default) -> Alamofire.DownloadRequest\n```\n这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定\n```\nAlamofire.download(resumingWith: tmpData!)\n```\n同样他返回一个request的对象，我们可以通过点语法来拿到进度、response等信息\n\n## 批量下载\n\n当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。\n\n#### GCD\n\n我们很自然而然的想到GCD，但是GCD有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载100个文件，如果同时下载的话开辟100个线程，那肯定是不行的，先不说移动设备是否支持(最多70个左右)，即使支持了那这个开销太大。虽说GCD的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。\n\n#### OperationQueue\n\nOperation及OperationQueue是基于GCD封装的对象，作为对象可以提供更多操作选择，可以用方法或block实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像GCD那样使用C语言实现，所以效率会相比GCD低一些。但是对线程的控制的灵活性要远高于GCD，对于下载线程来说可以优先选择这个。\n\n#### 实现\n\n我们把每一个下载任务封装成一个operation。注意Operation不能直接使用，我们需要使用他的子类，这里我选择使用 `BlockOperation` 他的闭包则是需要执行的下载任务，然后我们把他添加进queue中便开始执行了任务\n\n```\nlet op : BlockOperation = BlockOperation { [weak self] in\n            Alamofire.download(\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\", method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil) { (url, response) -> (destinationURL: URL, options: DownloadRequest.DownloadOptions) in\n                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, false)[0]+\"123.mp4\")), [.createIntermediateDirectories, .removePreviousFile])\n                }.downloadProgress { [weak self] (pro) in\n                    let percent = Float(pro.completedUnitCount) / Float(pro.totalUnitCount)\n                    if count == 0 {\n\n                        self?.downLoadLabel.snp.remakeConstraints { (make) in\n                            make.width.equalTo(300 * percent)\n                            make.height.equalTo(30)\n                            make.top.equalTo((self?.stopButton.snp.bottom)!).offset(30)\n                            make.left.equalToSuperview().offset(30)\n                        }\n                    } else {\n                        self?.downLoadLabel2.snp.remakeConstraints { (make) in\n                            make.width.equalTo(300 * percent)\n                            make.height.equalTo(30)\n                            make.top.equalTo((self?.downLoadLabel.snp.bottom)!).offset(30)\n                            make.left.equalToSuperview().offset(30)\n                        }\n                    }\n                }.responseJSON { (response) in\n\n                    switch response.result {\n\n                    case .success:\n                        print(\"success\")\n                    case .failure:\n                        self?.tmpData = response.resumeData\n\n                    default:\n                        print(\"failed\")\n                    }\n\n            }\n        }\n\n        queue.addOperation(op)\n```\n每一个opeeation对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的queue进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo中我只有两个下载任务，所以我就设置最大并发数为1 这样就是一个一个下载。\n```\nlet queue : OperationQueue = {\n        let que : OperationQueue = OperationQueue()\n        que.maxConcurrentOperationCount = 1\n        return que\n    }()\n\n```\n我们运行然后点击开始下载\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif)\n\n很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入queue的任务。正常来说每一个operation都要等上一个operation完成后才会执行，而系统判断完成的标准就是上一个operation的闭包走完，我们闭包中放入的是一个下载任务，而Alamofire的下载都是异步执行，所以导致operation的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证operation闭包中的代码是同步执行的就OK了。而Alamofire是基于URLSession来实现的，并没有像connection那样提供同步的方法，所以我们使用信号量卡一下，像这样\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg)\n\n这样之后就会按照我们设置好的队列进行了\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif)\n\n有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程(除非Alamofire的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个operation中之后，就注定不会在主线程中了，没一个operation都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。\n\n## 总结\n\n因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"Thank You Very Much\",\n            \"author\": \"Margaret\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","source":"_posts/2018-03-30-AlamoFire.md","raw":"---\ntitle: AlamoFire的使用(下载队列，断点续传)\ncategories: iOS开发\ndate: 2018-03-30 17:54:38\ntags:\n - swift\n - 网络请求\ncomments:\n---\n## 前言\n\n最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。\n\n![](https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png)\n<!--more-->\n\n## 背景\n\n新项目包含了上传下载网络请求相关功能，由于是swift编写所以自然而然选择了 [AlamoFire](https://github.com/Alamofire/Alamofire) (好像也没得选)来做底层，正常的网络请求post、get等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题\n\n## 设置通用超时时间\n\n使用Alamofire发起请求时候有这两个接口\n\n```\n/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,\n/// `method`, `parameters`, `encoding` and `headers`.\n///\n/// - parameter url:        The URL.\n/// - parameter method:     The HTTP method. `.get` by default.\n/// - parameter parameters: The parameters. `nil` by default.\n/// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.\n/// - parameter headers:    The HTTP headers. `nil` by default.\n///\n/// - returns: The created `DataRequest`.\npublic func request(_ url: URLConvertible, method: Alamofire.HTTPMethod = default, parameters: Parameters? = default, encoding: ParameterEncoding = default, headers: HTTPHeaders? = default) -> Alamofire.DataRequest\n\n/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the\n/// specified `urlRequest`.\n///\n/// - parameter urlRequest: The URL request\n///\n/// - returns: The created `DataRequest`.\npublic func request(_ urlRequest: URLRequestConvertible) -> Alamofire.DataRequest\n\n```\n而我们在调用的时候通常会直接这么用\n\n```\nlet req : URLRequest = URLRequest(url: URL(fileURLWithPath: \"32\"), cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10)\n\n        // 第一种方法调用，后面参数直接用default\n        Alamofire.request(URL(fileURLWithPath: \"32\"))\n\n        // 第二中调用，使传入request\n        Alamofire.request(req)\n        let semaphore = DispatchSemaphore(value: 0)\n\n```\n\n其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的URLRequest来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法\n\n* 对生成Request的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.\n\n* 创建 `Alamofire.SessionManager` 通过sessionManager来设置超时时间等一些通用的东西\n\n```\nlet networkManager : SessionManager = {\n        let config : URLSessionConfiguration = URLSessionConfiguration.default\n        config.timeoutIntervalForRequest = 10\n        let manager = Alamofire.SessionManager.init(configuration: config)\n        return manager\n    }()\n```\n\n## 断点续传\nAlamofire支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过data的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传\n\n#### 第一步 断点\n监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的\n\n```\nAlamofire.download(\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\", method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil) { (url, response) -> (destinationURL: URL, options: DownloadRequest.DownloadOptions) in\n            return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, false)[0]+\"123.mp4\")), [.createIntermediateDirectories, .removePreviousFile])\n            }.responseJSON { (response) in\n\n                switch response.result {\n\n                case .success:\n                    print(\"success\")\n                case .failure:\n                    //意外中断后在此处处理下载完成的部分\n                    self.tmpData = response.resumeData\n\n                default:\n                    print(\"failed\")\n                }\n\n        }\n```\n\n#### 第二步 续传\n\n当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用Alamofire这个方法\n```\n/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a\n/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.\n///\n/// If `destination` is not specified, the contents will remain in the temporary location determined by the\n/// underlying URL session.\n///\n/// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken\n/// on background URL session configurations. There's an underlying bug in the `resumeData` generation logic where the\n/// data is written incorrectly and will always fail to resume the download. For more information about the bug and\n/// possible workarounds, please refer to the following Stack Overflow post:\n///\n///    - http://stackoverflow.com/a/39347461/1342462\n///\n/// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`\n///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional\n///                          information.\n/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.\n///\n/// - returns: The created `DownloadRequest`.\npublic func download(resumingWith resumeData: Data, to destination: Alamofire.DownloadRequest.DownloadFileDestination? = default) -> Alamofire.DownloadRequest\n```\n这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定\n```\nAlamofire.download(resumingWith: tmpData!)\n```\n同样他返回一个request的对象，我们可以通过点语法来拿到进度、response等信息\n\n## 批量下载\n\n当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。\n\n#### GCD\n\n我们很自然而然的想到GCD，但是GCD有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载100个文件，如果同时下载的话开辟100个线程，那肯定是不行的，先不说移动设备是否支持(最多70个左右)，即使支持了那这个开销太大。虽说GCD的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。\n\n#### OperationQueue\n\nOperation及OperationQueue是基于GCD封装的对象，作为对象可以提供更多操作选择，可以用方法或block实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像GCD那样使用C语言实现，所以效率会相比GCD低一些。但是对线程的控制的灵活性要远高于GCD，对于下载线程来说可以优先选择这个。\n\n#### 实现\n\n我们把每一个下载任务封装成一个operation。注意Operation不能直接使用，我们需要使用他的子类，这里我选择使用 `BlockOperation` 他的闭包则是需要执行的下载任务，然后我们把他添加进queue中便开始执行了任务\n\n```\nlet op : BlockOperation = BlockOperation { [weak self] in\n            Alamofire.download(\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\", method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil) { (url, response) -> (destinationURL: URL, options: DownloadRequest.DownloadOptions) in\n                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, false)[0]+\"123.mp4\")), [.createIntermediateDirectories, .removePreviousFile])\n                }.downloadProgress { [weak self] (pro) in\n                    let percent = Float(pro.completedUnitCount) / Float(pro.totalUnitCount)\n                    if count == 0 {\n\n                        self?.downLoadLabel.snp.remakeConstraints { (make) in\n                            make.width.equalTo(300 * percent)\n                            make.height.equalTo(30)\n                            make.top.equalTo((self?.stopButton.snp.bottom)!).offset(30)\n                            make.left.equalToSuperview().offset(30)\n                        }\n                    } else {\n                        self?.downLoadLabel2.snp.remakeConstraints { (make) in\n                            make.width.equalTo(300 * percent)\n                            make.height.equalTo(30)\n                            make.top.equalTo((self?.downLoadLabel.snp.bottom)!).offset(30)\n                            make.left.equalToSuperview().offset(30)\n                        }\n                    }\n                }.responseJSON { (response) in\n\n                    switch response.result {\n\n                    case .success:\n                        print(\"success\")\n                    case .failure:\n                        self?.tmpData = response.resumeData\n\n                    default:\n                        print(\"failed\")\n                    }\n\n            }\n        }\n\n        queue.addOperation(op)\n```\n每一个opeeation对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的queue进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo中我只有两个下载任务，所以我就设置最大并发数为1 这样就是一个一个下载。\n```\nlet queue : OperationQueue = {\n        let que : OperationQueue = OperationQueue()\n        que.maxConcurrentOperationCount = 1\n        return que\n    }()\n\n```\n我们运行然后点击开始下载\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif)\n\n很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入queue的任务。正常来说每一个operation都要等上一个operation完成后才会执行，而系统判断完成的标准就是上一个operation的闭包走完，我们闭包中放入的是一个下载任务，而Alamofire的下载都是异步执行，所以导致operation的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证operation闭包中的代码是同步执行的就OK了。而Alamofire是基于URLSession来实现的，并没有像connection那样提供同步的方法，所以我们使用信号量卡一下，像这样\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg)\n\n这样之后就会按照我们设置好的队列进行了\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif)\n\n有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程(除非Alamofire的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个operation中之后，就注定不会在主线程中了，没一个operation都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。\n\n## 总结\n\n因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注\n\n{% aplayerlist %}\n{\n    \"autoplay\": true,\n    \"showlrc\": 0,\n    \"mutex\": true,\n    \"music\": [\n        {\n            \"title\": \"Thank You Very Much\",\n            \"author\": \"Margaret\",\n            \"url\": \"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\n            \"pic\": \"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\n            \"lrc\": \"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"\n        }\n    ]\n}\n{% endaplayerlist %}\n","slug":"AlamoFire","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lt001ta04wfw3cur9y","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>新项目包含了上传下载网络请求相关功能，由于是swift编写所以自然而然选择了 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\">AlamoFire</a> (好像也没得选)来做底层，正常的网络请求post、get等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题</p>\n<h2 id=\"设置通用超时时间\"><a href=\"#设置通用超时时间\" class=\"headerlink\" title=\"设置通用超时时间\"></a>设置通用超时时间</h2><p>使用Alamofire发起请求时候有这两个接口</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// Creates </span>a<span class=\"markdown\"> <span class=\"code\">`DataRequest`</span> using </span>the<span class=\"markdown\"> default <span class=\"code\">`SessionManager`</span> to retrieve </span>the<span class=\"markdown\"> contents of </span>the<span class=\"markdown\"> specified <span class=\"code\">`url`</span>,</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// <span class=\"code\">`method`</span>, <span class=\"code\">`parameters`</span>, <span class=\"code\">`encoding`</span> and <span class=\"code\">`headers`</span>.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter url:        The URL.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter method:     The HTTP method. <span class=\"code\">`.get`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter parameters: The parameters. <span class=\"code\">`nil`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter encoding:   The parameter encoding. <span class=\"code\">`URLEncoding.default`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter headers:    The HTTP headers. <span class=\"code\">`nil`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - returns: The created <span class=\"code\">`DataRequest`</span>.</span></span></span><br><span class=\"line\">public func request(_ url: URLConvertible, method: Alamofire.HTTPMethod = <span class=\"keyword\">default</span>, parameters: Parameters? = <span class=\"keyword\">default</span>, encoding: ParameterEncoding = <span class=\"keyword\">default</span>, headers: HTTPHeaders? = <span class=\"keyword\">default</span>) -&gt; Alamofire.DataRequest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// Creates </span>a<span class=\"markdown\"> <span class=\"code\">`DataRequest`</span> using </span>the<span class=\"markdown\"> default <span class=\"code\">`SessionManager`</span> to retrieve </span>the<span class=\"markdown\"> contents of </span>a<span class=\"markdown\"> URL based on </span>the<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// specified <span class=\"code\">`urlRequest`</span>.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter urlRequest: The URL request</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - returns: The created <span class=\"code\">`DataRequest`</span>.</span></span></span><br><span class=\"line\">public func request(_ urlRequest: URLRequestConvertible) -&gt; Alamofire.DataRequest</span><br></pre></td></tr></table></figure>\n<p>而我们在调用的时候通常会直接这么用</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">let <span class=\"string\">req :</span> URLRequest = URLRequest(<span class=\"string\">url:</span> URL(<span class=\"string\">fileURLWithPath:</span> <span class=\"string\">\"32\"</span>), <span class=\"string\">cachePolicy:</span> .useProtocolCachePolicy, <span class=\"string\">timeoutInterval:</span> <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一种方法调用，后面参数直接用default</span></span><br><span class=\"line\">        Alamofire.request(URL(<span class=\"string\">fileURLWithPath:</span> <span class=\"string\">\"32\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二中调用，使传入request</span></span><br><span class=\"line\">        Alamofire.request(req)</span><br><span class=\"line\">        let semaphore = DispatchSemaphore(<span class=\"string\">value:</span> <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的URLRequest来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法</p>\n<ul>\n<li><p>对生成Request的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.</p>\n</li>\n<li><p>创建 <code>Alamofire.SessionManager</code> 通过sessionManager来设置超时时间等一些通用的东西</p>\n</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">let networkManager : SessionManager = &#123;</span><br><span class=\"line\">        let<span class=\"built_in\"> config </span>: URLSessionConfiguration = URLSessionConfiguration.default</span><br><span class=\"line\">        config.timeoutIntervalForRequest = 10</span><br><span class=\"line\">        let manager = Alamofire.SessionManager.init(configuration: config)</span><br><span class=\"line\">        return manager</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure>\n<h2 id=\"断点续传\"><a href=\"#断点续传\" class=\"headerlink\" title=\"断点续传\"></a>断点续传</h2><p>Alamofire支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过data的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传</p>\n<h4 id=\"第一步-断点\"><a href=\"#第一步-断点\" class=\"headerlink\" title=\"第一步 断点\"></a>第一步 断点</h4><p>监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">Alamofire.download(<span class=\"string\">\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\"</span>, method: <span class=\"selector-class\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"selector-class\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) <span class=\"keyword\">in</span></span><br><span class=\"line\">            return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"selector-class\">.documentDirectory</span>, <span class=\"selector-class\">.userDomainMask</span>, false)[<span class=\"number\">0</span>]+<span class=\"string\">\"123.mp4\"</span>)), [<span class=\"selector-class\">.createIntermediateDirectories</span>, .removePreviousFile])</span><br><span class=\"line\">            &#125;<span class=\"selector-class\">.responseJSON</span> &#123; (response) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">                switch response<span class=\"selector-class\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                case <span class=\"selector-class\">.success</span>:</span><br><span class=\"line\">                    print(<span class=\"string\">\"success\"</span>)</span><br><span class=\"line\">                case <span class=\"selector-class\">.failure</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//意外中断后在此处处理下载完成的部分</span></span><br><span class=\"line\">                    self<span class=\"selector-class\">.tmpData</span> = response.resumeData</span><br><span class=\"line\"></span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    print(<span class=\"string\">\"failed\"</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步-续传\"><a href=\"#第二步-续传\" class=\"headerlink\" title=\"第二步 续传\"></a>第二步 续传</h4><p>当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用Alamofire这个方法<br><figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// Creates </span>a<span class=\"markdown\"> <span class=\"code\">`DownloadRequest`</span> using </span>the<span class=\"markdown\"> default <span class=\"code\">`SessionManager`</span> from </span>the<span class=\"markdown\"> <span class=\"code\">`resumeData`</span> produced from </span>a<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// previous request cancellation to retrieve </span>the<span class=\"markdown\"> contents of </span>the<span class=\"markdown\"> original request and save them to </span>the<span class=\"markdown\"> <span class=\"code\">`destination`</span>.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// If <span class=\"code\">`destination`</span> is not specified, </span>the<span class=\"markdown\"> contents </span>will<span class=\"markdown\"> remain in </span>the<span class=\"markdown\"> temporary location determined by </span>the<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// underlying URL session.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// On </span>the<span class=\"markdown\"> latest release of all </span>the<span class=\"markdown\"> Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), <span class=\"code\">`resumeData`</span> is broken</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// on background URL session configurations. There's </span>an<span class=\"markdown\"> underlying bug in </span>the<span class=\"markdown\"> <span class=\"code\">`resumeData`</span> generation logic where </span>the<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// data is written incorrectly and </span>will<span class=\"markdown\"> always fail to resume </span>the<span class=\"markdown\"> download. For </span>more<span class=\"markdown\"> information about </span>the<span class=\"markdown\"> bug and</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// possible workarounds, please refer to </span>the<span class=\"markdown\"> following Stack Overflow post:</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///    - http://stackoverflow.com/</span>a<span class=\"markdown\">/39347461/1342462</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter resumeData:  The resume data. This is </span>an<span class=\"markdown\"> opaque data blob produced by <span class=\"code\">`URLSessionDownloadTask`</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///                          when </span>a<span class=\"markdown\"> task is cancelled. See <span class=\"code\">`URLSession -downloadTask(withResumeData:)`</span> for additional</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///                          information.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter destination: The closure used to determine </span>the<span class=\"markdown\"> destination of </span>the<span class=\"markdown\"> downloaded file. <span class=\"code\">`nil`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - returns: The created <span class=\"code\">`DownloadRequest`</span>.</span></span></span><br><span class=\"line\">public func download(resumingWith resumeData: Data, to destination: Alamofire.DownloadRequest.DownloadFileDestination? = <span class=\"keyword\">default</span>) -&gt; Alamofire.DownloadRequest</span><br></pre></td></tr></table></figure></p>\n<p>这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定<br><figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Alamofire</span><span class=\"selector-class\">.download</span>(<span class=\"attribute\">resumingWith</span>: tmpData!)</span><br></pre></td></tr></table></figure></p>\n<p>同样他返回一个request的对象，我们可以通过点语法来拿到进度、response等信息</p>\n<h2 id=\"批量下载\"><a href=\"#批量下载\" class=\"headerlink\" title=\"批量下载\"></a>批量下载</h2><p>当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。</p>\n<h4 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h4><p>我们很自然而然的想到GCD，但是GCD有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载100个文件，如果同时下载的话开辟100个线程，那肯定是不行的，先不说移动设备是否支持(最多70个左右)，即使支持了那这个开销太大。虽说GCD的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。</p>\n<h4 id=\"OperationQueue\"><a href=\"#OperationQueue\" class=\"headerlink\" title=\"OperationQueue\"></a>OperationQueue</h4><p>Operation及OperationQueue是基于GCD封装的对象，作为对象可以提供更多操作选择，可以用方法或block实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像GCD那样使用C语言实现，所以效率会相比GCD低一些。但是对线程的控制的灵活性要远高于GCD，对于下载线程来说可以优先选择这个。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>我们把每一个下载任务封装成一个operation。注意Operation不能直接使用，我们需要使用他的子类，这里我选择使用 <code>BlockOperation</code> 他的闭包则是需要执行的下载任务，然后我们把他添加进queue中便开始执行了任务</p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"code\"><pre><span class=\"line\">let op : BlockOperation = BlockOperation &#123; [<span class=\"attribute\">weak self] in</span></span><br><span class=\"line\"><span class=\"attribute\">            Alamofire.download(\"http</span>://clips<span class=\"variable\">.vorwaerts-gmbh</span><span class=\"variable\">.de</span>/big_buck_bunny<span class=\"variable\">.mp</span>4\", method: <span class=\"variable\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"variable\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest<span class=\"variable\">.DownloadOptions</span>) in</span><br><span class=\"line\">                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"variable\">.documentDirectory</span>, <span class=\"variable\">.userDomainMask</span>, false)[0]+\"123<span class=\"variable\">.mp</span>4\")), [<span class=\"variable\">.createIntermediateDirectories</span>, <span class=\"variable\">.removePreviousFile</span>])</span><br><span class=\"line\">                &#125;<span class=\"variable\">.downloadProgress</span> &#123; [weak self] (pro) in</span><br><span class=\"line\">                    let percent = Float(pro<span class=\"variable\">.completedUnitCount</span>) / Float(pro<span class=\"variable\">.totalUnitCount</span>)</span><br><span class=\"line\">                    if count == 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.stopButton</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span>2<span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"variable\">.responseJSON</span> &#123; (response) in</span><br><span class=\"line\"></span><br><span class=\"line\">                    switch response<span class=\"variable\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case <span class=\"variable\">.success</span>:</span><br><span class=\"line\">                        print(\"success\")</span><br><span class=\"line\">                    case <span class=\"variable\">.failure</span>:</span><br><span class=\"line\">                        self?<span class=\"variable\">.tmpData</span> = response<span class=\"variable\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        print(\"failed\")</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue<span class=\"variable\">.addOperation</span>(op)</span><br></pre></td></tr></table></figure>\n<p>每一个opeeation对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的queue进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo中我只有两个下载任务，所以我就设置最大并发数为1 这样就是一个一个下载。<br><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">let<span class=\"built_in\"> queue </span>: OperationQueue = &#123;</span><br><span class=\"line\">        let que : OperationQueue = OperationQueue()</span><br><span class=\"line\">        que.maxConcurrentOperationCount = 1</span><br><span class=\"line\">        return que</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure></p>\n<p>我们运行然后点击开始下载</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif\" alt=\"\"></p>\n<p>很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入queue的任务。正常来说每一个operation都要等上一个operation完成后才会执行，而系统判断完成的标准就是上一个operation的闭包走完，我们闭包中放入的是一个下载任务，而Alamofire的下载都是异步执行，所以导致operation的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证operation闭包中的代码是同步执行的就OK了。而Alamofire是基于URLSession来实现的，并没有像connection那样提供同步的方法，所以我们使用信号量卡一下，像这样</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg\" alt=\"\"></p>\n<p>这样之后就会按照我们设置好的队列进行了</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif\" alt=\"\"></p>\n<p>有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程(除非Alamofire的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个operation中之后，就注定不会在主线程中了，没一个operation都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注</p>\n\n\t\t\t<div id=\"aplayer5\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"Thank You Very Much\",\"author\":\"Margaret\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer5\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>\n\n\t\t\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Alamofire/Alamofire/master/alamofire.png\" alt=\"\"><br>","more":"</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>新项目包含了上传下载网络请求相关功能，由于是swift编写所以自然而然选择了 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\">AlamoFire</a> (好像也没得选)来做底层，正常的网络请求post、get等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题</p>\n<h2 id=\"设置通用超时时间\"><a href=\"#设置通用超时时间\" class=\"headerlink\" title=\"设置通用超时时间\"></a>设置通用超时时间</h2><p>使用Alamofire发起请求时候有这两个接口</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// Creates </span>a<span class=\"markdown\"> <span class=\"code\">`DataRequest`</span> using </span>the<span class=\"markdown\"> default <span class=\"code\">`SessionManager`</span> to retrieve </span>the<span class=\"markdown\"> contents of </span>the<span class=\"markdown\"> specified <span class=\"code\">`url`</span>,</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// <span class=\"code\">`method`</span>, <span class=\"code\">`parameters`</span>, <span class=\"code\">`encoding`</span> and <span class=\"code\">`headers`</span>.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter url:        The URL.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter method:     The HTTP method. <span class=\"code\">`.get`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter parameters: The parameters. <span class=\"code\">`nil`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter encoding:   The parameter encoding. <span class=\"code\">`URLEncoding.default`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter headers:    The HTTP headers. <span class=\"code\">`nil`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - returns: The created <span class=\"code\">`DataRequest`</span>.</span></span></span><br><span class=\"line\">public func request(_ url: URLConvertible, method: Alamofire.HTTPMethod = <span class=\"keyword\">default</span>, parameters: Parameters? = <span class=\"keyword\">default</span>, encoding: ParameterEncoding = <span class=\"keyword\">default</span>, headers: HTTPHeaders? = <span class=\"keyword\">default</span>) -&gt; Alamofire.DataRequest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// Creates </span>a<span class=\"markdown\"> <span class=\"code\">`DataRequest`</span> using </span>the<span class=\"markdown\"> default <span class=\"code\">`SessionManager`</span> to retrieve </span>the<span class=\"markdown\"> contents of </span>a<span class=\"markdown\"> URL based on </span>the<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// specified <span class=\"code\">`urlRequest`</span>.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter urlRequest: The URL request</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - returns: The created <span class=\"code\">`DataRequest`</span>.</span></span></span><br><span class=\"line\">public func request(_ urlRequest: URLRequestConvertible) -&gt; Alamofire.DataRequest</span><br></pre></td></tr></table></figure>\n<p>而我们在调用的时候通常会直接这么用</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">let <span class=\"string\">req :</span> URLRequest = URLRequest(<span class=\"string\">url:</span> URL(<span class=\"string\">fileURLWithPath:</span> <span class=\"string\">\"32\"</span>), <span class=\"string\">cachePolicy:</span> .useProtocolCachePolicy, <span class=\"string\">timeoutInterval:</span> <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一种方法调用，后面参数直接用default</span></span><br><span class=\"line\">        Alamofire.request(URL(<span class=\"string\">fileURLWithPath:</span> <span class=\"string\">\"32\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二中调用，使传入request</span></span><br><span class=\"line\">        Alamofire.request(req)</span><br><span class=\"line\">        let semaphore = DispatchSemaphore(<span class=\"string\">value:</span> <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的URLRequest来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法</p>\n<ul>\n<li><p>对生成Request的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入.</p>\n</li>\n<li><p>创建 <code>Alamofire.SessionManager</code> 通过sessionManager来设置超时时间等一些通用的东西</p>\n</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">let networkManager : SessionManager = &#123;</span><br><span class=\"line\">        let<span class=\"built_in\"> config </span>: URLSessionConfiguration = URLSessionConfiguration.default</span><br><span class=\"line\">        config.timeoutIntervalForRequest = 10</span><br><span class=\"line\">        let manager = Alamofire.SessionManager.init(configuration: config)</span><br><span class=\"line\">        return manager</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure>\n<h2 id=\"断点续传\"><a href=\"#断点续传\" class=\"headerlink\" title=\"断点续传\"></a>断点续传</h2><p>Alamofire支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过data的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传</p>\n<h4 id=\"第一步-断点\"><a href=\"#第一步-断点\" class=\"headerlink\" title=\"第一步 断点\"></a>第一步 断点</h4><p>监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">Alamofire.download(<span class=\"string\">\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\"</span>, method: <span class=\"selector-class\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"selector-class\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) <span class=\"keyword\">in</span></span><br><span class=\"line\">            return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"selector-class\">.documentDirectory</span>, <span class=\"selector-class\">.userDomainMask</span>, false)[<span class=\"number\">0</span>]+<span class=\"string\">\"123.mp4\"</span>)), [<span class=\"selector-class\">.createIntermediateDirectories</span>, .removePreviousFile])</span><br><span class=\"line\">            &#125;<span class=\"selector-class\">.responseJSON</span> &#123; (response) <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">                switch response<span class=\"selector-class\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                case <span class=\"selector-class\">.success</span>:</span><br><span class=\"line\">                    print(<span class=\"string\">\"success\"</span>)</span><br><span class=\"line\">                case <span class=\"selector-class\">.failure</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//意外中断后在此处处理下载完成的部分</span></span><br><span class=\"line\">                    self<span class=\"selector-class\">.tmpData</span> = response.resumeData</span><br><span class=\"line\"></span><br><span class=\"line\">                default:</span><br><span class=\"line\">                    print(<span class=\"string\">\"failed\"</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步-续传\"><a href=\"#第二步-续传\" class=\"headerlink\" title=\"第二步 续传\"></a>第二步 续传</h4><p>当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用Alamofire这个方法<br><figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// Creates </span>a<span class=\"markdown\"> <span class=\"code\">`DownloadRequest`</span> using </span>the<span class=\"markdown\"> default <span class=\"code\">`SessionManager`</span> from </span>the<span class=\"markdown\"> <span class=\"code\">`resumeData`</span> produced from </span>a<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// previous request cancellation to retrieve </span>the<span class=\"markdown\"> contents of </span>the<span class=\"markdown\"> original request and save them to </span>the<span class=\"markdown\"> <span class=\"code\">`destination`</span>.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// If <span class=\"code\">`destination`</span> is not specified, </span>the<span class=\"markdown\"> contents </span>will<span class=\"markdown\"> remain in </span>the<span class=\"markdown\"> temporary location determined by </span>the<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// underlying URL session.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// On </span>the<span class=\"markdown\"> latest release of all </span>the<span class=\"markdown\"> Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), <span class=\"code\">`resumeData`</span> is broken</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// on background URL session configurations. There's </span>an<span class=\"markdown\"> underlying bug in </span>the<span class=\"markdown\"> <span class=\"code\">`resumeData`</span> generation logic where </span>the<span class=\"markdown\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// data is written incorrectly and </span>will<span class=\"markdown\"> always fail to resume </span>the<span class=\"markdown\"> download. For </span>more<span class=\"markdown\"> information about </span>the<span class=\"markdown\"> bug and</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// possible workarounds, please refer to </span>the<span class=\"markdown\"> following Stack Overflow post:</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///    - http://stackoverflow.com/</span>a<span class=\"markdown\">/39347461/1342462</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter resumeData:  The resume data. This is </span>an<span class=\"markdown\"> opaque data blob produced by <span class=\"code\">`URLSessionDownloadTask`</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///                          when </span>a<span class=\"markdown\"> task is cancelled. See <span class=\"code\">`URLSession -downloadTask(withResumeData:)`</span> for additional</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///                          information.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - parameter destination: The closure used to determine </span>the<span class=\"markdown\"> destination of </span>the<span class=\"markdown\"> downloaded file. <span class=\"code\">`nil`</span> by default.</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">///</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/// - returns: The created <span class=\"code\">`DownloadRequest`</span>.</span></span></span><br><span class=\"line\">public func download(resumingWith resumeData: Data, to destination: Alamofire.DownloadRequest.DownloadFileDestination? = <span class=\"keyword\">default</span>) -&gt; Alamofire.DownloadRequest</span><br></pre></td></tr></table></figure></p>\n<p>这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定<br><figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Alamofire</span><span class=\"selector-class\">.download</span>(<span class=\"attribute\">resumingWith</span>: tmpData!)</span><br></pre></td></tr></table></figure></p>\n<p>同样他返回一个request的对象，我们可以通过点语法来拿到进度、response等信息</p>\n<h2 id=\"批量下载\"><a href=\"#批量下载\" class=\"headerlink\" title=\"批量下载\"></a>批量下载</h2><p>当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。</p>\n<h4 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h4><p>我们很自然而然的想到GCD，但是GCD有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载100个文件，如果同时下载的话开辟100个线程，那肯定是不行的，先不说移动设备是否支持(最多70个左右)，即使支持了那这个开销太大。虽说GCD的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。</p>\n<h4 id=\"OperationQueue\"><a href=\"#OperationQueue\" class=\"headerlink\" title=\"OperationQueue\"></a>OperationQueue</h4><p>Operation及OperationQueue是基于GCD封装的对象，作为对象可以提供更多操作选择，可以用方法或block实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像GCD那样使用C语言实现，所以效率会相比GCD低一些。但是对线程的控制的灵活性要远高于GCD，对于下载线程来说可以优先选择这个。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>我们把每一个下载任务封装成一个operation。注意Operation不能直接使用，我们需要使用他的子类，这里我选择使用 <code>BlockOperation</code> 他的闭包则是需要执行的下载任务，然后我们把他添加进queue中便开始执行了任务</p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"code\"><pre><span class=\"line\">let op : BlockOperation = BlockOperation &#123; [<span class=\"attribute\">weak self] in</span></span><br><span class=\"line\"><span class=\"attribute\">            Alamofire.download(\"http</span>://clips<span class=\"variable\">.vorwaerts-gmbh</span><span class=\"variable\">.de</span>/big_buck_bunny<span class=\"variable\">.mp</span>4\", method: <span class=\"variable\">.get</span>, parameters: nil, encoding: URLEncoding<span class=\"variable\">.default</span>, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest<span class=\"variable\">.DownloadOptions</span>) in</span><br><span class=\"line\">                return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(<span class=\"variable\">.documentDirectory</span>, <span class=\"variable\">.userDomainMask</span>, false)[0]+\"123<span class=\"variable\">.mp</span>4\")), [<span class=\"variable\">.createIntermediateDirectories</span>, <span class=\"variable\">.removePreviousFile</span>])</span><br><span class=\"line\">                &#125;<span class=\"variable\">.downloadProgress</span> &#123; [weak self] (pro) in</span><br><span class=\"line\">                    let percent = Float(pro<span class=\"variable\">.completedUnitCount</span>) / Float(pro<span class=\"variable\">.totalUnitCount</span>)</span><br><span class=\"line\">                    if count == 0 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.stopButton</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        self?<span class=\"variable\">.downLoadLabel</span>2<span class=\"variable\">.snp</span><span class=\"variable\">.remakeConstraints</span> &#123; (make) in</span><br><span class=\"line\">                            make<span class=\"variable\">.width</span><span class=\"variable\">.equalTo</span>(300 * percent)</span><br><span class=\"line\">                            make<span class=\"variable\">.height</span><span class=\"variable\">.equalTo</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.top</span><span class=\"variable\">.equalTo</span>((self?<span class=\"variable\">.downLoadLabel</span><span class=\"variable\">.snp</span><span class=\"variable\">.bottom</span>)!)<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                            make<span class=\"variable\">.left</span><span class=\"variable\">.equalToSuperview</span>()<span class=\"variable\">.offset</span>(30)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"variable\">.responseJSON</span> &#123; (response) in</span><br><span class=\"line\"></span><br><span class=\"line\">                    switch response<span class=\"variable\">.result</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case <span class=\"variable\">.success</span>:</span><br><span class=\"line\">                        print(\"success\")</span><br><span class=\"line\">                    case <span class=\"variable\">.failure</span>:</span><br><span class=\"line\">                        self?<span class=\"variable\">.tmpData</span> = response<span class=\"variable\">.resumeData</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        print(\"failed\")</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue<span class=\"variable\">.addOperation</span>(op)</span><br></pre></td></tr></table></figure>\n<p>每一个opeeation对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的queue进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo中我只有两个下载任务，所以我就设置最大并发数为1 这样就是一个一个下载。<br><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">let<span class=\"built_in\"> queue </span>: OperationQueue = &#123;</span><br><span class=\"line\">        let que : OperationQueue = OperationQueue()</span><br><span class=\"line\">        que.maxConcurrentOperationCount = 1</span><br><span class=\"line\">        return que</span><br><span class=\"line\">    &#125;()</span><br></pre></td></tr></table></figure></p>\n<p>我们运行然后点击开始下载</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fpw0vlzbp6g308h0gnkjm.gif\" alt=\"\"></p>\n<p>很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入queue的任务。正常来说每一个operation都要等上一个operation完成后才会执行，而系统判断完成的标准就是上一个operation的闭包走完，我们闭包中放入的是一个下载任务，而Alamofire的下载都是异步执行，所以导致operation的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证operation闭包中的代码是同步执行的就OK了。而Alamofire是基于URLSession来实现的，并没有像connection那样提供同步的方法，所以我们使用信号量卡一下，像这样</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fpw1444jp0j31610qbgrr.jpg\" alt=\"\"></p>\n<p>这样之后就会按照我们设置好的队列进行了</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fpw15riwhjg308h0gnb2i.gif\" alt=\"\"></p>\n<p>有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程(除非Alamofire的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个operation中之后，就注定不会在主线程中了，没一个operation都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注</p>\n\n\t\t\t<div id=\"aplayer5\" class=\"aplayer\" style=\"margin-bottom: 20px;\"></div>\n\t\t\t<script>\n\t\t\t\tvar options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":0,\"mutex\":true,\"music\":[{\"title\":\"Thank You Very Much\",\"author\":\"Margaret\",\"url\":\"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000\",\"lrc\":\"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO\"}]};\n\t\t\t\toptions.element = document.getElementById(\"aplayer5\");\n\t\t\t\tnew APlayer(options);\n\t\t\t</script>"},{"title":"SVN切换到Git","date":"2018-08-23T12:47:19.000Z","comments":1,"_content":"## 背景：\nSVN和Git同样都是在特定时代下比较优秀的版本控制系统，但是随着时代的发展，SVN越来越不能满足多人开发的需求，尤其是在多种多样，天马星空的业务场景面前，SVN会显得力不从心。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fujxnf8ilhj30zk0m8gm9.jpg)\n\n<!-- more -->\n","source":"_posts/2018-08-23-ChangeSvnToGit.md","raw":"---\ntitle: SVN切换到Git\ncategories: 通用开发\ndate: 2018-08-23 20:47:19\ntags:\n  - git\n  - 代码版本控制  \ncomments:\n---\n## 背景：\nSVN和Git同样都是在特定时代下比较优秀的版本控制系统，但是随着时代的发展，SVN越来越不能满足多人开发的需求，尤其是在多种多样，天马星空的业务场景面前，SVN会显得力不从心。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fujxnf8ilhj30zk0m8gm9.jpg)\n\n<!-- more -->\n","slug":"ChangeSvnToGit","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lv001xa04wpmlz7xso","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>SVN和Git同样都是在特定时代下比较优秀的版本控制系统，但是随着时代的发展，SVN越来越不能满足多人开发的需求，尤其是在多种多样，天马星空的业务场景面前，SVN会显得力不从心。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fujxnf8ilhj30zk0m8gm9.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>SVN和Git同样都是在特定时代下比较优秀的版本控制系统，但是随着时代的发展，SVN越来越不能满足多人开发的需求，尤其是在多种多样，天马星空的业务场景面前，SVN会显得力不从心。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwgy1fujxnf8ilhj30zk0m8gm9.jpg\" alt=\"\"></p>","more":""},{"title":"GitFlow流程","date":"2018-08-23T06:20:39.000Z","comments":1,"_content":"# 关于gitflow\n## 概念：\nGit Flow是构建在Git之上的一个组织、管理软件开发活动的模型。Git Flow是一套使用Git进行源代码管理时的一套行为规范和，通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为“Git Flow”。\n## 原理：\ngitflow的\b核心就branch，通过在项目的不同阶段对branch的不同操作包括但不限于create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。**Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率**。用一张图来了解gitflow的流程：从右向左看 从上到下看\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1ftk5pkvn7ij30vy16cwhl.jpg)\n\n<!-- more -->\n\n## Branch：\nBranch是gitfolw的核心。主要分为两大类 **Main Branchs** 和 **Supporting branches**, 其中 **Main Branchs** 中又包含了 **Master** 和 **Develop**，而 **Supporting branches** 中包含了 **Feature **、**Release**、**Hotfix** **以及其他自定义分支**，下面逐一讲解：\n\n#### Master:\n* 描述：\n\n  master分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master分支上的代码要被更新，同时，每一次更新，都需要在master上打上对应的版本号(tag)。\n\n* 生成及销毁：\n\n  任何人不允许在master上进行代码的直接提交，只接受合入，Master上的代码必须是要从经过多轮测试且已经发布一段时间(根据DAU以及项目实际情况来定，个人建议K歌国际版可以定为一周)且线上已经稳定的 **release** 分支合并进去，然后在Master 上生成tag(通常就是对应的版本号)\n\n* 命名：\n\n  master\n\n#### Develop:\n* 描述：\n\n  develop分支是保存当前最新版本开发成果的分支。该分支上的代码允许有BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支(如果有夜间测试的话)所以该分支也叫做Nightly build。当develop分支上的代码已实现了软件需求说明书中所有的功能(必须经过开发自测，但是不必经过QA)且相对稳定时候，就可以基于此分支来拉出新的release分支交付QA进行测试。\n\n* 生成及销毁：\n\n  Develop分支是由一个人(通常是Team Leader)从Master中拉出，任何人不得在Develop上进行代码提交，只接受合入。Develop上所有代码一定都是由 **Supporting branches** 中的Branch合并进来，且合入Develop的分支必须保证功能完整，可以独立运行，可允许包含一些BUG(但是最好经过自测，不要有太大或者太明显的BUG，比如一启动就crash之类的)。\n\n* 命名：\n\n    develop\n\n* 流程：\n\n ![](https://ws4.sinaimg.cn/large/006tNc79gy1ftk7aszas4j30eu0mc74p.jpg)    \n\n#### Feature:\n  * 描述：\n\n    Feature分支通常叫做功能分支，也可以叫做个人分支，一般命名为 **feature/XXXX**,该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。\n\n  * 生成及销毁：\n\n    每个开发者从通常会Develop分支中拉取自己的feature，且开发者可以随意的在自己的feature上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入develop那就要保证功能的完整性以及代码的稳定新，比如我在feature上做了3个需求但是由于时间关系我只做了两个，那也可以将feature合并入develop，然后剩下的那一个需求等有时间了再去feature上做完之后再合入develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入develop。合并入develop尽量上删除远端的feature分支，本地的feature可以视情况而取舍。\n\n  * 命名：\n\n    feature通常是从develope上拉取 所有通常用 **dev_功能描述_英文名** 来命名。比如 **feature/dev_refresh_molierzhang**\n\n  * 流程：\n\n  ![](https://ws3.sinaimg.cn/large/006tNc79gy1ftk7br1fvqj307e0jugln.jpg)\n\n#### Release:\n  * 描述：\n\n    Release分支通常叫做发布分支，也可以叫做测试-发布分支，一般命名为 **Release/1.2.3**（后面是版本号）,该分支是为测试-发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。**注意：该分支上的代码一定是可编译可运行的，允许包含小BUG**\n\n  * 生成及销毁：\n\n    当develop分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于develop拉取release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了release分支之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改BUG，进行提交、回滚等操作，但是与feature不同的是release分支是被多人操作的，不像feature，所以一定要小心避免冲突。当现在QA测试没有问题，便从release上发布上线，且经过一段时间的验证没有问题后合入master，并且删除release分支，其实根据release分支的特性我们可以使用Git Hook触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。\n  * 命名：\n\n    release/1.2.3 后面跟对应的版本号\n\n  * 流程：\n\n    同feature\n\n#### Hotfix:\n  * 描述：\n\n    Hotfix叫热修复分支，除了是计划外创建的以外，hotfix分支与release分支十分相似，当已经发布的版本（Master上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的tag版本拉取hotfix分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。\n\n  * 生成及销毁：\n\n    由Master上拉取，进行修复，负责修改BUG的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人(通常为teamleader)**合并入Master分支，且同时也要合并入Develop分支**\n  * 命名：\n\n    Hotfix/1.2.3 后面跟对应的版本号\n\n  * 流程：\n\n    ![](https://ws2.sinaimg.cn/large/006tNc79gy1ftk81yr4iej308j0bqwf3.jpg)\n\n## 总结\nGit Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。\n\n所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。\n\n## 效率工具\n 推荐 [sourceTree](https://www.sourcetreeapp.com/) 和 [gitkarken](https://www.gitkraken.com/)(用免费版即可，不用充钱) 前者对gitsubmodel的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目30G+ 会有卡死情况出现，后者界面炫酷一些 iOS的话Xcdoe自带git 也可以试试。\n","source":"_posts/2018-08-22-GitFlow.md","raw":"---\ntitle: \"GitFlow流程\"\ndate: 2018-08-23 14:20:39\ntags:\n  - git\n  - 效率工作\ncategories: iOS开发\ncomments:\n---\n# 关于gitflow\n## 概念：\nGit Flow是构建在Git之上的一个组织、管理软件开发活动的模型。Git Flow是一套使用Git进行源代码管理时的一套行为规范和，通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为“Git Flow”。\n## 原理：\ngitflow的\b核心就branch，通过在项目的不同阶段对branch的不同操作包括但不限于create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。**Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率**。用一张图来了解gitflow的流程：从右向左看 从上到下看\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1ftk5pkvn7ij30vy16cwhl.jpg)\n\n<!-- more -->\n\n## Branch：\nBranch是gitfolw的核心。主要分为两大类 **Main Branchs** 和 **Supporting branches**, 其中 **Main Branchs** 中又包含了 **Master** 和 **Develop**，而 **Supporting branches** 中包含了 **Feature **、**Release**、**Hotfix** **以及其他自定义分支**，下面逐一讲解：\n\n#### Master:\n* 描述：\n\n  master分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master分支上的代码要被更新，同时，每一次更新，都需要在master上打上对应的版本号(tag)。\n\n* 生成及销毁：\n\n  任何人不允许在master上进行代码的直接提交，只接受合入，Master上的代码必须是要从经过多轮测试且已经发布一段时间(根据DAU以及项目实际情况来定，个人建议K歌国际版可以定为一周)且线上已经稳定的 **release** 分支合并进去，然后在Master 上生成tag(通常就是对应的版本号)\n\n* 命名：\n\n  master\n\n#### Develop:\n* 描述：\n\n  develop分支是保存当前最新版本开发成果的分支。该分支上的代码允许有BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支(如果有夜间测试的话)所以该分支也叫做Nightly build。当develop分支上的代码已实现了软件需求说明书中所有的功能(必须经过开发自测，但是不必经过QA)且相对稳定时候，就可以基于此分支来拉出新的release分支交付QA进行测试。\n\n* 生成及销毁：\n\n  Develop分支是由一个人(通常是Team Leader)从Master中拉出，任何人不得在Develop上进行代码提交，只接受合入。Develop上所有代码一定都是由 **Supporting branches** 中的Branch合并进来，且合入Develop的分支必须保证功能完整，可以独立运行，可允许包含一些BUG(但是最好经过自测，不要有太大或者太明显的BUG，比如一启动就crash之类的)。\n\n* 命名：\n\n    develop\n\n* 流程：\n\n ![](https://ws4.sinaimg.cn/large/006tNc79gy1ftk7aszas4j30eu0mc74p.jpg)    \n\n#### Feature:\n  * 描述：\n\n    Feature分支通常叫做功能分支，也可以叫做个人分支，一般命名为 **feature/XXXX**,该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。\n\n  * 生成及销毁：\n\n    每个开发者从通常会Develop分支中拉取自己的feature，且开发者可以随意的在自己的feature上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入develop那就要保证功能的完整性以及代码的稳定新，比如我在feature上做了3个需求但是由于时间关系我只做了两个，那也可以将feature合并入develop，然后剩下的那一个需求等有时间了再去feature上做完之后再合入develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入develop。合并入develop尽量上删除远端的feature分支，本地的feature可以视情况而取舍。\n\n  * 命名：\n\n    feature通常是从develope上拉取 所有通常用 **dev_功能描述_英文名** 来命名。比如 **feature/dev_refresh_molierzhang**\n\n  * 流程：\n\n  ![](https://ws3.sinaimg.cn/large/006tNc79gy1ftk7br1fvqj307e0jugln.jpg)\n\n#### Release:\n  * 描述：\n\n    Release分支通常叫做发布分支，也可以叫做测试-发布分支，一般命名为 **Release/1.2.3**（后面是版本号）,该分支是为测试-发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。**注意：该分支上的代码一定是可编译可运行的，允许包含小BUG**\n\n  * 生成及销毁：\n\n    当develop分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于develop拉取release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了release分支之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改BUG，进行提交、回滚等操作，但是与feature不同的是release分支是被多人操作的，不像feature，所以一定要小心避免冲突。当现在QA测试没有问题，便从release上发布上线，且经过一段时间的验证没有问题后合入master，并且删除release分支，其实根据release分支的特性我们可以使用Git Hook触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。\n  * 命名：\n\n    release/1.2.3 后面跟对应的版本号\n\n  * 流程：\n\n    同feature\n\n#### Hotfix:\n  * 描述：\n\n    Hotfix叫热修复分支，除了是计划外创建的以外，hotfix分支与release分支十分相似，当已经发布的版本（Master上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的tag版本拉取hotfix分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。\n\n  * 生成及销毁：\n\n    由Master上拉取，进行修复，负责修改BUG的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人(通常为teamleader)**合并入Master分支，且同时也要合并入Develop分支**\n  * 命名：\n\n    Hotfix/1.2.3 后面跟对应的版本号\n\n  * 流程：\n\n    ![](https://ws2.sinaimg.cn/large/006tNc79gy1ftk81yr4iej308j0bqwf3.jpg)\n\n## 总结\nGit Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。\n\n所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。\n\n## 效率工具\n 推荐 [sourceTree](https://www.sourcetreeapp.com/) 和 [gitkarken](https://www.gitkraken.com/)(用免费版即可，不用充钱) 前者对gitsubmodel的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目30G+ 会有卡死情况出现，后者界面炫酷一些 iOS的话Xcdoe自带git 也可以试试。\n","slug":"GitFlow","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lw0020a04wwb2yltar","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"关于gitflow\"><a href=\"#关于gitflow\" class=\"headerlink\" title=\"关于gitflow\"></a>关于gitflow</h1><h2 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h2><p>Git Flow是构建在Git之上的一个组织、管理软件开发活动的模型。Git Flow是一套使用Git进行源代码管理时的一套行为规范和，通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为“Git Flow”。</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>gitflow的\b核心就branch，通过在项目的不同阶段对branch的不同操作包括但不限于create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。<strong>Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率</strong>。用一张图来了解gitflow的流程：从右向左看 从上到下看</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ftk5pkvn7ij30vy16cwhl.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Branch：\"><a href=\"#Branch：\" class=\"headerlink\" title=\"Branch：\"></a>Branch：</h2><p>Branch是gitfolw的核心。主要分为两大类 <strong>Main Branchs</strong> 和 <strong>Supporting branches</strong>, 其中 <strong>Main Branchs</strong> 中又包含了 <strong>Master</strong> 和 <strong>Develop</strong>，而 <strong>Supporting branches</strong> 中包含了 <strong>Feature </strong>、<strong>Release</strong>、<strong>Hotfix</strong> <strong>以及其他自定义分支</strong>，下面逐一讲解：</p>\n<h4 id=\"Master\"><a href=\"#Master\" class=\"headerlink\" title=\"Master:\"></a>Master:</h4><ul>\n<li><p>描述：</p>\n<p>master分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master分支上的代码要被更新，同时，每一次更新，都需要在master上打上对应的版本号(tag)。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>任何人不允许在master上进行代码的直接提交，只接受合入，Master上的代码必须是要从经过多轮测试且已经发布一段时间(根据DAU以及项目实际情况来定，个人建议K歌国际版可以定为一周)且线上已经稳定的 <strong>release</strong> 分支合并进去，然后在Master 上生成tag(通常就是对应的版本号)</p>\n</li>\n<li><p>命名：</p>\n<p>master</p>\n</li>\n</ul>\n<h4 id=\"Develop\"><a href=\"#Develop\" class=\"headerlink\" title=\"Develop:\"></a>Develop:</h4><ul>\n<li><p>描述：</p>\n<p>develop分支是保存当前最新版本开发成果的分支。该分支上的代码允许有BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支(如果有夜间测试的话)所以该分支也叫做Nightly build。当develop分支上的代码已实现了软件需求说明书中所有的功能(必须经过开发自测，但是不必经过QA)且相对稳定时候，就可以基于此分支来拉出新的release分支交付QA进行测试。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>Develop分支是由一个人(通常是Team Leader)从Master中拉出，任何人不得在Develop上进行代码提交，只接受合入。Develop上所有代码一定都是由 <strong>Supporting branches</strong> 中的Branch合并进来，且合入Develop的分支必须保证功能完整，可以独立运行，可允许包含一些BUG(但是最好经过自测，不要有太大或者太明显的BUG，比如一启动就crash之类的)。</p>\n</li>\n<li><p>命名：</p>\n<p>  develop</p>\n</li>\n<li><p>流程：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ftk7aszas4j30eu0mc74p.jpg\" alt=\"\">    </p>\n</li>\n</ul>\n<h4 id=\"Feature\"><a href=\"#Feature\" class=\"headerlink\" title=\"Feature:\"></a>Feature:</h4><ul>\n<li><p>描述：</p>\n<p>Feature分支通常叫做功能分支，也可以叫做个人分支，一般命名为 <strong>feature/XXXX</strong>,该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>每个开发者从通常会Develop分支中拉取自己的feature，且开发者可以随意的在自己的feature上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入develop那就要保证功能的完整性以及代码的稳定新，比如我在feature上做了3个需求但是由于时间关系我只做了两个，那也可以将feature合并入develop，然后剩下的那一个需求等有时间了再去feature上做完之后再合入develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入develop。合并入develop尽量上删除远端的feature分支，本地的feature可以视情况而取舍。</p>\n</li>\n<li><p>命名：</p>\n<p>feature通常是从develope上拉取 所有通常用 <strong>dev<em>功能描述</em>英文名</strong> 来命名。比如 <strong>feature/dev_refresh_molierzhang</strong></p>\n</li>\n<li><p>流程：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1ftk7br1fvqj307e0jugln.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"Release\"><a href=\"#Release\" class=\"headerlink\" title=\"Release:\"></a>Release:</h4><ul>\n<li><p>描述：</p>\n<p>Release分支通常叫做发布分支，也可以叫做测试-发布分支，一般命名为 <strong>Release/1.2.3</strong>（后面是版本号）,该分支是为测试-发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。<strong>注意：该分支上的代码一定是可编译可运行的，允许包含小BUG</strong></p>\n</li>\n<li><p>生成及销毁：</p>\n<p>当develop分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于develop拉取release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了release分支之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改BUG，进行提交、回滚等操作，但是与feature不同的是release分支是被多人操作的，不像feature，所以一定要小心避免冲突。当现在QA测试没有问题，便从release上发布上线，且经过一段时间的验证没有问题后合入master，并且删除release分支，其实根据release分支的特性我们可以使用Git Hook触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。</p>\n</li>\n<li><p>命名：</p>\n<p>release/1.2.3 后面跟对应的版本号</p>\n</li>\n<li><p>流程：</p>\n<p>同feature</p>\n</li>\n</ul>\n<h4 id=\"Hotfix\"><a href=\"#Hotfix\" class=\"headerlink\" title=\"Hotfix:\"></a>Hotfix:</h4><ul>\n<li><p>描述：</p>\n<p>Hotfix叫热修复分支，除了是计划外创建的以外，hotfix分支与release分支十分相似，当已经发布的版本（Master上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的tag版本拉取hotfix分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>由Master上拉取，进行修复，负责修改BUG的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人(通常为teamleader)<strong>合并入Master分支，且同时也要合并入Develop分支</strong></p>\n</li>\n<li><p>命名：</p>\n<p>Hotfix/1.2.3 后面跟对应的版本号</p>\n</li>\n<li><p>流程：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1ftk81yr4iej308j0bqwf3.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p>\n<p>所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。</p>\n<h2 id=\"效率工具\"><a href=\"#效率工具\" class=\"headerlink\" title=\"效率工具\"></a>效率工具</h2><p> 推荐 <a href=\"https://www.sourcetreeapp.com/\" target=\"_blank\" rel=\"noopener\">sourceTree</a> 和 <a href=\"https://www.gitkraken.com/\" target=\"_blank\" rel=\"noopener\">gitkarken</a>(用免费版即可，不用充钱) 前者对gitsubmodel的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目30G+ 会有卡死情况出现，后者界面炫酷一些 iOS的话Xcdoe自带git 也可以试试。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"关于gitflow\"><a href=\"#关于gitflow\" class=\"headerlink\" title=\"关于gitflow\"></a>关于gitflow</h1><h2 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h2><p>Git Flow是构建在Git之上的一个组织、管理软件开发活动的模型。Git Flow是一套使用Git进行源代码管理时的一套行为规范和，通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为“Git Flow”。</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>gitflow的\b核心就branch，通过在项目的不同阶段对branch的不同操作包括但不限于create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。<strong>Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率</strong>。用一张图来了解gitflow的流程：从右向左看 从上到下看</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ftk5pkvn7ij30vy16cwhl.jpg\" alt=\"\"></p>","more":"<h2 id=\"Branch：\"><a href=\"#Branch：\" class=\"headerlink\" title=\"Branch：\"></a>Branch：</h2><p>Branch是gitfolw的核心。主要分为两大类 <strong>Main Branchs</strong> 和 <strong>Supporting branches</strong>, 其中 <strong>Main Branchs</strong> 中又包含了 <strong>Master</strong> 和 <strong>Develop</strong>，而 <strong>Supporting branches</strong> 中包含了 <strong>Feature </strong>、<strong>Release</strong>、<strong>Hotfix</strong> <strong>以及其他自定义分支</strong>，下面逐一讲解：</p>\n<h4 id=\"Master\"><a href=\"#Master\" class=\"headerlink\" title=\"Master:\"></a>Master:</h4><ul>\n<li><p>描述：</p>\n<p>master分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master分支上的代码要被更新，同时，每一次更新，都需要在master上打上对应的版本号(tag)。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>任何人不允许在master上进行代码的直接提交，只接受合入，Master上的代码必须是要从经过多轮测试且已经发布一段时间(根据DAU以及项目实际情况来定，个人建议K歌国际版可以定为一周)且线上已经稳定的 <strong>release</strong> 分支合并进去，然后在Master 上生成tag(通常就是对应的版本号)</p>\n</li>\n<li><p>命名：</p>\n<p>master</p>\n</li>\n</ul>\n<h4 id=\"Develop\"><a href=\"#Develop\" class=\"headerlink\" title=\"Develop:\"></a>Develop:</h4><ul>\n<li><p>描述：</p>\n<p>develop分支是保存当前最新版本开发成果的分支。该分支上的代码允许有BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支(如果有夜间测试的话)所以该分支也叫做Nightly build。当develop分支上的代码已实现了软件需求说明书中所有的功能(必须经过开发自测，但是不必经过QA)且相对稳定时候，就可以基于此分支来拉出新的release分支交付QA进行测试。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>Develop分支是由一个人(通常是Team Leader)从Master中拉出，任何人不得在Develop上进行代码提交，只接受合入。Develop上所有代码一定都是由 <strong>Supporting branches</strong> 中的Branch合并进来，且合入Develop的分支必须保证功能完整，可以独立运行，可允许包含一些BUG(但是最好经过自测，不要有太大或者太明显的BUG，比如一启动就crash之类的)。</p>\n</li>\n<li><p>命名：</p>\n<p>  develop</p>\n</li>\n<li><p>流程：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1ftk7aszas4j30eu0mc74p.jpg\" alt=\"\">    </p>\n</li>\n</ul>\n<h4 id=\"Feature\"><a href=\"#Feature\" class=\"headerlink\" title=\"Feature:\"></a>Feature:</h4><ul>\n<li><p>描述：</p>\n<p>Feature分支通常叫做功能分支，也可以叫做个人分支，一般命名为 <strong>feature/XXXX</strong>,该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>每个开发者从通常会Develop分支中拉取自己的feature，且开发者可以随意的在自己的feature上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入develop那就要保证功能的完整性以及代码的稳定新，比如我在feature上做了3个需求但是由于时间关系我只做了两个，那也可以将feature合并入develop，然后剩下的那一个需求等有时间了再去feature上做完之后再合入develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入develop。合并入develop尽量上删除远端的feature分支，本地的feature可以视情况而取舍。</p>\n</li>\n<li><p>命名：</p>\n<p>feature通常是从develope上拉取 所有通常用 <strong>dev<em>功能描述</em>英文名</strong> 来命名。比如 <strong>feature/dev_refresh_molierzhang</strong></p>\n</li>\n<li><p>流程：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1ftk7br1fvqj307e0jugln.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"Release\"><a href=\"#Release\" class=\"headerlink\" title=\"Release:\"></a>Release:</h4><ul>\n<li><p>描述：</p>\n<p>Release分支通常叫做发布分支，也可以叫做测试-发布分支，一般命名为 <strong>Release/1.2.3</strong>（后面是版本号）,该分支是为测试-发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。<strong>注意：该分支上的代码一定是可编译可运行的，允许包含小BUG</strong></p>\n</li>\n<li><p>生成及销毁：</p>\n<p>当develop分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于develop拉取release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了release分支之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改BUG，进行提交、回滚等操作，但是与feature不同的是release分支是被多人操作的，不像feature，所以一定要小心避免冲突。当现在QA测试没有问题，便从release上发布上线，且经过一段时间的验证没有问题后合入master，并且删除release分支，其实根据release分支的特性我们可以使用Git Hook触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。</p>\n</li>\n<li><p>命名：</p>\n<p>release/1.2.3 后面跟对应的版本号</p>\n</li>\n<li><p>流程：</p>\n<p>同feature</p>\n</li>\n</ul>\n<h4 id=\"Hotfix\"><a href=\"#Hotfix\" class=\"headerlink\" title=\"Hotfix:\"></a>Hotfix:</h4><ul>\n<li><p>描述：</p>\n<p>Hotfix叫热修复分支，除了是计划外创建的以外，hotfix分支与release分支十分相似，当已经发布的版本（Master上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的tag版本拉取hotfix分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。</p>\n</li>\n<li><p>生成及销毁：</p>\n<p>由Master上拉取，进行修复，负责修改BUG的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人(通常为teamleader)<strong>合并入Master分支，且同时也要合并入Develop分支</strong></p>\n</li>\n<li><p>命名：</p>\n<p>Hotfix/1.2.3 后面跟对应的版本号</p>\n</li>\n<li><p>流程：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1ftk81yr4iej308j0bqwf3.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p>\n<p>所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。</p>\n<h2 id=\"效率工具\"><a href=\"#效率工具\" class=\"headerlink\" title=\"效率工具\"></a>效率工具</h2><p> 推荐 <a href=\"https://www.sourcetreeapp.com/\" target=\"_blank\" rel=\"noopener\">sourceTree</a> 和 <a href=\"https://www.gitkraken.com/\" target=\"_blank\" rel=\"noopener\">gitkarken</a>(用免费版即可，不用充钱) 前者对gitsubmodel的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目30G+ 会有卡死情况出现，后者界面炫酷一些 iOS的话Xcdoe自带git 也可以试试。</p>"},{"title":"关于实现唱吧清唱功能的理解","date":"2018-06-19T06:44:56.000Z","comments":1,"_content":"## 简介\n\n#### AVFoundation\n\n在iOS上多媒体的处理主要依赖的是AVFoundation框架，而AVFoundation是基于CoreAudio、CoreVideo、CoreMedia、CoreAnimation之上高层框架，在AVFoundation框架之上苹果还提供给我们更高层一些处理媒体数据的框架。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fsgu5859czj30ol0et75h.jpg)\n<!-- more -->\n\n如AVKit、iOS的UIKit、OS的AppKit。AVFoundation提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的Kit一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是AVFoundation上层加下层的AVAudioEngine实现。\n\n#### AVAudioEngine\n\nAVAudioEngine是Objective-C的音频API接口，具有低延迟(low-latency)和实时(real-time)的音频功能，并且具有如下特点：\n\n* 读写所有Core Audio支持的格式音频文件\n\n* 播放和录音使用 (files) 和音频缓冲区 (buffers)\n\n* 动态配置音频处理模块 (audio processing blocks)\n\n* 可以进行音频挖掘处理 (tap processing)\n\n* 可以进行立体声音频信号混合和3d效果的混合\n\n* 音乐设备数字接口MIDI 回放和控制，通过乐器的采样器\n\nAVAudioEngine的工作原理可以简单的分为三个部分:\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fsgusaq6ttj316208i41t.jpg)\n\n从图中可以看出AVAudioEngine的每一步操作都是一个音频操作节点(Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和GPUImage的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的Mixer其实是包含若干个这样的音效节点\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fsgvxmt21cj310c0dpq4l.jpg)\n\n\n## 原理\n\n清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作(添加配乐完整K歌在下期会讲到)，但是有一个问题就是耳返，也叫返送：\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fsgv4t4pd6j30n602ujsg.jpg)\n\n这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好(因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。\n\n使用AVAudioEngine来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整\n\n## 实现\n\n###### 创建音频文件用来接收待录制的声音：\n\n```\n//创建音频文件。\n   NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];\n   NSString * filePath = [path stringByAppendingPathComponent:@\"123.caf\"];\n   NSURL * url = [NSURL fileURLWithPath:filePath];\n```\n\n###### 创建AVAudioEngine，并打通输入和输出节点：\n* 创建AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果\n\n  ```\n  @interface ViewController (){\n\n  @property (nonatomic, strong) AVAudioEngine * engine;\n  @property (nonatomic, strong) AVAudioMixerNode * mixer;\n  @end\n\n  ```\n\n  ```\n  self.engine = [[AVAudioEngine alloc] init];\n  self.mixer = [[AVAudioMixerNode alloc] init];\n  ```\n\n* 打通输入和输出节点：\n\n  ```\n  [_engine connect:_engine.inputNode to:_engine.outputNode format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];\n\n  ```\n  所使用的是如下方法。\n  ```\n  /*!\t@method connect:to:format:\n  \t@abstract\n  \t\tEstablish a connection between two nodes\n  \t@discussion\n  \t\tThis calls connect:to:fromBus:toBus:format: using bus 0 on the source node,\n  \t\tand bus 0 on the destination node, except in the case of a destination which is a mixer,\n  \t\tin which case the destination is the mixer's nextAvailableInputBus.\n  */\n  - (void)connect:(AVAudioNode *)node1 to:(AVAudioNode *)node2 format:(AVAudioFormat * __nullable)format;\n  ```\n\n* 开启AVAudioEngine:\n\n  该方法可能会开启失败，需要开发者自定去处理\n\n  ```\n  [_engine startAndReturnError:nil];\n\n  ```\n\n  以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。\n\n* 音效：\n\n  正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到AVAudioEngine中的AVAudioUnitEffect类。\n\n  ![](https://ws2.sinaimg.cn/large/006tNc79gy1fsgxpydeq8j30hw0cwq32.jpg)\n\n  * 1.AVAudioUnitReverb:混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为\n  ```\n  typedef NS_ENUM(NSInteger, AVAudioUnitReverbPreset) {\n    AVAudioUnitReverbPresetSmallRoom       = 0,\n    AVAudioUnitReverbPresetMediumRoom      = 1,\n    AVAudioUnitReverbPresetLargeRoom       = 2,\n    AVAudioUnitReverbPresetMediumHall      = 3,\n    AVAudioUnitReverbPresetLargeHall       = 4,\n    AVAudioUnitReverbPresetPlate           = 5,\n    AVAudioUnitReverbPresetMediumChamber   = 6,\n    AVAudioUnitReverbPresetLargeChamber    = 7,\n    AVAudioUnitReverbPresetCathedral       = 8,\n    AVAudioUnitReverbPresetLargeRoom2      = 9,\n    AVAudioUnitReverbPresetMediumHall2     = 10,\n    AVAudioUnitReverbPresetMediumHall3     = 11,\n    AVAudioUnitReverbPresetLargeHall2      = 12\n    } NS_ENUM_AVAILABLE(10_10, 8_0);\n  ```\n  从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。\n\n    该类别可以自定义的属性是wetDryMix，就是可以让我们的声音更空灵。\n\n    ```\n      /*! @property wetDryMix\n        @abstract\n        Blend of the wet and dry signals\n        Range:      0 (all dry) -> 100 (all wet)\n        Unit:       Percent\n      */\n    @property (nonatomic) float wetDryMix;\n    ```\n\n    可以通过如下方式创建AVAudioUnitReverb\n    ```\n    AVAudioUnitReverb * reverd = [[AVAudioUnitReverb alloc] init];\n    reverd.wetDryMix = 100;\n    [reverd loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];\n    ```\n\n  * 2.AVAudioUnitEQ:均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节EQ的20-150HZ的频段，如果你想让你的声音更加明亮，那可以调节500-1KHZ的频段,这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于photoshop和美图秀秀的区别。\n\n    ```\n    typedef NS_ENUM(NSInteger, AVAudioUnitEQFilterType) {\n      AVAudioUnitEQFilterTypeParametric        = 0,\n      AVAudioUnitEQFilterTypeLowPass           = 1,\n      AVAudioUnitEQFilterTypeHighPass          = 2,\n      AVAudioUnitEQFilterTypeResonantLowPass   = 3,\n      AVAudioUnitEQFilterTypeResonantHighPass  = 4,\n      AVAudioUnitEQFilterTypeBandPass          = 5,\n      AVAudioUnitEQFilterTypeBandStop          = 6,\n      AVAudioUnitEQFilterTypeLowShelf          = 7,\n      AVAudioUnitEQFilterTypeHighShelf         = 8,\n      AVAudioUnitEQFilterTypeResonantLowShelf  = 9,\n      AVAudioUnitEQFilterTypeResonantHighShelf = 10,\n      } NS_ENUM_AVAILABLE(10_10, 8_0);\n    ```\n\n    上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器\n  不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调，\n\n    可以通过如下方式使用,然后更改这个节点一些属性值。\n    ```\n    AVAudioUnitEQ * eq = [[AVAudioUnitEQ alloc] initWithNumberOfBands:1];\n    AVAudioUnitEQFilterParameters * filter = eq.bands.firstObject;\n    filter.filterType = AVAudioUnitEQFilterTypeResonantHighShelf;\n    filter.bandwidth = 10;\n    filter.gain = 20;\n    ```\n\n  * 3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。\n\n    ```\n    typedef NS_ENUM(NSInteger, AVAudioUnitDistortionPreset) {\n      AVAudioUnitDistortionPresetDrumsBitBrush           = 0,\n      AVAudioUnitDistortionPresetDrumsBufferBeats        = 1,\n      AVAudioUnitDistortionPresetDrumsLoFi               = 2,\n      AVAudioUnitDistortionPresetMultiBrokenSpeaker      = 3,\n      AVAudioUnitDistortionPresetMultiCellphoneConcert   = 4,\n      AVAudioUnitDistortionPresetMultiDecimated1         = 5,\n      AVAudioUnitDistortionPresetMultiDecimated2         = 6,\n      AVAudioUnitDistortionPresetMultiDecimated3         = 7,\n      AVAudioUnitDistortionPresetMultiDecimated4         = 8,\n      AVAudioUnitDistortionPresetMultiDistortedFunk      = 9,\n      AVAudioUnitDistortionPresetMultiDistortedCubed     = 10,\n      AVAudioUnitDistortionPresetMultiDistortedSquared   = 11,\n      AVAudioUnitDistortionPresetMultiEcho1              = 12,\n      AVAudioUnitDistortionPresetMultiEcho2              = 13,\n      AVAudioUnitDistortionPresetMultiEchoTight1         = 14,\n      AVAudioUnitDistortionPresetMultiEchoTight2         = 15,\n      AVAudioUnitDistortionPresetMultiEverythingIsBroken = 16,\n      AVAudioUnitDistortionPresetSpeechAlienChatter      = 17,\n      AVAudioUnitDistortionPresetSpeechCosmicInterference = 18,\n      AVAudioUnitDistortionPresetSpeechGoldenPi          = 19,\n      AVAudioUnitDistortionPresetSpeechRadioTower        = 20,\n      AVAudioUnitDistortionPresetSpeechWaves             = 21\n  } NS_ENUM_AVAILABLE(10_10, 8_0);\n    ```\n    其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试\n\n    使用方式同之前的效果一样\n\n    ```\n    AVAudioUnitDistortion * dist = [[AVAudioUnitDistortion alloc] init];\n    [dist loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush];\n    dist.preGain = 4;\n    dist.wetDryMix = 100;\n    ```\n\n  * 4.AVAudioUnitDelay:延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。\n\n\n* 添加音效：\n  主要流程就是链式关系\n\n  **input(Mic或者音频文件) ->效果器->output**\n\n  如果是多个音效\n\n  **input(Mic或者音频文件) ->效果器1->效果器2->output**\n\n  我们以AVAudioUnitReverb效果为例\n\n  ```\n  AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];\n  [reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];\n  reverb.wetDryMix = 100;\n  //把混响附着到音频引擎\n  [_engine attachNode:reverb];\n  //依次链接输入-> 混响 -> 输出\n  [_engine connect:_engine.inputNode to:reverb format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];\n  [_engine connect:reverb to:_engine.outputNode format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];\n  //启动引擎\n  [_engine startAndReturnError:nil];\n\n  ```\n  同理添加多个音效则需要严格按照 **input(Mic或者音频文件) ->效果器1->效果器2->output** 顺序来添加\n\n  综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。\n\n\n###### 声音混合、写入本地：\n我们需要把我们清唱的歌曲录制到本地，正常的录制时使用AVAudioRecorder来进行录制的，像这样\n\n```\nAVAudioSession * session = [AVAudioSession sharedInstance];\n    [session setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];\n    [session setActive:YES error:nil];\n\n\n    NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];\n    self.filePath = [path stringByAppendingPathComponent:@\"SoWeak\"];\n    self.recordFileUrl = [NSURL fileURLWithPath:self.filePath];\n\n    //设置参数\n    NSDictionary *recordSetting = [[NSDictionary alloc] initWithObjectsAndKeys:\n                                   //采样率  8000/11025/22050/44100/96000（影响音频的质量）\n                                   [NSNumber numberWithFloat: 8000.0],AVSampleRateKey,\n                                   // 音频格式\n                                   [NSNumber numberWithInt: kAudioFormatLinearPCM],AVFormatIDKey,\n                                   //采样位数  8、16、24、32 默认为16\n                                   [NSNumber numberWithInt:16],AVLinearPCMBitDepthKey,\n                                   // 音频通道数 1 或 2\n                                   [NSNumber numberWithInt: 2], AVNumberOfChannelsKey,\n                                   //录音质量\n                                   [NSNumber numberWithInt:AVAudioQualityHigh],AVEncoderAudioQualityKey,\n                                   nil];\n    self.recorder = [[AVAudioRecorder alloc] initWithURL:self.recordFileUrl settings:recordSetting error:nil];\n\n    if (self.recorder) {\n        _recorder.meteringEnabled = YES;\n        [_recorder prepareToRecord];\n        [_recorder record];\n    }\n```\n\n但是很明显这样录制声音需要开启session 而声音的session是一个单利，如果这样开启了那么我们后面就不能用AVAudioEngine来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine在开启引擎之后一定会有一个delegate或者是block回调出采集到的数据的。于是我们找到了AudioNode中的这个方法：\n```\n- (void)installTapOnBus:(AVAudioNodeBus)bus bufferSize:(AVAudioFrameCount)bufferSize format:(AVAudioFormat * __nullable)format block:(AVAudioNodeTapBlock)tapBlock;\n```\n其中的block的buffer 便是我们采集到的数据。\n\n```\n/*!\t@typedef AVAudioNodeTapBlock\n\t@abstract A block that receives copies of the output of an AVAudioNode.\n\t@param buffer\n\t\ta buffer of audio captured from the output of an AVAudioNode\n\t@param when\n\t\tthe time at which the buffer was captured\n\t@discussion\n\t\tCAUTION: This callback may be invoked on a thread other than the main thread.\n*/\ntypedef void (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when);\n```\n\n我们需要把buffer转成AVAudioFile然后通过AVAudioFile的write方法写入\n```\n  初始化AVAudioFile\n  AVAudioFile * audioFile = [[AVAudioFile alloc] initForWriting:url settings:@{} error:nil];\n  然后在block中实现\n  [audioFile writeFromBuffer:buffer error:nil];\n\n```\n这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。\n\n其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到\n\n**AVAudioMixerNode**\n\n他是继承与AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样\n\n**input(Mic或者音频文件) ->效果器1->效果器2->Mixer->output**\n\n不过唯一需要注意的是这个mixer最好也写成属性、不然会出问题。\n\n所以一个完整的带音效的清唱录制为：\n```\n//创建音频文件。\n    NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];\n    NSString * filePath = [path stringByAppendingPathComponent:@\"123.caf\"];\n    NSURL * url = [NSURL fileURLWithPath:filePath];\n    AVAudioFile * audioFile = [[AVAudioFile alloc] initForWriting:url settings:@{} error:nil];\n    self.recordFileUrl = url;\n\n\n    AVAudioUnitReverb * reverd = [[AVAudioUnitReverb alloc] init];\n    reverd.wetDryMix = 100;\n    [reverd loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];\n    [self.engine attachNode:reverd];\n\n    [self.engine attachNode:_mixer];\n\n\n    [self.engine connect:self.engine.inputNode to:reverd format:audioFile.processingFormat];\n    [self.engine connect:reverd to:_mixer format:audioFile.processingFormat];\n    [self.engine connect:_mixer to:self.engine.outputNode format:audioFile.processingFormat];\n\n    [_mixer installTapOnBus:0 bufferSize:4096 format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops] block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {\n        [audioFile writeFromBuffer:buffer error:nil];\n        NSLog(@\"我录制到的数据是 === %@\", buffer);\n    }];\n\n    [self.engine startAndReturnError:nil];\n```\n## 总结\n\n通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是AudioUnit，AudioUnit是iOS中音频的非常底层的实现，由C语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有AudioUnit可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于AudioUnit也正在学习过程，后续会输出相应的文章。\n","source":"_posts/2018-06-19-MusicAbout.md","raw":"---\ntitle: 关于实现唱吧清唱功能的理解\ncategories: iOS开发\ndate: 2018-06-19 14:44:56\ntags:\n  - 音频\n  - 唱吧\n  - K歌\n  - AVFoundation\ncomments:\n---\n## 简介\n\n#### AVFoundation\n\n在iOS上多媒体的处理主要依赖的是AVFoundation框架，而AVFoundation是基于CoreAudio、CoreVideo、CoreMedia、CoreAnimation之上高层框架，在AVFoundation框架之上苹果还提供给我们更高层一些处理媒体数据的框架。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fsgu5859czj30ol0et75h.jpg)\n<!-- more -->\n\n如AVKit、iOS的UIKit、OS的AppKit。AVFoundation提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的Kit一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是AVFoundation上层加下层的AVAudioEngine实现。\n\n#### AVAudioEngine\n\nAVAudioEngine是Objective-C的音频API接口，具有低延迟(low-latency)和实时(real-time)的音频功能，并且具有如下特点：\n\n* 读写所有Core Audio支持的格式音频文件\n\n* 播放和录音使用 (files) 和音频缓冲区 (buffers)\n\n* 动态配置音频处理模块 (audio processing blocks)\n\n* 可以进行音频挖掘处理 (tap processing)\n\n* 可以进行立体声音频信号混合和3d效果的混合\n\n* 音乐设备数字接口MIDI 回放和控制，通过乐器的采样器\n\nAVAudioEngine的工作原理可以简单的分为三个部分:\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fsgusaq6ttj316208i41t.jpg)\n\n从图中可以看出AVAudioEngine的每一步操作都是一个音频操作节点(Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和GPUImage的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的Mixer其实是包含若干个这样的音效节点\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fsgvxmt21cj310c0dpq4l.jpg)\n\n\n## 原理\n\n清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作(添加配乐完整K歌在下期会讲到)，但是有一个问题就是耳返，也叫返送：\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fsgv4t4pd6j30n602ujsg.jpg)\n\n这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好(因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。\n\n使用AVAudioEngine来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整\n\n## 实现\n\n###### 创建音频文件用来接收待录制的声音：\n\n```\n//创建音频文件。\n   NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];\n   NSString * filePath = [path stringByAppendingPathComponent:@\"123.caf\"];\n   NSURL * url = [NSURL fileURLWithPath:filePath];\n```\n\n###### 创建AVAudioEngine，并打通输入和输出节点：\n* 创建AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果\n\n  ```\n  @interface ViewController (){\n\n  @property (nonatomic, strong) AVAudioEngine * engine;\n  @property (nonatomic, strong) AVAudioMixerNode * mixer;\n  @end\n\n  ```\n\n  ```\n  self.engine = [[AVAudioEngine alloc] init];\n  self.mixer = [[AVAudioMixerNode alloc] init];\n  ```\n\n* 打通输入和输出节点：\n\n  ```\n  [_engine connect:_engine.inputNode to:_engine.outputNode format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];\n\n  ```\n  所使用的是如下方法。\n  ```\n  /*!\t@method connect:to:format:\n  \t@abstract\n  \t\tEstablish a connection between two nodes\n  \t@discussion\n  \t\tThis calls connect:to:fromBus:toBus:format: using bus 0 on the source node,\n  \t\tand bus 0 on the destination node, except in the case of a destination which is a mixer,\n  \t\tin which case the destination is the mixer's nextAvailableInputBus.\n  */\n  - (void)connect:(AVAudioNode *)node1 to:(AVAudioNode *)node2 format:(AVAudioFormat * __nullable)format;\n  ```\n\n* 开启AVAudioEngine:\n\n  该方法可能会开启失败，需要开发者自定去处理\n\n  ```\n  [_engine startAndReturnError:nil];\n\n  ```\n\n  以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。\n\n* 音效：\n\n  正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到AVAudioEngine中的AVAudioUnitEffect类。\n\n  ![](https://ws2.sinaimg.cn/large/006tNc79gy1fsgxpydeq8j30hw0cwq32.jpg)\n\n  * 1.AVAudioUnitReverb:混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为\n  ```\n  typedef NS_ENUM(NSInteger, AVAudioUnitReverbPreset) {\n    AVAudioUnitReverbPresetSmallRoom       = 0,\n    AVAudioUnitReverbPresetMediumRoom      = 1,\n    AVAudioUnitReverbPresetLargeRoom       = 2,\n    AVAudioUnitReverbPresetMediumHall      = 3,\n    AVAudioUnitReverbPresetLargeHall       = 4,\n    AVAudioUnitReverbPresetPlate           = 5,\n    AVAudioUnitReverbPresetMediumChamber   = 6,\n    AVAudioUnitReverbPresetLargeChamber    = 7,\n    AVAudioUnitReverbPresetCathedral       = 8,\n    AVAudioUnitReverbPresetLargeRoom2      = 9,\n    AVAudioUnitReverbPresetMediumHall2     = 10,\n    AVAudioUnitReverbPresetMediumHall3     = 11,\n    AVAudioUnitReverbPresetLargeHall2      = 12\n    } NS_ENUM_AVAILABLE(10_10, 8_0);\n  ```\n  从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。\n\n    该类别可以自定义的属性是wetDryMix，就是可以让我们的声音更空灵。\n\n    ```\n      /*! @property wetDryMix\n        @abstract\n        Blend of the wet and dry signals\n        Range:      0 (all dry) -> 100 (all wet)\n        Unit:       Percent\n      */\n    @property (nonatomic) float wetDryMix;\n    ```\n\n    可以通过如下方式创建AVAudioUnitReverb\n    ```\n    AVAudioUnitReverb * reverd = [[AVAudioUnitReverb alloc] init];\n    reverd.wetDryMix = 100;\n    [reverd loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];\n    ```\n\n  * 2.AVAudioUnitEQ:均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节EQ的20-150HZ的频段，如果你想让你的声音更加明亮，那可以调节500-1KHZ的频段,这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于photoshop和美图秀秀的区别。\n\n    ```\n    typedef NS_ENUM(NSInteger, AVAudioUnitEQFilterType) {\n      AVAudioUnitEQFilterTypeParametric        = 0,\n      AVAudioUnitEQFilterTypeLowPass           = 1,\n      AVAudioUnitEQFilterTypeHighPass          = 2,\n      AVAudioUnitEQFilterTypeResonantLowPass   = 3,\n      AVAudioUnitEQFilterTypeResonantHighPass  = 4,\n      AVAudioUnitEQFilterTypeBandPass          = 5,\n      AVAudioUnitEQFilterTypeBandStop          = 6,\n      AVAudioUnitEQFilterTypeLowShelf          = 7,\n      AVAudioUnitEQFilterTypeHighShelf         = 8,\n      AVAudioUnitEQFilterTypeResonantLowShelf  = 9,\n      AVAudioUnitEQFilterTypeResonantHighShelf = 10,\n      } NS_ENUM_AVAILABLE(10_10, 8_0);\n    ```\n\n    上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器\n  不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调，\n\n    可以通过如下方式使用,然后更改这个节点一些属性值。\n    ```\n    AVAudioUnitEQ * eq = [[AVAudioUnitEQ alloc] initWithNumberOfBands:1];\n    AVAudioUnitEQFilterParameters * filter = eq.bands.firstObject;\n    filter.filterType = AVAudioUnitEQFilterTypeResonantHighShelf;\n    filter.bandwidth = 10;\n    filter.gain = 20;\n    ```\n\n  * 3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。\n\n    ```\n    typedef NS_ENUM(NSInteger, AVAudioUnitDistortionPreset) {\n      AVAudioUnitDistortionPresetDrumsBitBrush           = 0,\n      AVAudioUnitDistortionPresetDrumsBufferBeats        = 1,\n      AVAudioUnitDistortionPresetDrumsLoFi               = 2,\n      AVAudioUnitDistortionPresetMultiBrokenSpeaker      = 3,\n      AVAudioUnitDistortionPresetMultiCellphoneConcert   = 4,\n      AVAudioUnitDistortionPresetMultiDecimated1         = 5,\n      AVAudioUnitDistortionPresetMultiDecimated2         = 6,\n      AVAudioUnitDistortionPresetMultiDecimated3         = 7,\n      AVAudioUnitDistortionPresetMultiDecimated4         = 8,\n      AVAudioUnitDistortionPresetMultiDistortedFunk      = 9,\n      AVAudioUnitDistortionPresetMultiDistortedCubed     = 10,\n      AVAudioUnitDistortionPresetMultiDistortedSquared   = 11,\n      AVAudioUnitDistortionPresetMultiEcho1              = 12,\n      AVAudioUnitDistortionPresetMultiEcho2              = 13,\n      AVAudioUnitDistortionPresetMultiEchoTight1         = 14,\n      AVAudioUnitDistortionPresetMultiEchoTight2         = 15,\n      AVAudioUnitDistortionPresetMultiEverythingIsBroken = 16,\n      AVAudioUnitDistortionPresetSpeechAlienChatter      = 17,\n      AVAudioUnitDistortionPresetSpeechCosmicInterference = 18,\n      AVAudioUnitDistortionPresetSpeechGoldenPi          = 19,\n      AVAudioUnitDistortionPresetSpeechRadioTower        = 20,\n      AVAudioUnitDistortionPresetSpeechWaves             = 21\n  } NS_ENUM_AVAILABLE(10_10, 8_0);\n    ```\n    其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试\n\n    使用方式同之前的效果一样\n\n    ```\n    AVAudioUnitDistortion * dist = [[AVAudioUnitDistortion alloc] init];\n    [dist loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush];\n    dist.preGain = 4;\n    dist.wetDryMix = 100;\n    ```\n\n  * 4.AVAudioUnitDelay:延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。\n\n\n* 添加音效：\n  主要流程就是链式关系\n\n  **input(Mic或者音频文件) ->效果器->output**\n\n  如果是多个音效\n\n  **input(Mic或者音频文件) ->效果器1->效果器2->output**\n\n  我们以AVAudioUnitReverb效果为例\n\n  ```\n  AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];\n  [reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];\n  reverb.wetDryMix = 100;\n  //把混响附着到音频引擎\n  [_engine attachNode:reverb];\n  //依次链接输入-> 混响 -> 输出\n  [_engine connect:_engine.inputNode to:reverb format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];\n  [_engine connect:reverb to:_engine.outputNode format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];\n  //启动引擎\n  [_engine startAndReturnError:nil];\n\n  ```\n  同理添加多个音效则需要严格按照 **input(Mic或者音频文件) ->效果器1->效果器2->output** 顺序来添加\n\n  综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。\n\n\n###### 声音混合、写入本地：\n我们需要把我们清唱的歌曲录制到本地，正常的录制时使用AVAudioRecorder来进行录制的，像这样\n\n```\nAVAudioSession * session = [AVAudioSession sharedInstance];\n    [session setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];\n    [session setActive:YES error:nil];\n\n\n    NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];\n    self.filePath = [path stringByAppendingPathComponent:@\"SoWeak\"];\n    self.recordFileUrl = [NSURL fileURLWithPath:self.filePath];\n\n    //设置参数\n    NSDictionary *recordSetting = [[NSDictionary alloc] initWithObjectsAndKeys:\n                                   //采样率  8000/11025/22050/44100/96000（影响音频的质量）\n                                   [NSNumber numberWithFloat: 8000.0],AVSampleRateKey,\n                                   // 音频格式\n                                   [NSNumber numberWithInt: kAudioFormatLinearPCM],AVFormatIDKey,\n                                   //采样位数  8、16、24、32 默认为16\n                                   [NSNumber numberWithInt:16],AVLinearPCMBitDepthKey,\n                                   // 音频通道数 1 或 2\n                                   [NSNumber numberWithInt: 2], AVNumberOfChannelsKey,\n                                   //录音质量\n                                   [NSNumber numberWithInt:AVAudioQualityHigh],AVEncoderAudioQualityKey,\n                                   nil];\n    self.recorder = [[AVAudioRecorder alloc] initWithURL:self.recordFileUrl settings:recordSetting error:nil];\n\n    if (self.recorder) {\n        _recorder.meteringEnabled = YES;\n        [_recorder prepareToRecord];\n        [_recorder record];\n    }\n```\n\n但是很明显这样录制声音需要开启session 而声音的session是一个单利，如果这样开启了那么我们后面就不能用AVAudioEngine来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine在开启引擎之后一定会有一个delegate或者是block回调出采集到的数据的。于是我们找到了AudioNode中的这个方法：\n```\n- (void)installTapOnBus:(AVAudioNodeBus)bus bufferSize:(AVAudioFrameCount)bufferSize format:(AVAudioFormat * __nullable)format block:(AVAudioNodeTapBlock)tapBlock;\n```\n其中的block的buffer 便是我们采集到的数据。\n\n```\n/*!\t@typedef AVAudioNodeTapBlock\n\t@abstract A block that receives copies of the output of an AVAudioNode.\n\t@param buffer\n\t\ta buffer of audio captured from the output of an AVAudioNode\n\t@param when\n\t\tthe time at which the buffer was captured\n\t@discussion\n\t\tCAUTION: This callback may be invoked on a thread other than the main thread.\n*/\ntypedef void (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when);\n```\n\n我们需要把buffer转成AVAudioFile然后通过AVAudioFile的write方法写入\n```\n  初始化AVAudioFile\n  AVAudioFile * audioFile = [[AVAudioFile alloc] initForWriting:url settings:@{} error:nil];\n  然后在block中实现\n  [audioFile writeFromBuffer:buffer error:nil];\n\n```\n这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。\n\n其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到\n\n**AVAudioMixerNode**\n\n他是继承与AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样\n\n**input(Mic或者音频文件) ->效果器1->效果器2->Mixer->output**\n\n不过唯一需要注意的是这个mixer最好也写成属性、不然会出问题。\n\n所以一个完整的带音效的清唱录制为：\n```\n//创建音频文件。\n    NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];\n    NSString * filePath = [path stringByAppendingPathComponent:@\"123.caf\"];\n    NSURL * url = [NSURL fileURLWithPath:filePath];\n    AVAudioFile * audioFile = [[AVAudioFile alloc] initForWriting:url settings:@{} error:nil];\n    self.recordFileUrl = url;\n\n\n    AVAudioUnitReverb * reverd = [[AVAudioUnitReverb alloc] init];\n    reverd.wetDryMix = 100;\n    [reverd loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];\n    [self.engine attachNode:reverd];\n\n    [self.engine attachNode:_mixer];\n\n\n    [self.engine connect:self.engine.inputNode to:reverd format:audioFile.processingFormat];\n    [self.engine connect:reverd to:_mixer format:audioFile.processingFormat];\n    [self.engine connect:_mixer to:self.engine.outputNode format:audioFile.processingFormat];\n\n    [_mixer installTapOnBus:0 bufferSize:4096 format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops] block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {\n        [audioFile writeFromBuffer:buffer error:nil];\n        NSLog(@\"我录制到的数据是 === %@\", buffer);\n    }];\n\n    [self.engine startAndReturnError:nil];\n```\n## 总结\n\n通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是AudioUnit，AudioUnit是iOS中音频的非常底层的实现，由C语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有AudioUnit可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于AudioUnit也正在学习过程，后续会输出相应的文章。\n","slug":"MusicAbout","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2ly0023a04wf3ateqrz","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h4 id=\"AVFoundation\"><a href=\"#AVFoundation\" class=\"headerlink\" title=\"AVFoundation\"></a>AVFoundation</h4><p>在iOS上多媒体的处理主要依赖的是AVFoundation框架，而AVFoundation是基于CoreAudio、CoreVideo、CoreMedia、CoreAnimation之上高层框架，在AVFoundation框架之上苹果还提供给我们更高层一些处理媒体数据的框架。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fsgu5859czj30ol0et75h.jpg\" alt=\"\"><br><a id=\"more\"></a></p>\n<p>如AVKit、iOS的UIKit、OS的AppKit。AVFoundation提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的Kit一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是AVFoundation上层加下层的AVAudioEngine实现。</p>\n<h4 id=\"AVAudioEngine\"><a href=\"#AVAudioEngine\" class=\"headerlink\" title=\"AVAudioEngine\"></a>AVAudioEngine</h4><p>AVAudioEngine是Objective-C的音频API接口，具有低延迟(low-latency)和实时(real-time)的音频功能，并且具有如下特点：</p>\n<ul>\n<li><p>读写所有Core Audio支持的格式音频文件</p>\n</li>\n<li><p>播放和录音使用 (files) 和音频缓冲区 (buffers)</p>\n</li>\n<li><p>动态配置音频处理模块 (audio processing blocks)</p>\n</li>\n<li><p>可以进行音频挖掘处理 (tap processing)</p>\n</li>\n<li><p>可以进行立体声音频信号混合和3d效果的混合</p>\n</li>\n<li><p>音乐设备数字接口MIDI 回放和控制，通过乐器的采样器</p>\n</li>\n</ul>\n<p>AVAudioEngine的工作原理可以简单的分为三个部分:</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fsgusaq6ttj316208i41t.jpg\" alt=\"\"></p>\n<p>从图中可以看出AVAudioEngine的每一步操作都是一个音频操作节点(Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和GPUImage的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的Mixer其实是包含若干个这样的音效节点</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fsgvxmt21cj310c0dpq4l.jpg\" alt=\"\"></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作(添加配乐完整K歌在下期会讲到)，但是有一个问题就是耳返，也叫返送：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fsgv4t4pd6j30n602ujsg.jpg\" alt=\"\"></p>\n<p>这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好(因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。</p>\n<p>使用AVAudioEngine来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h6 id=\"创建音频文件用来接收待录制的声音：\"><a href=\"#创建音频文件用来接收待录制的声音：\" class=\"headerlink\" title=\"创建音频文件用来接收待录制的声音：\"></a>创建音频文件用来接收待录制的声音：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * filePath = [path stringByAppendingPathComponent:<span class=\"string\">@\"123.caf\"</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath];</span><br></pre></td></tr></table></figure>\n<h6 id=\"创建AVAudioEngine，并打通输入和输出节点：\"><a href=\"#创建AVAudioEngine，并打通输入和输出节点：\" class=\"headerlink\" title=\"创建AVAudioEngine，并打通输入和输出节点：\"></a>创建AVAudioEngine，并打通输入和输出节点：</h6><ul>\n<li><p>创建AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioEngine</span> * engine;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioMixerNode</span> * mixer;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight inform7\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.engine = <span class=\"comment\">[<span class=\"comment\">[AVAudioEngine alloc]</span> init]</span>;</span><br><span class=\"line\">self.mixer = <span class=\"comment\">[<span class=\"comment\">[AVAudioMixerNode alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打通输入和输出节点：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br></pre></td></tr></table></figure>\n<p>所使用的是如下方法。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*!\t@method connect:<span class=\"keyword\">to</span>:format:</span><br><span class=\"line\">\t@abstract</span><br><span class=\"line\">\t\tEstablish a connection between two nodes</span><br><span class=\"line\">\t@discussion</span><br><span class=\"line\">\t\tThis calls connect:<span class=\"keyword\">to</span>:fromBus:toBus:format: <span class=\"keyword\">using</span> bus <span class=\"number\">0</span> <span class=\"keyword\">on</span> the source node,</span><br><span class=\"line\">\t\t<span class=\"keyword\">and</span> bus <span class=\"number\">0</span> <span class=\"keyword\">on</span> the destination node, except <span class=\"keyword\">in</span> the <span class=\"keyword\">case</span> <span class=\"keyword\">of</span> a destination which <span class=\"keyword\">is</span> a mixer,</span><br><span class=\"line\">\t\t<span class=\"keyword\">in</span> which <span class=\"keyword\">case</span> the destination <span class=\"keyword\">is</span> the mixer<span class=\"comment\">'s nextAvailableInputBus.</span></span><br><span class=\"line\">*/</span><br><span class=\"line\">- (void)connect:(AVAudioNode *)node1 <span class=\"keyword\">to</span>:(AVAudioNode *)node2 format:(AVAudioFormat * __nullable)format;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启AVAudioEngine:</p>\n<p>该方法可能会开启失败，需要开发者自定去处理</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[_engine startAndReturnError:nil]</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。</p>\n</li>\n<li><p>音效：</p>\n<p>正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到AVAudioEngine中的AVAudioUnitEffect类。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fsgxpydeq8j30hw0cwq32.jpg\" alt=\"\"></p>\n<ul>\n<li>1.AVAudioUnitReverb:混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitReverbPreset</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetSmallRoom</span>       = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumRoom</span>      = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>       = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall</span>      = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall</span>       = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetPlate</span>           = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumChamber</span>   = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeChamber</span>    = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetCathedral</span>       = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom2</span>      = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall2</span>     = 10,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall3</span>     = 11,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall2</span>      = 12</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。</p>\n<p>  该类别可以自定义的属性是wetDryMix，就是可以让我们的声音更空灵。</p>\n  <figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">  /*! @<span class=\"keyword\">property</span><span class=\"title\"> </span>wetDryMix</span><br><span class=\"line\">    @abstract</span><br><span class=\"line\">    Blend of the wet <span class=\"keyword\">and</span> dry signals</span><br><span class=\"line\">    Range:      <span class=\"number\">0</span> (all dry) -&gt; <span class=\"number\">100</span> (all wet)</span><br><span class=\"line\">    Unit:       Percent</span><br><span class=\"line\">  */</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>(nonatomic) float wetDryMix;</span><br></pre></td></tr></table></figure>\n<p>  可以通过如下方式创建AVAudioUnitReverb</p>\n  <figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">AVAudioUnitReverb</span> * <span class=\"keyword\">reverd </span>= [[AVAudioUnitReverb alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">reverd.wetDryMix </span>= <span class=\"number\">100</span><span class=\"comment\">;</span></span><br><span class=\"line\">[<span class=\"keyword\">reverd </span>loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>2.AVAudioUnitEQ:均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节EQ的20-150HZ的频段，如果你想让你的声音更加明亮，那可以调节500-1KHZ的频段,这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于photoshop和美图秀秀的区别。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitEQFilterType</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeParametric</span>        = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowPass</span>           = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighPass</span>          = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowPass</span>   = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighPass</span>  = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandPass</span>          = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandStop</span>          = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowShelf</span>          = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighShelf</span>         = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowShelf</span>  = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighShelf</span> = 10,</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>\n<p>上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器<br>不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调，</p>\n<p>可以通过如下方式使用,然后更改这个节点一些属性值。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVAudioUnitEQ * eq = [[AVAudioUnitEQ alloc] initWithNumberOfBands:1];</span><br><span class=\"line\">AVAudioUnitEQFilterParameters *<span class=\"built_in\"> filter </span>= eq.bands.firstObject;</span><br><span class=\"line\">filter.filterType = AVAudioUnitEQFilterTypeResonantHighShelf;</span><br><span class=\"line\">filter.bandwidth = 10;</span><br><span class=\"line\">filter.gain = 20;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">  typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitDistortionPreset</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBitBrush</span>           = 0,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBufferBeats</span>        = 1,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsLoFi</span>               = 2,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiBrokenSpeaker</span>      = 3,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiCellphoneConcert</span>   = 4,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated1</span>         = 5,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated2</span>         = 6,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated3</span>         = 7,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated4</span>         = 8,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedFunk</span>      = 9,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedCubed</span>     = 10,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedSquared</span>   = 11,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho1</span>              = 12,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho2</span>              = 13,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight1</span>         = 14,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight2</span>         = 15,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEverythingIsBroken</span> = 16,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechAlienChatter</span>      = 17,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechCosmicInterference</span> = 18,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechGoldenPi</span>          = 19,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechRadioTower</span>        = 20,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechWaves</span>             = 21</span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>\n<p>其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试</p>\n<p>使用方式同之前的效果一样</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVAudioUnitDistortion * <span class=\"keyword\">dist </span>= [[AVAudioUnitDistortion alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">[<span class=\"keyword\">dist </span>loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">dist.preGain </span>= <span class=\"number\">4</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">dist.wetDryMix </span>= <span class=\"number\">100</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.AVAudioUnitDelay:延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>添加音效：<br>主要流程就是链式关系</p>\n<p><strong>input(Mic或者音频文件) -&gt;效果器-&gt;output</strong></p>\n<p>如果是多个音效</p>\n<p><strong>input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;output</strong></p>\n<p>我们以AVAudioUnitReverb效果为例</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];</span><br><span class=\"line\">[reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];</span><br><span class=\"line\">reverb.wetDryMix = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//把混响附着到音频引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> attachNode:reverb];</span><br><span class=\"line\"><span class=\"comment\">//依次链接输入-&gt; 混响 -&gt; 输出</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:reverb <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:reverb <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\"><span class=\"comment\">//启动引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> startAndReturnError:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>同理添加多个音效则需要严格按照 <strong>input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;output</strong> 顺序来添加</p>\n<p>综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。</p>\n</li>\n</ul>\n<h6 id=\"声音混合、写入本地：\"><a href=\"#声音混合、写入本地：\" class=\"headerlink\" title=\"声音混合、写入本地：\"></a>声音混合、写入本地：</h6><p>我们需要把我们清唱的歌曲录制到本地，正常的录制时使用AVAudioRecorder来进行录制的，像这样</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVAudioSession</span> * session = [<span class=\"built_in\">AVAudioSession</span> sharedInstance];</span><br><span class=\"line\">    [session setCategory:<span class=\"built_in\">AVAudioSessionCategoryPlayAndRecord</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [session setActive:<span class=\"literal\">YES</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.filePath = [path stringByAppendingPathComponent:<span class=\"string\">@\"SoWeak\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl = [<span class=\"built_in\">NSURL</span> fileURLWithPath:<span class=\"keyword\">self</span>.filePath];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *recordSetting = [[<span class=\"built_in\">NSDictionary</span> alloc] initWithObjectsAndKeys:</span><br><span class=\"line\">                                   <span class=\"comment\">//采样率  8000/11025/22050/44100/96000（影响音频的质量）</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithFloat: <span class=\"number\">8000.0</span>],<span class=\"built_in\">AVSampleRateKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频格式</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: kAudioFormatLinearPCM],<span class=\"built_in\">AVFormatIDKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//采样位数  8、16、24、32 默认为16</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">16</span>],<span class=\"built_in\">AVLinearPCMBitDepthKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频通道数 1 或 2</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: <span class=\"number\">2</span>], <span class=\"built_in\">AVNumberOfChannelsKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//录音质量</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"built_in\">AVAudioQualityHigh</span>],<span class=\"built_in\">AVEncoderAudioQualityKey</span>,</span><br><span class=\"line\">                                   <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recorder = [[<span class=\"built_in\">AVAudioRecorder</span> alloc] initWithURL:<span class=\"keyword\">self</span>.recordFileUrl settings:recordSetting error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.recorder) &#123;</span><br><span class=\"line\">        _recorder.meteringEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        [_recorder prepareToRecord];</span><br><span class=\"line\">        [_recorder record];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>但是很明显这样录制声音需要开启session 而声音的session是一个单利，如果这样开启了那么我们后面就不能用AVAudioEngine来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine在开启引擎之后一定会有一个delegate或者是block回调出采集到的数据的。于是我们找到了AudioNode中的这个方法：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)installTapOnBus:(<span class=\"built_in\">AVAudioNodeBus</span>)bus bufferSize:(<span class=\"built_in\">AVAudioFrameCount</span>)bufferSize format:(<span class=\"built_in\">AVAudioFormat</span> * __<span class=\"keyword\">nullable</span>)format block:(<span class=\"built_in\">AVAudioNodeTapBlock</span>)tapBlock;</span><br></pre></td></tr></table></figure></p>\n<p>其中的block的buffer 便是我们采集到的数据。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!\t<span class=\"doctag\">@typedef</span> AVAudioNodeTapBlock</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@abstract</span> A block that receives copies of the output of an AVAudioNode.</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">\t\ta buffer of audio captured from the output of an AVAudioNode</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> when</span></span><br><span class=\"line\"><span class=\"comment\">\t\tthe time at which the buffer was captured</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@discussion</span></span></span><br><span class=\"line\"><span class=\"comment\">\t\tCAUTION: This callback may be invoked on a thread other than the main thread.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">typedef void (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when);</span><br></pre></td></tr></table></figure>\n<p>我们需要把buffer转成AVAudioFile然后通过AVAudioFile的write方法写入<br><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">初始化AVAudioFile</span><br><span class=\"line\">AVAudioFile * audioFile = [[AVAudioFile alloc] <span class=\"string\">initForWriting:</span>url <span class=\"string\">settings:</span>@&#123;&#125; <span class=\"string\">error:</span>nil];</span><br><span class=\"line\">然后在block中实现</span><br><span class=\"line\">[audioFile <span class=\"string\">writeFromBuffer:</span>buffer <span class=\"string\">error:</span>nil];</span><br></pre></td></tr></table></figure></p>\n<p>这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。</p>\n<p>其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到</p>\n<p><strong>AVAudioMixerNode</strong></p>\n<p>他是继承与AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样</p>\n<p><strong>input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;Mixer-&gt;output</strong></p>\n<p>不过唯一需要注意的是这个mixer最好也写成属性、不然会出问题。</p>\n<p>所以一个完整的带音效的清唱录制为：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * filePath = [path stringByAppendingPathComponent:<span class=\"string\">@\"123.caf\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath];</span><br><span class=\"line\">    <span class=\"built_in\">AVAudioFile</span> * audioFile = [[<span class=\"built_in\">AVAudioFile</span> alloc] initForWriting:url settings:@&#123;&#125; error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl = url;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AVAudioUnitReverb</span> * reverd = [[<span class=\"built_in\">AVAudioUnitReverb</span> alloc] init];</span><br><span class=\"line\">    reverd.wetDryMix = <span class=\"number\">100</span>;</span><br><span class=\"line\">    [reverd loadFactoryPreset:<span class=\"built_in\">AVAudioUnitReverbPresetLargeRoom</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:reverd];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:_mixer];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:<span class=\"keyword\">self</span>.engine.inputNode to:reverd format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:reverd to:_mixer format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:_mixer to:<span class=\"keyword\">self</span>.engine.outputNode format:audioFile.processingFormat];</span><br><span class=\"line\"></span><br><span class=\"line\">    [_mixer installTapOnBus:<span class=\"number\">0</span> bufferSize:<span class=\"number\">4096</span> format:[_engine.inputNode inputFormatForBus:<span class=\"built_in\">AVAudioPlayerNodeBufferLoops</span>] block:^(<span class=\"built_in\">AVAudioPCMBuffer</span> * _Nonnull buffer, <span class=\"built_in\">AVAudioTime</span> * _Nonnull when) &#123;</span><br><span class=\"line\">        [audioFile writeFromBuffer:buffer error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"我录制到的数据是 === %@\"</span>, buffer);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine startAndReturnError:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是AudioUnit，AudioUnit是iOS中音频的非常底层的实现，由C语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有AudioUnit可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于AudioUnit也正在学习过程，后续会输出相应的文章。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h4 id=\"AVFoundation\"><a href=\"#AVFoundation\" class=\"headerlink\" title=\"AVFoundation\"></a>AVFoundation</h4><p>在iOS上多媒体的处理主要依赖的是AVFoundation框架，而AVFoundation是基于CoreAudio、CoreVideo、CoreMedia、CoreAnimation之上高层框架，在AVFoundation框架之上苹果还提供给我们更高层一些处理媒体数据的框架。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fsgu5859czj30ol0et75h.jpg\" alt=\"\"><br>","more":"</p>\n<p>如AVKit、iOS的UIKit、OS的AppKit。AVFoundation提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的Kit一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是AVFoundation上层加下层的AVAudioEngine实现。</p>\n<h4 id=\"AVAudioEngine\"><a href=\"#AVAudioEngine\" class=\"headerlink\" title=\"AVAudioEngine\"></a>AVAudioEngine</h4><p>AVAudioEngine是Objective-C的音频API接口，具有低延迟(low-latency)和实时(real-time)的音频功能，并且具有如下特点：</p>\n<ul>\n<li><p>读写所有Core Audio支持的格式音频文件</p>\n</li>\n<li><p>播放和录音使用 (files) 和音频缓冲区 (buffers)</p>\n</li>\n<li><p>动态配置音频处理模块 (audio processing blocks)</p>\n</li>\n<li><p>可以进行音频挖掘处理 (tap processing)</p>\n</li>\n<li><p>可以进行立体声音频信号混合和3d效果的混合</p>\n</li>\n<li><p>音乐设备数字接口MIDI 回放和控制，通过乐器的采样器</p>\n</li>\n</ul>\n<p>AVAudioEngine的工作原理可以简单的分为三个部分:</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fsgusaq6ttj316208i41t.jpg\" alt=\"\"></p>\n<p>从图中可以看出AVAudioEngine的每一步操作都是一个音频操作节点(Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和GPUImage的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的Mixer其实是包含若干个这样的音效节点</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fsgvxmt21cj310c0dpq4l.jpg\" alt=\"\"></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作(添加配乐完整K歌在下期会讲到)，但是有一个问题就是耳返，也叫返送：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fsgv4t4pd6j30n602ujsg.jpg\" alt=\"\"></p>\n<p>这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好(因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。</p>\n<p>使用AVAudioEngine来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h6 id=\"创建音频文件用来接收待录制的声音：\"><a href=\"#创建音频文件用来接收待录制的声音：\" class=\"headerlink\" title=\"创建音频文件用来接收待录制的声音：\"></a>创建音频文件用来接收待录制的声音：</h6><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSString</span> * filePath = [path stringByAppendingPathComponent:<span class=\"string\">@\"123.caf\"</span>];</span><br><span class=\"line\">   <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath];</span><br></pre></td></tr></table></figure>\n<h6 id=\"创建AVAudioEngine，并打通输入和输出节点：\"><a href=\"#创建AVAudioEngine，并打通输入和输出节点：\" class=\"headerlink\" title=\"创建AVAudioEngine，并打通输入和输出节点：\"></a>创建AVAudioEngine，并打通输入和输出节点：</h6><ul>\n<li><p>创建AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioEngine</span> * engine;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">AVAudioMixerNode</span> * mixer;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight inform7\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.engine = <span class=\"comment\">[<span class=\"comment\">[AVAudioEngine alloc]</span> init]</span>;</span><br><span class=\"line\">self.mixer = <span class=\"comment\">[<span class=\"comment\">[AVAudioMixerNode alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打通输入和输出节点：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br></pre></td></tr></table></figure>\n<p>所使用的是如下方法。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*!\t@method connect:<span class=\"keyword\">to</span>:format:</span><br><span class=\"line\">\t@abstract</span><br><span class=\"line\">\t\tEstablish a connection between two nodes</span><br><span class=\"line\">\t@discussion</span><br><span class=\"line\">\t\tThis calls connect:<span class=\"keyword\">to</span>:fromBus:toBus:format: <span class=\"keyword\">using</span> bus <span class=\"number\">0</span> <span class=\"keyword\">on</span> the source node,</span><br><span class=\"line\">\t\t<span class=\"keyword\">and</span> bus <span class=\"number\">0</span> <span class=\"keyword\">on</span> the destination node, except <span class=\"keyword\">in</span> the <span class=\"keyword\">case</span> <span class=\"keyword\">of</span> a destination which <span class=\"keyword\">is</span> a mixer,</span><br><span class=\"line\">\t\t<span class=\"keyword\">in</span> which <span class=\"keyword\">case</span> the destination <span class=\"keyword\">is</span> the mixer<span class=\"comment\">'s nextAvailableInputBus.</span></span><br><span class=\"line\">*/</span><br><span class=\"line\">- (void)connect:(AVAudioNode *)node1 <span class=\"keyword\">to</span>:(AVAudioNode *)node2 format:(AVAudioFormat * __nullable)format;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启AVAudioEngine:</p>\n<p>该方法可能会开启失败，需要开发者自定去处理</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[_engine startAndReturnError:nil]</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。</p>\n</li>\n<li><p>音效：</p>\n<p>正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到AVAudioEngine中的AVAudioUnitEffect类。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fsgxpydeq8j30hw0cwq32.jpg\" alt=\"\"></p>\n<ul>\n<li>1.AVAudioUnitReverb:混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitReverbPreset</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetSmallRoom</span>       = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumRoom</span>      = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom</span>       = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall</span>      = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall</span>       = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetPlate</span>           = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumChamber</span>   = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeChamber</span>    = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetCathedral</span>       = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeRoom2</span>      = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall2</span>     = 10,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetMediumHall3</span>     = 11,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitReverbPresetLargeHall2</span>      = 12</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。</p>\n<p>  该类别可以自定义的属性是wetDryMix，就是可以让我们的声音更空灵。</p>\n  <figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">  /*! @<span class=\"keyword\">property</span><span class=\"title\"> </span>wetDryMix</span><br><span class=\"line\">    @abstract</span><br><span class=\"line\">    Blend of the wet <span class=\"keyword\">and</span> dry signals</span><br><span class=\"line\">    Range:      <span class=\"number\">0</span> (all dry) -&gt; <span class=\"number\">100</span> (all wet)</span><br><span class=\"line\">    Unit:       Percent</span><br><span class=\"line\">  */</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>(nonatomic) float wetDryMix;</span><br></pre></td></tr></table></figure>\n<p>  可以通过如下方式创建AVAudioUnitReverb</p>\n  <figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">AVAudioUnitReverb</span> * <span class=\"keyword\">reverd </span>= [[AVAudioUnitReverb alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">reverd.wetDryMix </span>= <span class=\"number\">100</span><span class=\"comment\">;</span></span><br><span class=\"line\">[<span class=\"keyword\">reverd </span>loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>2.AVAudioUnitEQ:均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节EQ的20-150HZ的频段，如果你想让你的声音更加明亮，那可以调节500-1KHZ的频段,这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于photoshop和美图秀秀的区别。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitEQFilterType</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeParametric</span>        = 0,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowPass</span>           = 1,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighPass</span>          = 2,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowPass</span>   = 3,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighPass</span>  = 4,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandPass</span>          = 5,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeBandStop</span>          = 6,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeLowShelf</span>          = 7,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeHighShelf</span>         = 8,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantLowShelf</span>  = 9,</span><br><span class=\"line\">  <span class=\"type\">AVAudioUnitEQFilterTypeResonantHighShelf</span> = 10,</span><br><span class=\"line\">  &#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>\n<p>上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器<br>不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调，</p>\n<p>可以通过如下方式使用,然后更改这个节点一些属性值。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVAudioUnitEQ * eq = [[AVAudioUnitEQ alloc] initWithNumberOfBands:1];</span><br><span class=\"line\">AVAudioUnitEQFilterParameters *<span class=\"built_in\"> filter </span>= eq.bands.firstObject;</span><br><span class=\"line\">filter.filterType = AVAudioUnitEQFilterTypeResonantHighShelf;</span><br><span class=\"line\">filter.bandwidth = 10;</span><br><span class=\"line\">filter.gain = 20;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">  typedef <span class=\"type\">NS_ENUM</span>(<span class=\"type\">NSInteger</span>, <span class=\"type\">AVAudioUnitDistortionPreset</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBitBrush</span>           = 0,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsBufferBeats</span>        = 1,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetDrumsLoFi</span>               = 2,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiBrokenSpeaker</span>      = 3,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiCellphoneConcert</span>   = 4,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated1</span>         = 5,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated2</span>         = 6,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated3</span>         = 7,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDecimated4</span>         = 8,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedFunk</span>      = 9,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedCubed</span>     = 10,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiDistortedSquared</span>   = 11,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho1</span>              = 12,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEcho2</span>              = 13,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight1</span>         = 14,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEchoTight2</span>         = 15,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetMultiEverythingIsBroken</span> = 16,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechAlienChatter</span>      = 17,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechCosmicInterference</span> = 18,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechGoldenPi</span>          = 19,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechRadioTower</span>        = 20,</span><br><span class=\"line\">    <span class=\"type\">AVAudioUnitDistortionPresetSpeechWaves</span>             = 21</span><br><span class=\"line\">&#125; <span class=\"type\">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>\n<p>其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试</p>\n<p>使用方式同之前的效果一样</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVAudioUnitDistortion * <span class=\"keyword\">dist </span>= [[AVAudioUnitDistortion alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">[<span class=\"keyword\">dist </span>loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">dist.preGain </span>= <span class=\"number\">4</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">dist.wetDryMix </span>= <span class=\"number\">100</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>4.AVAudioUnitDelay:延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>添加音效：<br>主要流程就是链式关系</p>\n<p><strong>input(Mic或者音频文件) -&gt;效果器-&gt;output</strong></p>\n<p>如果是多个音效</p>\n<p><strong>input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;output</strong></p>\n<p>我们以AVAudioUnitReverb效果为例</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\">AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];</span><br><span class=\"line\">[reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];</span><br><span class=\"line\">reverb.wetDryMix = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//把混响附着到音频引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> attachNode:reverb];</span><br><span class=\"line\"><span class=\"comment\">//依次链接输入-&gt; 混响 -&gt; 输出</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:<span class=\"variable\">_engine</span>.inputNode <span class=\"keyword\">to</span>:reverb <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\">[<span class=\"variable\">_engine</span> connect:reverb <span class=\"keyword\">to</span>:<span class=\"variable\">_engine</span>.outputNode <span class=\"built_in\">format</span>:[<span class=\"variable\">_engine</span>.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];</span><br><span class=\"line\"><span class=\"comment\">//启动引擎</span></span><br><span class=\"line\">[<span class=\"variable\">_engine</span> startAndReturnError:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>同理添加多个音效则需要严格按照 <strong>input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;output</strong> 顺序来添加</p>\n<p>综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。</p>\n</li>\n</ul>\n<h6 id=\"声音混合、写入本地：\"><a href=\"#声音混合、写入本地：\" class=\"headerlink\" title=\"声音混合、写入本地：\"></a>声音混合、写入本地：</h6><p>我们需要把我们清唱的歌曲录制到本地，正常的录制时使用AVAudioRecorder来进行录制的，像这样</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">AVAudioSession</span> * session = [<span class=\"built_in\">AVAudioSession</span> sharedInstance];</span><br><span class=\"line\">    [session setCategory:<span class=\"built_in\">AVAudioSessionCategoryPlayAndRecord</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [session setActive:<span class=\"literal\">YES</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.filePath = [path stringByAppendingPathComponent:<span class=\"string\">@\"SoWeak\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl = [<span class=\"built_in\">NSURL</span> fileURLWithPath:<span class=\"keyword\">self</span>.filePath];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置参数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *recordSetting = [[<span class=\"built_in\">NSDictionary</span> alloc] initWithObjectsAndKeys:</span><br><span class=\"line\">                                   <span class=\"comment\">//采样率  8000/11025/22050/44100/96000（影响音频的质量）</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithFloat: <span class=\"number\">8000.0</span>],<span class=\"built_in\">AVSampleRateKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频格式</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: kAudioFormatLinearPCM],<span class=\"built_in\">AVFormatIDKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//采样位数  8、16、24、32 默认为16</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">16</span>],<span class=\"built_in\">AVLinearPCMBitDepthKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">// 音频通道数 1 或 2</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt: <span class=\"number\">2</span>], <span class=\"built_in\">AVNumberOfChannelsKey</span>,</span><br><span class=\"line\">                                   <span class=\"comment\">//录音质量</span></span><br><span class=\"line\">                                   [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"built_in\">AVAudioQualityHigh</span>],<span class=\"built_in\">AVEncoderAudioQualityKey</span>,</span><br><span class=\"line\">                                   <span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recorder = [[<span class=\"built_in\">AVAudioRecorder</span> alloc] initWithURL:<span class=\"keyword\">self</span>.recordFileUrl settings:recordSetting error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.recorder) &#123;</span><br><span class=\"line\">        _recorder.meteringEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        [_recorder prepareToRecord];</span><br><span class=\"line\">        [_recorder record];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>但是很明显这样录制声音需要开启session 而声音的session是一个单利，如果这样开启了那么我们后面就不能用AVAudioEngine来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine在开启引擎之后一定会有一个delegate或者是block回调出采集到的数据的。于是我们找到了AudioNode中的这个方法：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)installTapOnBus:(<span class=\"built_in\">AVAudioNodeBus</span>)bus bufferSize:(<span class=\"built_in\">AVAudioFrameCount</span>)bufferSize format:(<span class=\"built_in\">AVAudioFormat</span> * __<span class=\"keyword\">nullable</span>)format block:(<span class=\"built_in\">AVAudioNodeTapBlock</span>)tapBlock;</span><br></pre></td></tr></table></figure></p>\n<p>其中的block的buffer 便是我们采集到的数据。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!\t<span class=\"doctag\">@typedef</span> AVAudioNodeTapBlock</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@abstract</span> A block that receives copies of the output of an AVAudioNode.</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">\t\ta buffer of audio captured from the output of an AVAudioNode</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@param</span> when</span></span><br><span class=\"line\"><span class=\"comment\">\t\tthe time at which the buffer was captured</span></span><br><span class=\"line\"><span class=\"comment\">\t<span class=\"doctag\">@discussion</span></span></span><br><span class=\"line\"><span class=\"comment\">\t\tCAUTION: This callback may be invoked on a thread other than the main thread.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">typedef void (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when);</span><br></pre></td></tr></table></figure>\n<p>我们需要把buffer转成AVAudioFile然后通过AVAudioFile的write方法写入<br><figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">初始化AVAudioFile</span><br><span class=\"line\">AVAudioFile * audioFile = [[AVAudioFile alloc] <span class=\"string\">initForWriting:</span>url <span class=\"string\">settings:</span>@&#123;&#125; <span class=\"string\">error:</span>nil];</span><br><span class=\"line\">然后在block中实现</span><br><span class=\"line\">[audioFile <span class=\"string\">writeFromBuffer:</span>buffer <span class=\"string\">error:</span>nil];</span><br></pre></td></tr></table></figure></p>\n<p>这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。</p>\n<p>其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到</p>\n<p><strong>AVAudioMixerNode</strong></p>\n<p>他是继承与AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样</p>\n<p><strong>input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;Mixer-&gt;output</strong></p>\n<p>不过唯一需要注意的是这个mixer最好也写成属性、不然会出问题。</p>\n<p>所以一个完整的带音效的清唱录制为：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建音频文件。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * filePath = [path stringByAppendingPathComponent:<span class=\"string\">@\"123.caf\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> * url = [<span class=\"built_in\">NSURL</span> fileURLWithPath:filePath];</span><br><span class=\"line\">    <span class=\"built_in\">AVAudioFile</span> * audioFile = [[<span class=\"built_in\">AVAudioFile</span> alloc] initForWriting:url settings:@&#123;&#125; error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.recordFileUrl = url;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AVAudioUnitReverb</span> * reverd = [[<span class=\"built_in\">AVAudioUnitReverb</span> alloc] init];</span><br><span class=\"line\">    reverd.wetDryMix = <span class=\"number\">100</span>;</span><br><span class=\"line\">    [reverd loadFactoryPreset:<span class=\"built_in\">AVAudioUnitReverbPresetLargeRoom</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:reverd];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine attachNode:_mixer];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:<span class=\"keyword\">self</span>.engine.inputNode to:reverd format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:reverd to:_mixer format:audioFile.processingFormat];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine connect:_mixer to:<span class=\"keyword\">self</span>.engine.outputNode format:audioFile.processingFormat];</span><br><span class=\"line\"></span><br><span class=\"line\">    [_mixer installTapOnBus:<span class=\"number\">0</span> bufferSize:<span class=\"number\">4096</span> format:[_engine.inputNode inputFormatForBus:<span class=\"built_in\">AVAudioPlayerNodeBufferLoops</span>] block:^(<span class=\"built_in\">AVAudioPCMBuffer</span> * _Nonnull buffer, <span class=\"built_in\">AVAudioTime</span> * _Nonnull when) &#123;</span><br><span class=\"line\">        [audioFile writeFromBuffer:buffer error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"我录制到的数据是 === %@\"</span>, buffer);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.engine startAndReturnError:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是AudioUnit，AudioUnit是iOS中音频的非常底层的实现，由C语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有AudioUnit可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于AudioUnit也正在学习过程，后续会输出相应的文章。</p>"},{"title":"At The End Of 2018","date":"2019-02-14T03:19:59.000Z","comments":1,"_content":"## 前言\n今年的总结来的比去年稍微晚一些，本来打算像去年一样在最后一个工作日出炉的，但是因为年前事情比较多，而且再加上父母要来过年，又请了半天假回家收拾屋子，所以没有按时完成任务。总的来说今年算是我人生中比较重要的一年，不光是我自己，还有自己的妹子，甚至2018对于中国互联网也是一次历史性的转折。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1g076fg14tqj31hd0u0wi5.jpg)\n\n<!-- more -->\n\n写这篇文章之前我还看了下去年的年终总结，想看看当时立了哪些flag，完成了哪些、辜负了哪些，最终的结论是勉勉强强完成百分之五十，不过虽然一半没有完成，但是今年还发生了一些其他的事情，总的来说收获不小，相比去年有过之而无不及，人总是要进步的嘛~\n\n## 辞旧\n#### 大背景\n\n2018年是不平凡的一年，尤其是对于互联网行业，都在说2018是互联网的寒冬，2018是过去十年最难的一年，同时也是未来十年最好的一年。作为一个在深圳的互联网从业者来说确实感慨颇深，一个个熟悉的朋友“被离职”，一家家曾经耳熟能详的公司“跑路”、“优化”。再加上各大媒体为了眼球效应大肆渲染，确实搞得大家人心惶惶。不过还是有一些公司趁着这个机会疯狂找人，想弯道超车，由此可见互联网还是有无限的潜力的。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1g0780whl50j312w0np0u6.jpg)\n\n#### 职业生涯\n\n今年对我影响最大应该算是从美图离职吧，不过这个真的跟互联网寒冬没有关系，完全是个人原因。其实到现在为止，美图在我心里依然占据很重要的一部分，从2016年6月13日到2018年6月13日，在美图的整整两年中我学到新的技术，认识到新的朋友，接触到新的圈子，更重要的是美图教会了我一种精神，一种上进，一种不服输的精神，总是想学更多的东西，想认识更多的人，总是有一种饥饿感。当然这一切也离不开我那些优秀的同事们。这也印证了那句话，你的圈子决定你成为一个生么样的人。美图公司给我留下的印象依然是站在图像处理领域的最高点，每一款产品都能让人眼前一亮，同时也一直在引领着“美颜”趋势的发展。\n\n5月底的时候身边的同事陆续地走了，去了BAT或者国外发展，不管是继续求学还是继续工作，他们都有了新的目标，当时对于不服输的我来说其实影响很大，于是也去鹅厂试了下并且拿到了offer。正好当时也觉得在美图带的时间也算比较久，而且对于个人的成长也似乎到了瓶颈，当时只是做一些业务需求，正好自己也想接触一些新的东西，所以就来了鹅厂。\n\n![美图公司](https://ws2.sinaimg.cn/large/006tKfTcgy1g0akxedwthj30zk0qodno.jpg)\n\n现在想想当时的情况感觉还是挺不可思议的，鹅厂的面试流程一项以严(hen)谨(man)著称，之前看论坛上流程要几个月的大有人在，而我5月底还在纠结要不要来腾讯，而六月中旬就拿到了offer，在这里还是要感谢我的现在的导师一直持续跟、催促进面试流程，才使得有这样的效率。历史总是惊人的相似，想起我当时来深圳的时候，2016年的5月底我还在北京的出租房门前给我妈打着电话纠结是否要来深圳打拼，从北京到深圳，地理位置的巨大变化不说，包括圈子，工作，生活基本都要从头开始，但是过了不到一个月 6月13号我已经做在了深圳美图的工位上，有的时候人生就是需要这样的而果断甚至是决绝吧。来到鹅厂算是去年一个很大的转折吧。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1g0al3b9ikhj30u01401l4.jpg)\n\n#### 个人生活\n\n个人生活方面无非就是健身、旅游、读书之类除了工作之外的事情，其实去年立了flag，说今年要去两个国家，结果只在五一时候跟妹子去了泰国，逛了三个城市。总结了原因，并不是时间或者是经济的原因，主要是2018互联网寒冬、人心惶惶、各种各样的负面消息层出不穷，谁也不敢放松太久，说白了还是为生活所迫吧🙂🙂🙂。\n\n\n\n","source":"_posts/2019-02-14-At-the-end-of-2018.md","raw":"---\ntitle: At The End Of 2018\ncategories: 闲谈\ndate: 2019-02-14 11:19:59\ntags:\n- 总结\n- 回首2018展望2019\ncomments:\n---\n## 前言\n今年的总结来的比去年稍微晚一些，本来打算像去年一样在最后一个工作日出炉的，但是因为年前事情比较多，而且再加上父母要来过年，又请了半天假回家收拾屋子，所以没有按时完成任务。总的来说今年算是我人生中比较重要的一年，不光是我自己，还有自己的妹子，甚至2018对于中国互联网也是一次历史性的转折。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1g076fg14tqj31hd0u0wi5.jpg)\n\n<!-- more -->\n\n写这篇文章之前我还看了下去年的年终总结，想看看当时立了哪些flag，完成了哪些、辜负了哪些，最终的结论是勉勉强强完成百分之五十，不过虽然一半没有完成，但是今年还发生了一些其他的事情，总的来说收获不小，相比去年有过之而无不及，人总是要进步的嘛~\n\n## 辞旧\n#### 大背景\n\n2018年是不平凡的一年，尤其是对于互联网行业，都在说2018是互联网的寒冬，2018是过去十年最难的一年，同时也是未来十年最好的一年。作为一个在深圳的互联网从业者来说确实感慨颇深，一个个熟悉的朋友“被离职”，一家家曾经耳熟能详的公司“跑路”、“优化”。再加上各大媒体为了眼球效应大肆渲染，确实搞得大家人心惶惶。不过还是有一些公司趁着这个机会疯狂找人，想弯道超车，由此可见互联网还是有无限的潜力的。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1g0780whl50j312w0np0u6.jpg)\n\n#### 职业生涯\n\n今年对我影响最大应该算是从美图离职吧，不过这个真的跟互联网寒冬没有关系，完全是个人原因。其实到现在为止，美图在我心里依然占据很重要的一部分，从2016年6月13日到2018年6月13日，在美图的整整两年中我学到新的技术，认识到新的朋友，接触到新的圈子，更重要的是美图教会了我一种精神，一种上进，一种不服输的精神，总是想学更多的东西，想认识更多的人，总是有一种饥饿感。当然这一切也离不开我那些优秀的同事们。这也印证了那句话，你的圈子决定你成为一个生么样的人。美图公司给我留下的印象依然是站在图像处理领域的最高点，每一款产品都能让人眼前一亮，同时也一直在引领着“美颜”趋势的发展。\n\n5月底的时候身边的同事陆续地走了，去了BAT或者国外发展，不管是继续求学还是继续工作，他们都有了新的目标，当时对于不服输的我来说其实影响很大，于是也去鹅厂试了下并且拿到了offer。正好当时也觉得在美图带的时间也算比较久，而且对于个人的成长也似乎到了瓶颈，当时只是做一些业务需求，正好自己也想接触一些新的东西，所以就来了鹅厂。\n\n![美图公司](https://ws2.sinaimg.cn/large/006tKfTcgy1g0akxedwthj30zk0qodno.jpg)\n\n现在想想当时的情况感觉还是挺不可思议的，鹅厂的面试流程一项以严(hen)谨(man)著称，之前看论坛上流程要几个月的大有人在，而我5月底还在纠结要不要来腾讯，而六月中旬就拿到了offer，在这里还是要感谢我的现在的导师一直持续跟、催促进面试流程，才使得有这样的效率。历史总是惊人的相似，想起我当时来深圳的时候，2016年的5月底我还在北京的出租房门前给我妈打着电话纠结是否要来深圳打拼，从北京到深圳，地理位置的巨大变化不说，包括圈子，工作，生活基本都要从头开始，但是过了不到一个月 6月13号我已经做在了深圳美图的工位上，有的时候人生就是需要这样的而果断甚至是决绝吧。来到鹅厂算是去年一个很大的转折吧。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1g0al3b9ikhj30u01401l4.jpg)\n\n#### 个人生活\n\n个人生活方面无非就是健身、旅游、读书之类除了工作之外的事情，其实去年立了flag，说今年要去两个国家，结果只在五一时候跟妹子去了泰国，逛了三个城市。总结了原因，并不是时间或者是经济的原因，主要是2018互联网寒冬、人心惶惶、各种各样的负面消息层出不穷，谁也不敢放松太久，说白了还是为生活所迫吧🙂🙂🙂。\n\n\n\n","slug":"At-the-end-of-2018","published":1,"updated":"2019-02-18T07:20:22.275Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2lz0025a04wa99x3bpo","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今年的总结来的比去年稍微晚一些，本来打算像去年一样在最后一个工作日出炉的，但是因为年前事情比较多，而且再加上父母要来过年，又请了半天假回家收拾屋子，所以没有按时完成任务。总的来说今年算是我人生中比较重要的一年，不光是我自己，还有自己的妹子，甚至2018对于中国互联网也是一次历史性的转折。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1g076fg14tqj31hd0u0wi5.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>写这篇文章之前我还看了下去年的年终总结，想看看当时立了哪些flag，完成了哪些、辜负了哪些，最终的结论是勉勉强强完成百分之五十，不过虽然一半没有完成，但是今年还发生了一些其他的事情，总的来说收获不小，相比去年有过之而无不及，人总是要进步的嘛~</p>\n<h2 id=\"辞旧\"><a href=\"#辞旧\" class=\"headerlink\" title=\"辞旧\"></a>辞旧</h2><h4 id=\"大背景\"><a href=\"#大背景\" class=\"headerlink\" title=\"大背景\"></a>大背景</h4><p>2018年是不平凡的一年，尤其是对于互联网行业，都在说2018是互联网的寒冬，2018是过去十年最难的一年，同时也是未来十年最好的一年。作为一个在深圳的互联网从业者来说确实感慨颇深，一个个熟悉的朋友“被离职”，一家家曾经耳熟能详的公司“跑路”、“优化”。再加上各大媒体为了眼球效应大肆渲染，确实搞得大家人心惶惶。不过还是有一些公司趁着这个机会疯狂找人，想弯道超车，由此可见互联网还是有无限的潜力的。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1g0780whl50j312w0np0u6.jpg\" alt=\"\"></p>\n<h4 id=\"职业生涯\"><a href=\"#职业生涯\" class=\"headerlink\" title=\"职业生涯\"></a>职业生涯</h4><p>今年对我影响最大应该算是从美图离职吧，不过这个真的跟互联网寒冬没有关系，完全是个人原因。其实到现在为止，美图在我心里依然占据很重要的一部分，从2016年6月13日到2018年6月13日，在美图的整整两年中我学到新的技术，认识到新的朋友，接触到新的圈子，更重要的是美图教会了我一种精神，一种上进，一种不服输的精神，总是想学更多的东西，想认识更多的人，总是有一种饥饿感。当然这一切也离不开我那些优秀的同事们。这也印证了那句话，你的圈子决定你成为一个生么样的人。美图公司给我留下的印象依然是站在图像处理领域的最高点，每一款产品都能让人眼前一亮，同时也一直在引领着“美颜”趋势的发展。</p>\n<p>5月底的时候身边的同事陆续地走了，去了BAT或者国外发展，不管是继续求学还是继续工作，他们都有了新的目标，当时对于不服输的我来说其实影响很大，于是也去鹅厂试了下并且拿到了offer。正好当时也觉得在美图带的时间也算比较久，而且对于个人的成长也似乎到了瓶颈，当时只是做一些业务需求，正好自己也想接触一些新的东西，所以就来了鹅厂。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1g0akxedwthj30zk0qodno.jpg\" alt=\"美图公司\"></p>\n<p>现在想想当时的情况感觉还是挺不可思议的，鹅厂的面试流程一项以严(hen)谨(man)著称，之前看论坛上流程要几个月的大有人在，而我5月底还在纠结要不要来腾讯，而六月中旬就拿到了offer，在这里还是要感谢我的现在的导师一直持续跟、催促进面试流程，才使得有这样的效率。历史总是惊人的相似，想起我当时来深圳的时候，2016年的5月底我还在北京的出租房门前给我妈打着电话纠结是否要来深圳打拼，从北京到深圳，地理位置的巨大变化不说，包括圈子，工作，生活基本都要从头开始，但是过了不到一个月 6月13号我已经做在了深圳美图的工位上，有的时候人生就是需要这样的而果断甚至是决绝吧。来到鹅厂算是去年一个很大的转折吧。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1g0al3b9ikhj30u01401l4.jpg\" alt=\"\"></p>\n<h4 id=\"个人生活\"><a href=\"#个人生活\" class=\"headerlink\" title=\"个人生活\"></a>个人生活</h4><p>个人生活方面无非就是健身、旅游、读书之类除了工作之外的事情，其实去年立了flag，说今年要去两个国家，结果只在五一时候跟妹子去了泰国，逛了三个城市。总结了原因，并不是时间或者是经济的原因，主要是2018互联网寒冬、人心惶惶、各种各样的负面消息层出不穷，谁也不敢放松太久，说白了还是为生活所迫吧🙂🙂🙂。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今年的总结来的比去年稍微晚一些，本来打算像去年一样在最后一个工作日出炉的，但是因为年前事情比较多，而且再加上父母要来过年，又请了半天假回家收拾屋子，所以没有按时完成任务。总的来说今年算是我人生中比较重要的一年，不光是我自己，还有自己的妹子，甚至2018对于中国互联网也是一次历史性的转折。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1g076fg14tqj31hd0u0wi5.jpg\" alt=\"\"></p>","more":"<p>写这篇文章之前我还看了下去年的年终总结，想看看当时立了哪些flag，完成了哪些、辜负了哪些，最终的结论是勉勉强强完成百分之五十，不过虽然一半没有完成，但是今年还发生了一些其他的事情，总的来说收获不小，相比去年有过之而无不及，人总是要进步的嘛~</p>\n<h2 id=\"辞旧\"><a href=\"#辞旧\" class=\"headerlink\" title=\"辞旧\"></a>辞旧</h2><h4 id=\"大背景\"><a href=\"#大背景\" class=\"headerlink\" title=\"大背景\"></a>大背景</h4><p>2018年是不平凡的一年，尤其是对于互联网行业，都在说2018是互联网的寒冬，2018是过去十年最难的一年，同时也是未来十年最好的一年。作为一个在深圳的互联网从业者来说确实感慨颇深，一个个熟悉的朋友“被离职”，一家家曾经耳熟能详的公司“跑路”、“优化”。再加上各大媒体为了眼球效应大肆渲染，确实搞得大家人心惶惶。不过还是有一些公司趁着这个机会疯狂找人，想弯道超车，由此可见互联网还是有无限的潜力的。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1g0780whl50j312w0np0u6.jpg\" alt=\"\"></p>\n<h4 id=\"职业生涯\"><a href=\"#职业生涯\" class=\"headerlink\" title=\"职业生涯\"></a>职业生涯</h4><p>今年对我影响最大应该算是从美图离职吧，不过这个真的跟互联网寒冬没有关系，完全是个人原因。其实到现在为止，美图在我心里依然占据很重要的一部分，从2016年6月13日到2018年6月13日，在美图的整整两年中我学到新的技术，认识到新的朋友，接触到新的圈子，更重要的是美图教会了我一种精神，一种上进，一种不服输的精神，总是想学更多的东西，想认识更多的人，总是有一种饥饿感。当然这一切也离不开我那些优秀的同事们。这也印证了那句话，你的圈子决定你成为一个生么样的人。美图公司给我留下的印象依然是站在图像处理领域的最高点，每一款产品都能让人眼前一亮，同时也一直在引领着“美颜”趋势的发展。</p>\n<p>5月底的时候身边的同事陆续地走了，去了BAT或者国外发展，不管是继续求学还是继续工作，他们都有了新的目标，当时对于不服输的我来说其实影响很大，于是也去鹅厂试了下并且拿到了offer。正好当时也觉得在美图带的时间也算比较久，而且对于个人的成长也似乎到了瓶颈，当时只是做一些业务需求，正好自己也想接触一些新的东西，所以就来了鹅厂。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1g0akxedwthj30zk0qodno.jpg\" alt=\"美图公司\"></p>\n<p>现在想想当时的情况感觉还是挺不可思议的，鹅厂的面试流程一项以严(hen)谨(man)著称，之前看论坛上流程要几个月的大有人在，而我5月底还在纠结要不要来腾讯，而六月中旬就拿到了offer，在这里还是要感谢我的现在的导师一直持续跟、催促进面试流程，才使得有这样的效率。历史总是惊人的相似，想起我当时来深圳的时候，2016年的5月底我还在北京的出租房门前给我妈打着电话纠结是否要来深圳打拼，从北京到深圳，地理位置的巨大变化不说，包括圈子，工作，生活基本都要从头开始，但是过了不到一个月 6月13号我已经做在了深圳美图的工位上，有的时候人生就是需要这样的而果断甚至是决绝吧。来到鹅厂算是去年一个很大的转折吧。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1g0al3b9ikhj30u01401l4.jpg\" alt=\"\"></p>\n<h4 id=\"个人生活\"><a href=\"#个人生活\" class=\"headerlink\" title=\"个人生活\"></a>个人生活</h4><p>个人生活方面无非就是健身、旅游、读书之类除了工作之外的事情，其实去年立了flag，说今年要去两个国家，结果只在五一时候跟妹子去了泰国，逛了三个城市。总结了原因，并不是时间或者是经济的原因，主要是2018互联网寒冬、人心惶惶、各种各样的负面消息层出不穷，谁也不敢放松太久，说白了还是为生活所迫吧🙂🙂🙂。</p>"},{"title":"位运算的简单理解😊","date":"2018-01-19T06:20:39.000Z","thumbnail":"https://tpc.googlesyndication.com/simgad/9110423436365907840","comments":1,"_content":"## 1：背景\n\n从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。\n\n我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。\n\n在iOS系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在iOS开发中不管是Objective—C还是Swift都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。\n\n```\ntypedef NS_OPTIONS(NSUInteger, NSLayoutFormatOptions) {\n    NSLayoutFormatAlignAllLeft = (1 << NSLayoutAttributeLeft),\n    NSLayoutFormatAlignAllRight = (1 << NSLayoutAttributeRight),\n    NSLayoutFormatAlignAllTop = (1 << NSLayoutAttributeTop),\n    NSLayoutFormatAlignAllBottom = (1 << NSLayoutAttributeBottom),\n    NSLayoutFormatAlignAllLeading = (1 << NSLayoutAttributeLeading),\n    NSLayoutFormatAlignAllTrailing = (1 << NSLayoutAttributeTrailing),\n.\n.\n.\n.\n    }\n```\n<!-- more -->\n\n## 10：计算机计算原理\n#### 加法和乘法\n\n举一个简单的例子来看下CPU是如何进行计算的，比如这行代码\n\n```\nint a = 35;\nint b = 47;\nint c = a + b;\n\n```\n计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加\n\n```\n35:  0 0 1 0 0 0 1 1\n47:  0 0 1 0 1 1 1 1\n————————————————————\n82:  0 1 0 1 0 0 1 0\n\n```\n\n再来看下乘法，执行如下的代码\n\n```\nint a = 3;\nint b = 2;\nint c = a * b;\n\n3:  0 0 0 0 0 0 1 1  *  2\n————————————————————\n6:  0 0 0 0 0 1 1 0\n\n*********************************************\n\nint a = 3;\nint b = 4;\nint c = a * b;\n\n3:  0 0 0 0 0 0 1 1  *  4\n————————————————————\n12:  0 0 0 0 1 1 0 0\n\n*********************************************\n\nint a = 3;\nint b = 8;\nint c = a * b;\n\n3:  0 0 0 0 0 0 1 1  *  8\n————————————————————\n24:  0 0 0 1 1 0 0 0\n\n```\n通过以上运算可以看出当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位，放到代码中 我们可以这样来写 **a << N**,所以上面**3 * 2、3 * 4、3 * 8**其实是可以写成**3<<1、3<<2、3<<3**，运算结果都是一样的。\n\n那假如相乘的两个数都不满足2^N怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足2^N的数相加的情况，打个比方\n\n```\nint a = 15;\t\t\t\tint a = 15\nint b = 13;      =>    \tint b = (4 + 8 + 1)\nint c = a * b;\t\t\tint c = a * b\n\n```\n最后其实执行相乘运算就会变成这样 **15 * 4 + 15 * 8 + 15 * 1**，按照上文说的移位来转换为位运算就会变成**15 << 2 + 15 << 3 + 15 << 0**\n\n#### 减法和除法\n减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作(因为正数的源码补码反码都与本身相同)。首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.\n\n除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成string的形式，这也是为什么浮点运算会消耗大量的时钟周期(操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz频率的CPU可以在一秒执行运算3.0*1024*1024*1024个时钟周期)\n\n## 11：位运算符\n\n使用的运算符包括下面：\n\n 含义 | 运算符 | 例子\n  -----|-----|------\n 左移    | <<    | 0011  =>  0110\n 右移    | >>    | 0110  =>  0011\n 按位或    | ︳    |0011 <br> -------  => 1011<br>1011\n 按位与    | &    |0011 <br> -------  => 1011<br>1011\n 按位取反    | ~    |0011  => 1100\n 按位异或 (相同为零不同为一)    | ^    |0011 <br> -------  => 1000<br>1011\n\n\n## 100：颜色转换\n#### 背景\n上面说了iOS中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照16进制的样子给我们标色值。但是iOS中的UIColor并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为UIColor。\n#### 原理分析\nUIColor中通常是用传入RGB的数值来初始化，而且每个颜色的取值范围是十进制下的0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如**0xffa131**我们要转换就要先理解其组成\n\n* 0x或者0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义\n\n* ff 颜色中的R值,转换为二进制为 1111 1111\n\n* a1 颜色中的G值,转换为二进制为 1010 0001\n\n* 31 颜色中的B值,转换为二进制为 0011 0001\n* 上述色彩值转换为二进制后为**1111 1111 1010 0001 0011 0001(每一位十六进制的对应4位二进制，如果位数不够记得高位补零)**\n\n通常来讲十六进制的颜色是按照上面的RGB的顺序排列的，但是并不固定，有时候可能会在其中加A(Alpha)值，具体情况按照设计为准，本文以通用情况举例。\n\n综上，我们只需把对应位的值转换为10进制然后/255.0f就可得到RGB色彩值，从而转换为UIColor\n\n#### 转换代码\n先列出代码，后续解析\n\n```\n- (UIColor *)colorWithHex:(long)hexColor alpha:(float)opacity\n{\n\t//将传入的十六进制颜色0xffa131 转换为UIColor\n\n    float red = ((hexColor & 0xFF0000) >> 16)/255.0f;\n    float green = ((hexColor & 0xFF00) >> 8)/255.0f;\n    float blue = (hexColor & 0xFF)/255.0f;\n    return [UIColor colorWithRed:red green:green blue:blue alpha:opacity];\n}\n```\n大概原理可以看出将RGB每个值都解析出来然后变成UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲(默认将参数代入，用0xffa131代替hexColor)\n\n*  **0xffa131 & 0xFF0000**\n\n\t我们知道红色值是前两位也就是**ff**，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：<br>\n\t1111 1111 1010 0001 0011 0001<br>-------------------------------------------  => & => 1111 1111 0000 0000 0000<br>\n\t1111 1111 0000 0000 0000 0000<br>这部操作做完后可以看出将除了R值之外的G值B值全部置零了，但是离最终结果还差点，因为0xFF是1111 1111，而我们的结果后面多出了16个0，所以便有了第二步操作\n\n* **>> 16**\n\n\t将上一步得到的结果右移16位即得到**0000 0000 0000 0000 1111 1111**高位的零可以忽略，这也是最终的结果\n\n* **/ 255.0f**\n\n\t这一步应该都知道UIColor中传入的数值范围在0~1，所以我们要做下转换\n\n* 后续的G值和B值都是一样的，只是大家注意位数就可以了，**值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用0补齐**\n\n## 101：枚举\n关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举(伪代码)\n\n```\ntypedef NS_OPTIONS(NSUInteger, TestOptions) {\n     TestOptionOne     =    1 << 0, （000001)\n\n  \t TestOptionTwo     =    1 << 1,\t(000010)\n\n\t TestOptionThree   =    1 << 2,\t(000100)\n\n\t TestOptionFour    =    1 << 3,\t(001000)\n\n\t TestOptionFive    =    1 << 4,\t(010000)\n\n\t TestOptionSix     =    1 << 5,\t(100000)\n.\n.\n.\n.\n\n```\n\n* 解析\n 上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如**TestOptionOne | TestOptionTwo （000001 | 000010 => 000011）** 或者有其他的自定义组合。\n\n## 110：加密\n在iOS中我们可以利用异或来进行加解密，异或的特性如下\n```\nA ^ B = C => C ^ A = B => C ^ B = A\n```\n上文我们可以把A认为是需要加密的数据，B认为是密钥 C是加密后的数据\n比如:\n\n```\n#include <stdio.h>\nmain()\n{\n   char a[]=\"MyPassword\";        /*要加密的密码*/\n   char b[]=\"cryptographic\";     /*密钥*/\n   int i;\n   /*加密代码*/\n   for(i=0;a[i]!='\\0';i++)\na[i]=a[i]^b[i];\n   printf(\"You Password encrypted: %s\\n\",a);\n   /*解密代码*/\n   for(i=0;a[i]!='\\0';i++)\na[i]=a[i]^b[i];\n   printf(\"You Password: %s\\n\",a);\n\n}\n```\n\n## 111：其他应用\n* 记得iOS总有一道面试题**在不使用第三个变量的情况下交换两个变量的值**，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如下位运算操作\n\n```\nvoid exchange(int x , int y)\n{\n    x ^= y;\n    y ^= x;\n    x ^= y;\n}\n```\n\n* 判断一个数的奇偶性，其实我们可以用**%2**来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:\n\n```\nvoid test(int x)\n{\n    if (x&1) {\n        printf(\"奇数\");\n    } else {\n        printf(\"偶数\");\n    }\n}\n```\n原理很简单，因为二进制是满二进一，一旦超过1就会变0并进一位，这时候和00001做**&**操作一定会为0，反之不为零。这样写效率会更高。\n\n* 计算两个数的平均值，通常我们都是（x+y）/2,先不考虑效率问题，这样还会引起一个其他的问题，那就是x+y的值很有可能溢出大于INT_MAX，所以我们采用位运算的办法来解决即可：\n\n```\nint average(int x, int y)\n{    \n    return (x&y)+((x^y)>>1);\n}\n```\n## 1000：总结\n其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。\n","source":"_posts/位运算的简单理解😊.md","raw":"---\ntitle: \"位运算的简单理解\\U0001F60A\"\ndate: 2018-01-19 14:20:39\ntags:\n  - 算法\n  - C语言\n  - 排序\ncategories: iOS开发\nthumbnail: https://tpc.googlesyndication.com/simgad/9110423436365907840\ncomments:\n---\n## 1：背景\n\n从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。\n\n我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。\n\n在iOS系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在iOS开发中不管是Objective—C还是Swift都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。\n\n```\ntypedef NS_OPTIONS(NSUInteger, NSLayoutFormatOptions) {\n    NSLayoutFormatAlignAllLeft = (1 << NSLayoutAttributeLeft),\n    NSLayoutFormatAlignAllRight = (1 << NSLayoutAttributeRight),\n    NSLayoutFormatAlignAllTop = (1 << NSLayoutAttributeTop),\n    NSLayoutFormatAlignAllBottom = (1 << NSLayoutAttributeBottom),\n    NSLayoutFormatAlignAllLeading = (1 << NSLayoutAttributeLeading),\n    NSLayoutFormatAlignAllTrailing = (1 << NSLayoutAttributeTrailing),\n.\n.\n.\n.\n    }\n```\n<!-- more -->\n\n## 10：计算机计算原理\n#### 加法和乘法\n\n举一个简单的例子来看下CPU是如何进行计算的，比如这行代码\n\n```\nint a = 35;\nint b = 47;\nint c = a + b;\n\n```\n计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加\n\n```\n35:  0 0 1 0 0 0 1 1\n47:  0 0 1 0 1 1 1 1\n————————————————————\n82:  0 1 0 1 0 0 1 0\n\n```\n\n再来看下乘法，执行如下的代码\n\n```\nint a = 3;\nint b = 2;\nint c = a * b;\n\n3:  0 0 0 0 0 0 1 1  *  2\n————————————————————\n6:  0 0 0 0 0 1 1 0\n\n*********************************************\n\nint a = 3;\nint b = 4;\nint c = a * b;\n\n3:  0 0 0 0 0 0 1 1  *  4\n————————————————————\n12:  0 0 0 0 1 1 0 0\n\n*********************************************\n\nint a = 3;\nint b = 8;\nint c = a * b;\n\n3:  0 0 0 0 0 0 1 1  *  8\n————————————————————\n24:  0 0 0 1 1 0 0 0\n\n```\n通过以上运算可以看出当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位，放到代码中 我们可以这样来写 **a << N**,所以上面**3 * 2、3 * 4、3 * 8**其实是可以写成**3<<1、3<<2、3<<3**，运算结果都是一样的。\n\n那假如相乘的两个数都不满足2^N怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足2^N的数相加的情况，打个比方\n\n```\nint a = 15;\t\t\t\tint a = 15\nint b = 13;      =>    \tint b = (4 + 8 + 1)\nint c = a * b;\t\t\tint c = a * b\n\n```\n最后其实执行相乘运算就会变成这样 **15 * 4 + 15 * 8 + 15 * 1**，按照上文说的移位来转换为位运算就会变成**15 << 2 + 15 << 3 + 15 << 0**\n\n#### 减法和除法\n减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作(因为正数的源码补码反码都与本身相同)。首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.\n\n除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成string的形式，这也是为什么浮点运算会消耗大量的时钟周期(操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz频率的CPU可以在一秒执行运算3.0*1024*1024*1024个时钟周期)\n\n## 11：位运算符\n\n使用的运算符包括下面：\n\n 含义 | 运算符 | 例子\n  -----|-----|------\n 左移    | <<    | 0011  =>  0110\n 右移    | >>    | 0110  =>  0011\n 按位或    | ︳    |0011 <br> -------  => 1011<br>1011\n 按位与    | &    |0011 <br> -------  => 1011<br>1011\n 按位取反    | ~    |0011  => 1100\n 按位异或 (相同为零不同为一)    | ^    |0011 <br> -------  => 1000<br>1011\n\n\n## 100：颜色转换\n#### 背景\n上面说了iOS中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照16进制的样子给我们标色值。但是iOS中的UIColor并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为UIColor。\n#### 原理分析\nUIColor中通常是用传入RGB的数值来初始化，而且每个颜色的取值范围是十进制下的0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如**0xffa131**我们要转换就要先理解其组成\n\n* 0x或者0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义\n\n* ff 颜色中的R值,转换为二进制为 1111 1111\n\n* a1 颜色中的G值,转换为二进制为 1010 0001\n\n* 31 颜色中的B值,转换为二进制为 0011 0001\n* 上述色彩值转换为二进制后为**1111 1111 1010 0001 0011 0001(每一位十六进制的对应4位二进制，如果位数不够记得高位补零)**\n\n通常来讲十六进制的颜色是按照上面的RGB的顺序排列的，但是并不固定，有时候可能会在其中加A(Alpha)值，具体情况按照设计为准，本文以通用情况举例。\n\n综上，我们只需把对应位的值转换为10进制然后/255.0f就可得到RGB色彩值，从而转换为UIColor\n\n#### 转换代码\n先列出代码，后续解析\n\n```\n- (UIColor *)colorWithHex:(long)hexColor alpha:(float)opacity\n{\n\t//将传入的十六进制颜色0xffa131 转换为UIColor\n\n    float red = ((hexColor & 0xFF0000) >> 16)/255.0f;\n    float green = ((hexColor & 0xFF00) >> 8)/255.0f;\n    float blue = (hexColor & 0xFF)/255.0f;\n    return [UIColor colorWithRed:red green:green blue:blue alpha:opacity];\n}\n```\n大概原理可以看出将RGB每个值都解析出来然后变成UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲(默认将参数代入，用0xffa131代替hexColor)\n\n*  **0xffa131 & 0xFF0000**\n\n\t我们知道红色值是前两位也就是**ff**，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：<br>\n\t1111 1111 1010 0001 0011 0001<br>-------------------------------------------  => & => 1111 1111 0000 0000 0000<br>\n\t1111 1111 0000 0000 0000 0000<br>这部操作做完后可以看出将除了R值之外的G值B值全部置零了，但是离最终结果还差点，因为0xFF是1111 1111，而我们的结果后面多出了16个0，所以便有了第二步操作\n\n* **>> 16**\n\n\t将上一步得到的结果右移16位即得到**0000 0000 0000 0000 1111 1111**高位的零可以忽略，这也是最终的结果\n\n* **/ 255.0f**\n\n\t这一步应该都知道UIColor中传入的数值范围在0~1，所以我们要做下转换\n\n* 后续的G值和B值都是一样的，只是大家注意位数就可以了，**值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用0补齐**\n\n## 101：枚举\n关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举(伪代码)\n\n```\ntypedef NS_OPTIONS(NSUInteger, TestOptions) {\n     TestOptionOne     =    1 << 0, （000001)\n\n  \t TestOptionTwo     =    1 << 1,\t(000010)\n\n\t TestOptionThree   =    1 << 2,\t(000100)\n\n\t TestOptionFour    =    1 << 3,\t(001000)\n\n\t TestOptionFive    =    1 << 4,\t(010000)\n\n\t TestOptionSix     =    1 << 5,\t(100000)\n.\n.\n.\n.\n\n```\n\n* 解析\n 上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如**TestOptionOne | TestOptionTwo （000001 | 000010 => 000011）** 或者有其他的自定义组合。\n\n## 110：加密\n在iOS中我们可以利用异或来进行加解密，异或的特性如下\n```\nA ^ B = C => C ^ A = B => C ^ B = A\n```\n上文我们可以把A认为是需要加密的数据，B认为是密钥 C是加密后的数据\n比如:\n\n```\n#include <stdio.h>\nmain()\n{\n   char a[]=\"MyPassword\";        /*要加密的密码*/\n   char b[]=\"cryptographic\";     /*密钥*/\n   int i;\n   /*加密代码*/\n   for(i=0;a[i]!='\\0';i++)\na[i]=a[i]^b[i];\n   printf(\"You Password encrypted: %s\\n\",a);\n   /*解密代码*/\n   for(i=0;a[i]!='\\0';i++)\na[i]=a[i]^b[i];\n   printf(\"You Password: %s\\n\",a);\n\n}\n```\n\n## 111：其他应用\n* 记得iOS总有一道面试题**在不使用第三个变量的情况下交换两个变量的值**，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如下位运算操作\n\n```\nvoid exchange(int x , int y)\n{\n    x ^= y;\n    y ^= x;\n    x ^= y;\n}\n```\n\n* 判断一个数的奇偶性，其实我们可以用**%2**来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:\n\n```\nvoid test(int x)\n{\n    if (x&1) {\n        printf(\"奇数\");\n    } else {\n        printf(\"偶数\");\n    }\n}\n```\n原理很简单，因为二进制是满二进一，一旦超过1就会变0并进一位，这时候和00001做**&**操作一定会为0，反之不为零。这样写效率会更高。\n\n* 计算两个数的平均值，通常我们都是（x+y）/2,先不考虑效率问题，这样还会引起一个其他的问题，那就是x+y的值很有可能溢出大于INT_MAX，所以我们采用位运算的办法来解决即可：\n\n```\nint average(int x, int y)\n{    \n    return (x&y)+((x^y)>>1);\n}\n```\n## 1000：总结\n其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。\n","slug":"位运算的简单理解😊","published":1,"updated":"2019-02-02T03:22:53.093Z","layout":"post","photos":[],"link":"","_id":"cjsa0g2m10028a04w04rrisig","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"1：背景\"><a href=\"#1：背景\" class=\"headerlink\" title=\"1：背景\"></a>1：背景</h2><p>从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。</p>\n<p>我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。</p>\n<p>在iOS系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在iOS开发中不管是Objective—C还是Swift都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSLayoutFormatOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeft</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeft</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllRight</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeRight</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTop</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTop</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllBottom</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeBottom</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeading</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeading</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTrailing</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTrailing</span>),</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"10：计算机计算原理\"><a href=\"#10：计算机计算原理\" class=\"headerlink\" title=\"10：计算机计算原理\"></a>10：计算机计算原理</h2><h4 id=\"加法和乘法\"><a href=\"#加法和乘法\" class=\"headerlink\" title=\"加法和乘法\"></a>加法和乘法</h4><p>举一个简单的例子来看下CPU是如何进行计算的，比如这行代码</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 35;</span><br><span class=\"line\"><span class=\"attribute\">int b</span> = 47;</span><br><span class=\"line\"><span class=\"attribute\">int c</span> = a + b;</span><br></pre></td></tr></table></figure>\n<p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"code\"><pre><span class=\"line\">35: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">47: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">82: <span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0</span><br></pre></td></tr></table></figure>\n<p>再来看下乘法，执行如下的代码</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"code\"><pre><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 2;</span><br><span class=\"line\">int c = a * b;</span><br><span class=\"line\"></span><br><span class=\"line\">3: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1  *  2</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">6: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>1<span class=\"number\"> 1 </span>0</span><br><span class=\"line\"></span><br><span class=\"line\">*********************************************</span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 4;</span><br><span class=\"line\">int c = a * b;</span><br><span class=\"line\"></span><br><span class=\"line\">3: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1  *  4</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">12: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 0 </span>0</span><br><span class=\"line\"></span><br><span class=\"line\">*********************************************</span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 8;</span><br><span class=\"line\">int c = a * b;</span><br><span class=\"line\"></span><br><span class=\"line\">3: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1  *  8</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">24: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>1<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0</span><br></pre></td></tr></table></figure>\n<p>通过以上运算可以看出当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位，放到代码中 我们可以这样来写 <strong>a &lt;&lt; N</strong>,所以上面<strong>3 <em> 2、3 </em> 4、3 * 8</strong>其实是可以写成<strong>3&lt;&lt;1、3&lt;&lt;2、3&lt;&lt;3</strong>，运算结果都是一样的。</p>\n<p>那假如相乘的两个数都不满足2^N怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足2^N的数相加的情况，打个比方</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 15;\t\t\t\t<span class=\"attribute\">i</span><span class=\"attribute\">n</span><span class=\"attribute\">t</span> <span class=\"attribute\">a</span> = 15</span><br><span class=\"line\">int b = 13;      =&gt;    \tint b = (4 + 8 + 1)</span><br><span class=\"line\">int c = a * b;\t\t\t<span class=\"attribute\">i</span><span class=\"attribute\">n</span><span class=\"attribute\">t</span> <span class=\"attribute\">c</span> = a * b</span><br></pre></td></tr></table></figure>\n<p>最后其实执行相乘运算就会变成这样 <strong>15 <em> 4 + 15 </em> 8 + 15 * 1</strong>，按照上文说的移位来转换为位运算就会变成<strong>15 &lt;&lt; 2 + 15 &lt;&lt; 3 + 15 &lt;&lt; 0</strong></p>\n<h4 id=\"减法和除法\"><a href=\"#减法和除法\" class=\"headerlink\" title=\"减法和除法\"></a>减法和除法</h4><p>减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作(因为正数的源码补码反码都与本身相同)。首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>\n<p>除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成string的形式，这也是为什么浮点运算会消耗大量的时钟周期(操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz频率的CPU可以在一秒执行运算3.0<em>1024</em>1024*1024个时钟周期)</p>\n<h2 id=\"11：位运算符\"><a href=\"#11：位运算符\" class=\"headerlink\" title=\"11：位运算符\"></a>11：位运算符</h2><p>使用的运算符包括下面：</p>\n<table>\n<thead>\n<tr>\n<th>含义</th>\n<th>运算符</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 左移</td>\n<td>&lt;&lt;</td>\n<td>0011  =&gt;  0110</td>\n</tr>\n<tr>\n<td> 右移</td>\n<td>&gt;&gt;</td>\n<td>0110  =&gt;  0011</td>\n</tr>\n<tr>\n<td> 按位或</td>\n<td>︳</td>\n<td>0011 <br> ——-  =&gt; 1011<br>1011</td>\n</tr>\n<tr>\n<td> 按位与</td>\n<td>&amp;</td>\n<td>0011 <br> ——-  =&gt; 1011<br>1011</td>\n</tr>\n<tr>\n<td> 按位取反</td>\n<td>~</td>\n<td>0011  =&gt; 1100</td>\n</tr>\n<tr>\n<td> 按位异或 (相同为零不同为一)</td>\n<td>^</td>\n<td>0011 <br> ——-  =&gt; 1000<br>1011</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"100：颜色转换\"><a href=\"#100：颜色转换\" class=\"headerlink\" title=\"100：颜色转换\"></a>100：颜色转换</h2><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>上面说了iOS中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照16进制的样子给我们标色值。但是iOS中的UIColor并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为UIColor。</p>\n<h4 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h4><p>UIColor中通常是用传入RGB的数值来初始化，而且每个颜色的取值范围是十进制下的0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如<strong>0xffa131</strong>我们要转换就要先理解其组成</p>\n<ul>\n<li><p>0x或者0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义</p>\n</li>\n<li><p>ff 颜色中的R值,转换为二进制为 1111 1111</p>\n</li>\n<li><p>a1 颜色中的G值,转换为二进制为 1010 0001</p>\n</li>\n<li><p>31 颜色中的B值,转换为二进制为 0011 0001</p>\n</li>\n<li>上述色彩值转换为二进制后为<strong>1111 1111 1010 0001 0011 0001(每一位十六进制的对应4位二进制，如果位数不够记得高位补零)</strong></li>\n</ul>\n<p>通常来讲十六进制的颜色是按照上面的RGB的顺序排列的，但是并不固定，有时候可能会在其中加A(Alpha)值，具体情况按照设计为准，本文以通用情况举例。</p>\n<p>综上，我们只需把对应位的值转换为10进制然后/255.0f就可得到RGB色彩值，从而转换为UIColor</p>\n<h4 id=\"转换代码\"><a href=\"#转换代码\" class=\"headerlink\" title=\"转换代码\"></a>转换代码</h4><p>先列出代码，后续解析</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (UIColor *)colorWithHex:(<span class=\"keyword\">long</span>)hexColor <span class=\"built_in\">alpha</span>:(<span class=\"built_in\">float</span>)opacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将传入的十六进制颜色0xffa131 转换为UIColor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">red</span> = ((hexColor &amp; <span class=\"number\">0xFF0000</span>) &gt;&gt; <span class=\"number\">16</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">green</span> = ((hexColor &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">blue</span> = (hexColor &amp; <span class=\"number\">0xFF</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [UIColor colorWithRed:<span class=\"built_in\">red</span> <span class=\"built_in\">green</span>:<span class=\"built_in\">green</span> <span class=\"built_in\">blue</span>:<span class=\"built_in\">blue</span> <span class=\"built_in\">alpha</span>:opacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大概原理可以看出将RGB每个值都解析出来然后变成UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲(默认将参数代入，用0xffa131代替hexColor)</p>\n<ul>\n<li><p><strong>0xffa131 &amp; 0xFF0000</strong></p>\n<p> 我们知道红色值是前两位也就是<strong>ff</strong>，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：<br><br> 1111 1111 1010 0001 0011 0001<br>——————————————-  =&gt; &amp; =&gt; 1111 1111 0000 0000 0000<br><br> 1111 1111 0000 0000 0000 0000<br>这部操作做完后可以看出将除了R值之外的G值B值全部置零了，但是离最终结果还差点，因为0xFF是1111 1111，而我们的结果后面多出了16个0，所以便有了第二步操作</p>\n</li>\n<li><p><strong>&gt;&gt; 16</strong></p>\n<p>  将上一步得到的结果右移16位即得到<strong>0000 0000 0000 0000 1111 1111</strong>高位的零可以忽略，这也是最终的结果</p>\n</li>\n<li><p><strong>/ 255.0f</strong></p>\n<p>  这一步应该都知道UIColor中传入的数值范围在0~1，所以我们要做下转换</p>\n</li>\n<li><p>后续的G值和B值都是一样的，只是大家注意位数就可以了，<strong>值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用0补齐</strong></p>\n</li>\n</ul>\n<h2 id=\"101：枚举\"><a href=\"#101：枚举\" class=\"headerlink\" title=\"101：枚举\"></a>101：枚举</h2><p>关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举(伪代码)</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, TestOptions) &#123;</span><br><span class=\"line\">     TestOptionOne     =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, （<span class=\"number\">000001</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  \t TestOptionTwo     =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,\t(<span class=\"number\">000010</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionThree   =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,\t(<span class=\"number\">000100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionFour    =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>,\t(<span class=\"number\">001000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionFive    =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,\t(<span class=\"number\">010000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionSix     =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>,\t(<span class=\"number\">100000</span>)</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>解析<br>上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如<strong>TestOptionOne | TestOptionTwo （000001 | 000010 =&gt; 000011）</strong> 或者有其他的自定义组合。</li>\n</ul>\n<h2 id=\"110：加密\"><a href=\"#110：加密\" class=\"headerlink\" title=\"110：加密\"></a>110：加密</h2><p>在iOS中我们可以利用异或来进行加解密，异或的特性如下<br><figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">A ^ <span class=\"attr\">B</span> = <span class=\"attr\">C</span> =&gt; C ^ <span class=\"attr\">A</span> = <span class=\"attr\">B</span> =&gt; C ^ <span class=\"attr\">B</span> = A</span><br></pre></td></tr></table></figure></p>\n<p>上文我们可以把A认为是需要加密的数据，B认为是密钥 C是加密后的数据<br>比如:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> a[]=<span class=\"string\">\"MyPassword\"</span>;        <span class=\"comment\">/*要加密的密码*/</span></span><br><span class=\"line\">   <span class=\"keyword\">char</span> b[]=<span class=\"string\">\"cryptographic\"</span>;     <span class=\"comment\">/*密钥*/</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"comment\">/*加密代码*/</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">'\\0'</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"You Password encrypted: %s\\n\"</span>,a);</span><br><span class=\"line\">   <span class=\"comment\">/*解密代码*/</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">'\\0'</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"You Password: %s\\n\"</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"111：其他应用\"><a href=\"#111：其他应用\" class=\"headerlink\" title=\"111：其他应用\"></a>111：其他应用</h2><ul>\n<li>记得iOS总有一道面试题<strong>在不使用第三个变量的情况下交换两个变量的值</strong>，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如下位运算操作</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> exchange(int x , int y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">    <span class=\"attribute\">y</span><span class=\"regexp\"> ^=</span> x;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断一个数的奇偶性，其实我们可以用<strong>%2</strong>来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"奇数\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"偶数\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理很简单，因为二进制是满二进一，一旦超过1就会变0并进一位，这时候和00001做<strong>&amp;</strong>操作一定会为0，反之不为零。这样写效率会更高。</p>\n<ul>\n<li>计算两个数的平均值，通常我们都是（x+y）/2,先不考虑效率问题，这样还会引起一个其他的问题，那就是x+y的值很有可能溢出大于INT_MAX，所以我们采用位运算的办法来解决即可：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">average</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x&amp;y)+((x^y)&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1000：总结\"><a href=\"#1000：总结\" class=\"headerlink\" title=\"1000：总结\"></a>1000：总结</h2><p>其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1：背景\"><a href=\"#1：背景\" class=\"headerlink\" title=\"1：背景\"></a>1：背景</h2><p>从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。</p>\n<p>我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。</p>\n<p>在iOS系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在iOS开发中不管是Objective—C还是Swift都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"type\">NS_OPTIONS</span>(<span class=\"type\">NSUInteger</span>, <span class=\"type\">NSLayoutFormatOptions</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeft</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeft</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllRight</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeRight</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTop</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTop</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllBottom</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeBottom</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllLeading</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeLeading</span>),</span><br><span class=\"line\">    <span class=\"type\">NSLayoutFormatAlignAllTrailing</span> = (1 &lt;&lt; <span class=\"type\">NSLayoutAttributeTrailing</span>),</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"10：计算机计算原理\"><a href=\"#10：计算机计算原理\" class=\"headerlink\" title=\"10：计算机计算原理\"></a>10：计算机计算原理</h2><h4 id=\"加法和乘法\"><a href=\"#加法和乘法\" class=\"headerlink\" title=\"加法和乘法\"></a>加法和乘法</h4><p>举一个简单的例子来看下CPU是如何进行计算的，比如这行代码</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 35;</span><br><span class=\"line\"><span class=\"attribute\">int b</span> = 47;</span><br><span class=\"line\"><span class=\"attribute\">int c</span> = a + b;</span><br></pre></td></tr></table></figure>\n<p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"code\"><pre><span class=\"line\">35: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">47: <span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 1 </span>1</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">82: <span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>1<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>0</span><br></pre></td></tr></table></figure>\n<p>再来看下乘法，执行如下的代码</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"code\"><pre><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 2;</span><br><span class=\"line\">int c = a * b;</span><br><span class=\"line\"></span><br><span class=\"line\">3: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1  *  2</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">6: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>1<span class=\"number\"> 1 </span>0</span><br><span class=\"line\"></span><br><span class=\"line\">*********************************************</span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 4;</span><br><span class=\"line\">int c = a * b;</span><br><span class=\"line\"></span><br><span class=\"line\">3: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1  *  4</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">12: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1<span class=\"number\"> 0 </span>0</span><br><span class=\"line\"></span><br><span class=\"line\">*********************************************</span><br><span class=\"line\"></span><br><span class=\"line\">int a = 3;</span><br><span class=\"line\">int b = 8;</span><br><span class=\"line\">int c = a * b;</span><br><span class=\"line\"></span><br><span class=\"line\">3: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>0<span class=\"number\"> 1 </span>1  *  8</span><br><span class=\"line\">————————————————————</span><br><span class=\"line\">24: <span class=\"number\"> 0 </span>0<span class=\"number\"> 0 </span>1<span class=\"number\"> 1 </span>0<span class=\"number\"> 0 </span>0</span><br></pre></td></tr></table></figure>\n<p>通过以上运算可以看出当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位，放到代码中 我们可以这样来写 <strong>a &lt;&lt; N</strong>,所以上面<strong>3 <em> 2、3 </em> 4、3 * 8</strong>其实是可以写成<strong>3&lt;&lt;1、3&lt;&lt;2、3&lt;&lt;3</strong>，运算结果都是一样的。</p>\n<p>那假如相乘的两个数都不满足2^N怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足2^N的数相加的情况，打个比方</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int a</span> = 15;\t\t\t\t<span class=\"attribute\">i</span><span class=\"attribute\">n</span><span class=\"attribute\">t</span> <span class=\"attribute\">a</span> = 15</span><br><span class=\"line\">int b = 13;      =&gt;    \tint b = (4 + 8 + 1)</span><br><span class=\"line\">int c = a * b;\t\t\t<span class=\"attribute\">i</span><span class=\"attribute\">n</span><span class=\"attribute\">t</span> <span class=\"attribute\">c</span> = a * b</span><br></pre></td></tr></table></figure>\n<p>最后其实执行相乘运算就会变成这样 <strong>15 <em> 4 + 15 </em> 8 + 15 * 1</strong>，按照上文说的移位来转换为位运算就会变成<strong>15 &lt;&lt; 2 + 15 &lt;&lt; 3 + 15 &lt;&lt; 0</strong></p>\n<h4 id=\"减法和除法\"><a href=\"#减法和除法\" class=\"headerlink\" title=\"减法和除法\"></a>减法和除法</h4><p>减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作(因为正数的源码补码反码都与本身相同)。首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>\n<p>除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成string的形式，这也是为什么浮点运算会消耗大量的时钟周期(操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz频率的CPU可以在一秒执行运算3.0<em>1024</em>1024*1024个时钟周期)</p>\n<h2 id=\"11：位运算符\"><a href=\"#11：位运算符\" class=\"headerlink\" title=\"11：位运算符\"></a>11：位运算符</h2><p>使用的运算符包括下面：</p>\n<table>\n<thead>\n<tr>\n<th>含义</th>\n<th>运算符</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 左移</td>\n<td>&lt;&lt;</td>\n<td>0011  =&gt;  0110</td>\n</tr>\n<tr>\n<td> 右移</td>\n<td>&gt;&gt;</td>\n<td>0110  =&gt;  0011</td>\n</tr>\n<tr>\n<td> 按位或</td>\n<td>︳</td>\n<td>0011 <br> ——-  =&gt; 1011<br>1011</td>\n</tr>\n<tr>\n<td> 按位与</td>\n<td>&amp;</td>\n<td>0011 <br> ——-  =&gt; 1011<br>1011</td>\n</tr>\n<tr>\n<td> 按位取反</td>\n<td>~</td>\n<td>0011  =&gt; 1100</td>\n</tr>\n<tr>\n<td> 按位异或 (相同为零不同为一)</td>\n<td>^</td>\n<td>0011 <br> ——-  =&gt; 1000<br>1011</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"100：颜色转换\"><a href=\"#100：颜色转换\" class=\"headerlink\" title=\"100：颜色转换\"></a>100：颜色转换</h2><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>上面说了iOS中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照16进制的样子给我们标色值。但是iOS中的UIColor并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为UIColor。</p>\n<h4 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h4><p>UIColor中通常是用传入RGB的数值来初始化，而且每个颜色的取值范围是十进制下的0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如<strong>0xffa131</strong>我们要转换就要先理解其组成</p>\n<ul>\n<li><p>0x或者0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义</p>\n</li>\n<li><p>ff 颜色中的R值,转换为二进制为 1111 1111</p>\n</li>\n<li><p>a1 颜色中的G值,转换为二进制为 1010 0001</p>\n</li>\n<li><p>31 颜色中的B值,转换为二进制为 0011 0001</p>\n</li>\n<li>上述色彩值转换为二进制后为<strong>1111 1111 1010 0001 0011 0001(每一位十六进制的对应4位二进制，如果位数不够记得高位补零)</strong></li>\n</ul>\n<p>通常来讲十六进制的颜色是按照上面的RGB的顺序排列的，但是并不固定，有时候可能会在其中加A(Alpha)值，具体情况按照设计为准，本文以通用情况举例。</p>\n<p>综上，我们只需把对应位的值转换为10进制然后/255.0f就可得到RGB色彩值，从而转换为UIColor</p>\n<h4 id=\"转换代码\"><a href=\"#转换代码\" class=\"headerlink\" title=\"转换代码\"></a>转换代码</h4><p>先列出代码，后续解析</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (UIColor *)colorWithHex:(<span class=\"keyword\">long</span>)hexColor <span class=\"built_in\">alpha</span>:(<span class=\"built_in\">float</span>)opacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将传入的十六进制颜色0xffa131 转换为UIColor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">red</span> = ((hexColor &amp; <span class=\"number\">0xFF0000</span>) &gt;&gt; <span class=\"number\">16</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">green</span> = ((hexColor &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">blue</span> = (hexColor &amp; <span class=\"number\">0xFF</span>)/<span class=\"number\">255.0</span>f;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [UIColor colorWithRed:<span class=\"built_in\">red</span> <span class=\"built_in\">green</span>:<span class=\"built_in\">green</span> <span class=\"built_in\">blue</span>:<span class=\"built_in\">blue</span> <span class=\"built_in\">alpha</span>:opacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大概原理可以看出将RGB每个值都解析出来然后变成UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲(默认将参数代入，用0xffa131代替hexColor)</p>\n<ul>\n<li><p><strong>0xffa131 &amp; 0xFF0000</strong></p>\n<p> 我们知道红色值是前两位也就是<strong>ff</strong>，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即：<br><br> 1111 1111 1010 0001 0011 0001<br>——————————————-  =&gt; &amp; =&gt; 1111 1111 0000 0000 0000<br><br> 1111 1111 0000 0000 0000 0000<br>这部操作做完后可以看出将除了R值之外的G值B值全部置零了，但是离最终结果还差点，因为0xFF是1111 1111，而我们的结果后面多出了16个0，所以便有了第二步操作</p>\n</li>\n<li><p><strong>&gt;&gt; 16</strong></p>\n<p>  将上一步得到的结果右移16位即得到<strong>0000 0000 0000 0000 1111 1111</strong>高位的零可以忽略，这也是最终的结果</p>\n</li>\n<li><p><strong>/ 255.0f</strong></p>\n<p>  这一步应该都知道UIColor中传入的数值范围在0~1，所以我们要做下转换</p>\n</li>\n<li><p>后续的G值和B值都是一样的，只是大家注意位数就可以了，<strong>值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用0补齐</strong></p>\n</li>\n</ul>\n<h2 id=\"101：枚举\"><a href=\"#101：枚举\" class=\"headerlink\" title=\"101：枚举\"></a>101：枚举</h2><p>关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举(伪代码)</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, TestOptions) &#123;</span><br><span class=\"line\">     TestOptionOne     =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>, （<span class=\"number\">000001</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  \t TestOptionTwo     =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,\t(<span class=\"number\">000010</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionThree   =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,\t(<span class=\"number\">000100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionFour    =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>,\t(<span class=\"number\">001000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionFive    =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,\t(<span class=\"number\">010000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t TestOptionSix     =    <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>,\t(<span class=\"number\">100000</span>)</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>解析<br>上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如<strong>TestOptionOne | TestOptionTwo （000001 | 000010 =&gt; 000011）</strong> 或者有其他的自定义组合。</li>\n</ul>\n<h2 id=\"110：加密\"><a href=\"#110：加密\" class=\"headerlink\" title=\"110：加密\"></a>110：加密</h2><p>在iOS中我们可以利用异或来进行加解密，异或的特性如下<br><figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">A ^ <span class=\"attr\">B</span> = <span class=\"attr\">C</span> =&gt; C ^ <span class=\"attr\">A</span> = <span class=\"attr\">B</span> =&gt; C ^ <span class=\"attr\">B</span> = A</span><br></pre></td></tr></table></figure></p>\n<p>上文我们可以把A认为是需要加密的数据，B认为是密钥 C是加密后的数据<br>比如:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> a[]=<span class=\"string\">\"MyPassword\"</span>;        <span class=\"comment\">/*要加密的密码*/</span></span><br><span class=\"line\">   <span class=\"keyword\">char</span> b[]=<span class=\"string\">\"cryptographic\"</span>;     <span class=\"comment\">/*密钥*/</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"comment\">/*加密代码*/</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">'\\0'</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"You Password encrypted: %s\\n\"</span>,a);</span><br><span class=\"line\">   <span class=\"comment\">/*解密代码*/</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;a[i]!=<span class=\"string\">'\\0'</span>;i++)</span><br><span class=\"line\">a[i]=a[i]^b[i];</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"You Password: %s\\n\"</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"111：其他应用\"><a href=\"#111：其他应用\" class=\"headerlink\" title=\"111：其他应用\"></a>111：其他应用</h2><ul>\n<li>记得iOS总有一道面试题<strong>在不使用第三个变量的情况下交换两个变量的值</strong>，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如下位运算操作</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> exchange(int x , int y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">    <span class=\"attribute\">y</span><span class=\"regexp\"> ^=</span> x;</span><br><span class=\"line\">    <span class=\"attribute\">x</span><span class=\"regexp\"> ^=</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断一个数的奇偶性，其实我们可以用<strong>%2</strong>来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&amp;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"奇数\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"偶数\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理很简单，因为二进制是满二进一，一旦超过1就会变0并进一位，这时候和00001做<strong>&amp;</strong>操作一定会为0，反之不为零。这样写效率会更高。</p>\n<ul>\n<li>计算两个数的平均值，通常我们都是（x+y）/2,先不考虑效率问题，这样还会引起一个其他的问题，那就是x+y的值很有可能溢出大于INT_MAX，所以我们采用位运算的办法来解决即可：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">average</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x&amp;y)+((x^y)&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1000：总结\"><a href=\"#1000：总结\" class=\"headerlink\" title=\"1000：总结\"></a>1000：总结</h2><p>其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjsa0g2ko0008a04wwjmq7m0u","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2kx000fa04w1tnabosi"},{"post_id":"cjsa0g2k80000a04w8pavn7z6","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2kz000ja04w46xy72av"},{"post_id":"cjsa0g2kq000aa04wvnuo3mns","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2l2000ma04wusiubb8y"},{"post_id":"cjsa0g2kf0002a04wpvronjp2","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2l4000ra04wltd5wq0r"},{"post_id":"cjsa0g2kw000ea04wg2ivuv8f","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2l6000ta04wc9ys3wl7"},{"post_id":"cjsa0g2ky000ia04w4pllyeq6","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2l7000wa04wr56du957"},{"post_id":"cjsa0g2km0006a04wp269hgj8","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2l9000za04wv4gkppb0"},{"post_id":"cjsa0g2l1000la04wzo4gshr8","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2la0011a04w1o6wl3be"},{"post_id":"cjsa0g2l3000qa04wif28k5g8","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2lc0015a04wwpflds7e"},{"post_id":"cjsa0g2kt000da04wxx9mfrfo","category_id":"cjsa0g2l2000na04wmohzlphv","_id":"cjsa0g2le0018a04wooi5nwdf"},{"post_id":"cjsa0g2l6000va04wm2ubwmyu","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2lg001da04wx07cdoqe"},{"post_id":"cjsa0g2l8000ya04wfumpaerw","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2lh001fa04wmrzf77mz"},{"post_id":"cjsa0g2l90010a04wwawh6vi7","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2lj001ia04wbdzda6kj"},{"post_id":"cjsa0g2l5000sa04w8magd3vy","category_id":"cjsa0g2l8000xa04w54f9mqoy","_id":"cjsa0g2ll001la04woft4o9n1"},{"post_id":"cjsa0g2ld0017a04wjkywxar4","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2lo001pa04w0f3r5mbx"},{"post_id":"cjsa0g2lf001ca04ww8whl1ir","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2ls001sa04wqfphcybc"},{"post_id":"cjsa0g2lg001ea04wtv07hd7y","category_id":"cjsa0g2le001aa04wnb4ie0bb","_id":"cjsa0g2lt001ua04w9w5ftie8"},{"post_id":"cjsa0g2lb0014a04wpz18qtns","category_id":"cjsa0g2le001aa04wnb4ie0bb","_id":"cjsa0g2lv001ya04w9o62flv3"},{"post_id":"cjsa0g2li001ha04whxpb19si","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2lx0021a04w5izxgjdm"},{"post_id":"cjsa0g2lm001oa04wwj9b3dhv","category_id":"cjsa0g2le001aa04wnb4ie0bb","_id":"cjsa0g2lz0024a04w6rc9zhg7"},{"post_id":"cjsa0g2lp001ra04wg1w5tq1b","category_id":"cjsa0g2l8000xa04w54f9mqoy","_id":"cjsa0g2m00026a04wucaxk0na"},{"post_id":"cjsa0g2lt001ta04wfw3cur9y","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2m20029a04wqemuuwxs"},{"post_id":"cjsa0g2lk001ka04wwn0xjocs","category_id":"cjsa0g2lo001qa04wajuicdln","_id":"cjsa0g2m3002ba04wugnzwgmb"},{"post_id":"cjsa0g2lv001xa04wpmlz7xso","category_id":"cjsa0g2le001aa04wnb4ie0bb","_id":"cjsa0g2m4002ea04wd88957uv"},{"post_id":"cjsa0g2lw0020a04wwb2yltar","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2m5002ga04w7atmrk7s"},{"post_id":"cjsa0g2ly0023a04wf3ateqrz","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2m5002ia04w25hj1r3a"},{"post_id":"cjsa0g2lz0025a04wa99x3bpo","category_id":"cjsa0g2lo001qa04wajuicdln","_id":"cjsa0g2m6002ja04wfi20ilwo"},{"post_id":"cjsa0g2m10028a04w04rrisig","category_id":"cjsa0g2kj0004a04wag0g1yua","_id":"cjsa0g2m7002la04wdkazq1fx"}],"PostTag":[{"post_id":"cjsa0g2k80000a04w8pavn7z6","tag_id":"cjsa0g2kl0005a04wkqwil267","_id":"cjsa0g2l0000ka04wzjvoftjt"},{"post_id":"cjsa0g2k80000a04w8pavn7z6","tag_id":"cjsa0g2kr000ca04worep157p","_id":"cjsa0g2l2000oa04wlxoe5ws5"},{"post_id":"cjsa0g2kf0002a04wpvronjp2","tag_id":"cjsa0g2ky000ha04wspdzqtw7","_id":"cjsa0g2lb0013a04wmpyc1me7"},{"post_id":"cjsa0g2kf0002a04wpvronjp2","tag_id":"cjsa0g2l3000pa04w1mt9zxls","_id":"cjsa0g2ld0016a04w2sn1pzof"},{"post_id":"cjsa0g2kf0002a04wpvronjp2","tag_id":"cjsa0g2l6000ua04wd8wxpraj","_id":"cjsa0g2lf001ba04we0c8lahi"},{"post_id":"cjsa0g2km0006a04wp269hgj8","tag_id":"cjsa0g2la0012a04wyzs3v5ki","_id":"cjsa0g2lj001ja04wlocucugf"},{"post_id":"cjsa0g2km0006a04wp269hgj8","tag_id":"cjsa0g2le0019a04wrfnca9bk","_id":"cjsa0g2lm001ma04wr772lh50"},{"post_id":"cjsa0g2ko0008a04wwjmq7m0u","tag_id":"cjsa0g2li001ga04wxqp6z9s4","_id":"cjsa0g2lu001wa04w2de5wfx1"},{"post_id":"cjsa0g2ko0008a04wwjmq7m0u","tag_id":"cjsa0g2lm001na04wzlgzratq","_id":"cjsa0g2lw001za04wixdef07y"},{"post_id":"cjsa0g2kq000aa04wvnuo3mns","tag_id":"cjsa0g2lu001va04wleqdj2d4","_id":"cjsa0g2m2002aa04wvxvcauvd"},{"post_id":"cjsa0g2kq000aa04wvnuo3mns","tag_id":"cjsa0g2lm001na04wzlgzratq","_id":"cjsa0g2m3002ca04wftitxv6h"},{"post_id":"cjsa0g2kt000da04wxx9mfrfo","tag_id":"cjsa0g2m10027a04wupph8q3e","_id":"cjsa0g2m4002fa04wzavjr9rp"},{"post_id":"cjsa0g2kw000ea04wg2ivuv8f","tag_id":"cjsa0g2m3002da04wg5hgrypi","_id":"cjsa0g2m8002na04wysbb8uvy"},{"post_id":"cjsa0g2kw000ea04wg2ivuv8f","tag_id":"cjsa0g2le0019a04wrfnca9bk","_id":"cjsa0g2m8002oa04wjlinpoqi"},{"post_id":"cjsa0g2kw000ea04wg2ivuv8f","tag_id":"cjsa0g2lm001na04wzlgzratq","_id":"cjsa0g2m9002qa04w79ti784f"},{"post_id":"cjsa0g2ky000ia04w4pllyeq6","tag_id":"cjsa0g2m7002ma04w7f1ieuxl","_id":"cjsa0g2ma002sa04wpzgvdxox"},{"post_id":"cjsa0g2ky000ia04w4pllyeq6","tag_id":"cjsa0g2m8002pa04wpn203r2x","_id":"cjsa0g2ma002ta04wg49qlvut"},{"post_id":"cjsa0g2l1000la04wzo4gshr8","tag_id":"cjsa0g2m9002ra04w79c7td9l","_id":"cjsa0g2mb002wa04wx5glyu8l"},{"post_id":"cjsa0g2l1000la04wzo4gshr8","tag_id":"cjsa0g2le0019a04wrfnca9bk","_id":"cjsa0g2mc002xa04wyj0lbzgx"},{"post_id":"cjsa0g2l5000sa04w8magd3vy","tag_id":"cjsa0g2mb002va04wgvkjp2py","_id":"cjsa0g2me0031a04wad9rwv77"},{"post_id":"cjsa0g2l5000sa04w8magd3vy","tag_id":"cjsa0g2mc002ya04wv14rggej","_id":"cjsa0g2me0032a04ws9c0rv9f"},{"post_id":"cjsa0g2l5000sa04w8magd3vy","tag_id":"cjsa0g2md002za04wmpmbhaor","_id":"cjsa0g2mf0034a04wnajtavlz"},{"post_id":"cjsa0g2l6000va04wm2ubwmyu","tag_id":"cjsa0g2la0012a04wyzs3v5ki","_id":"cjsa0g2mh0037a04wzpjitmdw"},{"post_id":"cjsa0g2l6000va04wm2ubwmyu","tag_id":"cjsa0g2me0033a04wij7u4cch","_id":"cjsa0g2mh0038a04w32uimcld"},{"post_id":"cjsa0g2l6000va04wm2ubwmyu","tag_id":"cjsa0g2le0019a04wrfnca9bk","_id":"cjsa0g2mi003aa04ws8wefxqz"},{"post_id":"cjsa0g2l8000ya04wfumpaerw","tag_id":"cjsa0g2lm001na04wzlgzratq","_id":"cjsa0g2mj003ca04wpxmr17yz"},{"post_id":"cjsa0g2l8000ya04wfumpaerw","tag_id":"cjsa0g2mi0039a04wbq6y1w4n","_id":"cjsa0g2mj003da04w9rh7fsw1"},{"post_id":"cjsa0g2l90010a04wwawh6vi7","tag_id":"cjsa0g2mi003ba04w52mx4auz","_id":"cjsa0g2ml003ga04w2n0icrl7"},{"post_id":"cjsa0g2l90010a04wwawh6vi7","tag_id":"cjsa0g2mk003ea04w78c3ni2c","_id":"cjsa0g2ml003ha04wivyfp541"},{"post_id":"cjsa0g2lb0014a04wpz18qtns","tag_id":"cjsa0g2mk003fa04wx3wew9y7","_id":"cjsa0g2mm003ja04w6y7478z0"},{"post_id":"cjsa0g2ld0017a04wjkywxar4","tag_id":"cjsa0g2le0019a04wrfnca9bk","_id":"cjsa0g2mo003na04wzukxrh9v"},{"post_id":"cjsa0g2ld0017a04wjkywxar4","tag_id":"cjsa0g2m9002ra04w79c7td9l","_id":"cjsa0g2mo003oa04wh4qxj4h0"},{"post_id":"cjsa0g2ld0017a04wjkywxar4","tag_id":"cjsa0g2mo003la04wid1wnls4","_id":"cjsa0g2mp003qa04w4gv1b3k9"},{"post_id":"cjsa0g2lf001ca04ww8whl1ir","tag_id":"cjsa0g2lm001na04wzlgzratq","_id":"cjsa0g2mq003ta04wma6g1e7q"},{"post_id":"cjsa0g2lf001ca04ww8whl1ir","tag_id":"cjsa0g2mo003pa04w7ttx9lu3","_id":"cjsa0g2mq003ua04wyddl5183"},{"post_id":"cjsa0g2lf001ca04ww8whl1ir","tag_id":"cjsa0g2mq003ra04wofdbnn85","_id":"cjsa0g2mr003wa04wr4mi95u5"},{"post_id":"cjsa0g2lg001ea04wtv07hd7y","tag_id":"cjsa0g2mq003sa04wa0d2hm9g","_id":"cjsa0g2mr003za04wru28havi"},{"post_id":"cjsa0g2lg001ea04wtv07hd7y","tag_id":"cjsa0g2mr003va04won4tlfhu","_id":"cjsa0g2ms0040a04wi73vsmj8"},{"post_id":"cjsa0g2lg001ea04wtv07hd7y","tag_id":"cjsa0g2mr003xa04w5qqrm1s8","_id":"cjsa0g2ms0042a04wvtgrjijo"},{"post_id":"cjsa0g2li001ha04whxpb19si","tag_id":"cjsa0g2mr003ya04wz17mx4ov","_id":"cjsa0g2mt0044a04wmi9fsn7o"},{"post_id":"cjsa0g2li001ha04whxpb19si","tag_id":"cjsa0g2ms0041a04w4wcgucdc","_id":"cjsa0g2mt0045a04wb08aj6i7"},{"post_id":"cjsa0g2lk001ka04wwn0xjocs","tag_id":"cjsa0g2ms0043a04wxe557yd4","_id":"cjsa0g2mv0048a04wcsvlj4e3"},{"post_id":"cjsa0g2lk001ka04wwn0xjocs","tag_id":"cjsa0g2mu0046a04w7ok12jt5","_id":"cjsa0g2mv0049a04w2fy2q65i"},{"post_id":"cjsa0g2lm001oa04wwj9b3dhv","tag_id":"cjsa0g2mq003sa04wa0d2hm9g","_id":"cjsa0g2mx004ea04wlrx71hgg"},{"post_id":"cjsa0g2lm001oa04wwj9b3dhv","tag_id":"cjsa0g2mr003va04won4tlfhu","_id":"cjsa0g2my004fa04wcimhz2ct"},{"post_id":"cjsa0g2lm001oa04wwj9b3dhv","tag_id":"cjsa0g2mr003xa04w5qqrm1s8","_id":"cjsa0g2my004ha04wf426o0rl"},{"post_id":"cjsa0g2lm001oa04wwj9b3dhv","tag_id":"cjsa0g2mx004ca04wi1hc6e7q","_id":"cjsa0g2my004ia04wko4wlq7h"},{"post_id":"cjsa0g2lp001ra04wg1w5tq1b","tag_id":"cjsa0g2mx004da04wdx6vcs59","_id":"cjsa0g2mz004ka04wz9pivigt"},{"post_id":"cjsa0g2lt001ta04wfw3cur9y","tag_id":"cjsa0g2my004ga04wc66kgju1","_id":"cjsa0g2n0004ma04w693ga9xv"},{"post_id":"cjsa0g2lt001ta04wfw3cur9y","tag_id":"cjsa0g2mz004ja04w2ho8oxme","_id":"cjsa0g2n0004na04wsyrje4jz"},{"post_id":"cjsa0g2lv001xa04wpmlz7xso","tag_id":"cjsa0g2mz004la04wh8fgpv0d","_id":"cjsa0g2n1004qa04w0kx5ez6l"},{"post_id":"cjsa0g2lv001xa04wpmlz7xso","tag_id":"cjsa0g2n0004oa04wbbb2sh0m","_id":"cjsa0g2n1004ra04we8wek5dn"},{"post_id":"cjsa0g2lw0020a04wwb2yltar","tag_id":"cjsa0g2mz004la04wh8fgpv0d","_id":"cjsa0g2n3004ua04w4e39zylm"},{"post_id":"cjsa0g2lw0020a04wwb2yltar","tag_id":"cjsa0g2n1004sa04wv3758jy0","_id":"cjsa0g2n3004va04wgn6io0al"},{"post_id":"cjsa0g2ly0023a04wf3ateqrz","tag_id":"cjsa0g2n2004ta04wixzmngyu","_id":"cjsa0g2n50050a04wnhm0twwu"},{"post_id":"cjsa0g2ly0023a04wf3ateqrz","tag_id":"cjsa0g2n4004wa04wwubes6jq","_id":"cjsa0g2n60051a04wbi5naa7i"},{"post_id":"cjsa0g2ly0023a04wf3ateqrz","tag_id":"cjsa0g2n4004xa04wcy7m2ntv","_id":"cjsa0g2n60053a04wm59qup9h"},{"post_id":"cjsa0g2ly0023a04wf3ateqrz","tag_id":"cjsa0g2n4004ya04w1v99p0vu","_id":"cjsa0g2n70054a04w50ntenes"},{"post_id":"cjsa0g2lz0025a04wa99x3bpo","tag_id":"cjsa0g2ms0043a04wxe557yd4","_id":"cjsa0g2n80056a04wqbheey1l"},{"post_id":"cjsa0g2lz0025a04wa99x3bpo","tag_id":"cjsa0g2n60052a04wnnu9ykgx","_id":"cjsa0g2n80057a04w7frfkzky"},{"post_id":"cjsa0g2m10028a04w04rrisig","tag_id":"cjsa0g2n80055a04w277d3i7v","_id":"cjsa0g2n9005aa04w801jlnji"},{"post_id":"cjsa0g2m10028a04w04rrisig","tag_id":"cjsa0g2n90058a04wik32v1ze","_id":"cjsa0g2na005ba04wf7ocglk6"},{"post_id":"cjsa0g2m10028a04w04rrisig","tag_id":"cjsa0g2n90059a04wu2zx0dfo","_id":"cjsa0g2na005ca04w3ku1g0y3"}],"Tag":[{"name":"DNS解析","_id":"cjsa0g2kl0005a04wkqwil267"},{"name":"LocalDNS","_id":"cjsa0g2kr000ca04worep157p"},{"name":"xcode","_id":"cjsa0g2ky000ha04wspdzqtw7"},{"name":"cocoapods","_id":"cjsa0g2l3000pa04w1mt9zxls"},{"name":"podfile","_id":"cjsa0g2l6000ua04wd8wxpraj"},{"name":"网络","_id":"cjsa0g2la0012a04wyzs3v5ki"},{"name":"底层","_id":"cjsa0g2le0019a04wrfnca9bk"},{"name":"动画","_id":"cjsa0g2li001ga04wxqp6z9s4"},{"name":"UI","_id":"cjsa0g2lm001na04wzlgzratq"},{"name":"性能优化","_id":"cjsa0g2lu001va04wleqdj2d4"},{"name":"欢迎页","_id":"cjsa0g2m10027a04wupph8q3e"},{"name":"OpenGL","_id":"cjsa0g2m3002da04wg5hgrypi"},{"name":"webview","_id":"cjsa0g2m7002ma04w7f1ieuxl"},{"name":"hook","_id":"cjsa0g2m8002pa04wpn203r2x"},{"name":"runtime","_id":"cjsa0g2m9002ra04w79c7td9l"},{"name":"翻译","_id":"cjsa0g2mb002va04wgvkjp2py"},{"name":"优化","_id":"cjsa0g2mc002ya04wv14rggej"},{"name":"国外文献","_id":"cjsa0g2md002za04wmpmbhaor"},{"name":"httpdns","_id":"cjsa0g2me0033a04wij7u4cch"},{"name":"AlertView","_id":"cjsa0g2mi0039a04wbq6y1w4n"},{"name":"Cocoapods","_id":"cjsa0g2mi003ba04w52mx4auz"},{"name":"架构","_id":"cjsa0g2mk003ea04w78c3ni2c"},{"name":"杂谈","_id":"cjsa0g2mk003fa04wx3wew9y7"},{"name":"Hook","_id":"cjsa0g2mo003la04wid1wnls4"},{"name":"屏幕适配","_id":"cjsa0g2mo003pa04w7ttx9lu3"},{"name":"iOS 11","_id":"cjsa0g2mq003ra04wofdbnn85"},{"name":"Hexo","_id":"cjsa0g2mq003sa04wa0d2hm9g"},{"name":"个人博客","_id":"cjsa0g2mr003va04won4tlfhu"},{"name":"网站","_id":"cjsa0g2mr003xa04w5qqrm1s8"},{"name":"热修复","_id":"cjsa0g2mr003ya04wz17mx4ov"},{"name":"JSPath","_id":"cjsa0g2ms0041a04w4wcgucdc"},{"name":"总结","_id":"cjsa0g2ms0043a04wxe557yd4"},{"name":"回味2017展望2018","_id":"cjsa0g2mu0046a04w7ok12jt5"},{"name":"评论插件","_id":"cjsa0g2mx004ca04wi1hc6e7q"},{"name":"Swift","_id":"cjsa0g2mx004da04wdx6vcs59"},{"name":"swift","_id":"cjsa0g2my004ga04wc66kgju1"},{"name":"网络请求","_id":"cjsa0g2mz004ja04w2ho8oxme"},{"name":"git","_id":"cjsa0g2mz004la04wh8fgpv0d"},{"name":"代码版本控制","_id":"cjsa0g2n0004oa04wbbb2sh0m"},{"name":"效率工作","_id":"cjsa0g2n1004sa04wv3758jy0"},{"name":"音频","_id":"cjsa0g2n2004ta04wixzmngyu"},{"name":"唱吧","_id":"cjsa0g2n4004wa04wwubes6jq"},{"name":"K歌","_id":"cjsa0g2n4004xa04wcy7m2ntv"},{"name":"AVFoundation","_id":"cjsa0g2n4004ya04w1v99p0vu"},{"name":"回首2018展望2019","_id":"cjsa0g2n60052a04wnnu9ykgx"},{"name":"算法","_id":"cjsa0g2n80055a04w277d3i7v"},{"name":"C语言","_id":"cjsa0g2n90058a04wik32v1ze"},{"name":"排序","_id":"cjsa0g2n90059a04wu2zx0dfo"}]}}