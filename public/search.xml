<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS Crash防护你看这个就够了 - 上篇]]></title>
    <url>%2F2021%2F05%2F03%2F%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOSCrash%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[0x1 为什么要做Crash防护 在产品开发过程中Crash率是一个很重要的指标，也是一个团队中几乎所有的部门都应该关注或者去参与提升的一个指标，他不仅代表着整个产品的质量，也是一个团队整体技术能力的体现。更低的Crash率不但能让产品获得更好的用户口碑，在整个流程中也能让团队成员获得更多的成长，加深对iOS系统底层的理解，为今后的开发带了更大的帮助。 0x2 为什么要写这篇文章起因也是因为自己的项目踩了FB的SDK的坑：2020.7.10，FB后台下发数据错误，导致大量使用FB SDK的App发生启动Crash，影响用户之多，范围之大，再加上当时包括我们的大部分App也缺乏相关的防护或者是容错处理，Crash率瞬间飙升，重新发版又要走发布流程，只能依赖FB后台的修复，当时束手无策十分被动，所以决定自己做一套较为完整的Crash防护体系，来避免这样的场景再次发生。第二个目的就是，发生问题后我也第一之间查阅了网上的一些资料和其他团队的做法，发现大家的方式各有千秋，方法不同，效果不同，所以我也决定把市面上能找到的好的思路和方法再结合自己的一些想法和经验记录下来。最后也是因为知识是要沉淀、积累和分享的，也算是巩固和加深自己的理解吧。 0x3 怎么做其实当时Crash的场景很简单，本来一个Dictionary参数FB后台却下发了个String类型的数据，这样一来解析时候必然会Crash，解决的话其实只要做一层参数安全校验即可。 但是这么简单的问题，大部分App都没处理好，证明在流程上一定有大家注意不到的地方，暴露出来的只是冰山一角，我们机制一定存在着某种问题，或者存在可以优化的地方。 要想避免这种情况，就要先梳理出处理Crash的流程： I：Crash处理流程 在iOS系统中基本可以总结出这四个步骤， Crash防护 - 通过Hook等手段，对一些类似容器类进行入参校验等措施，来进来避免Crash的发生 Crash拦截 - 如果第一步防护失败，那么在Crash走到这一步就要进行拦截，要让我们发现异常 Crash上报 - 对防护的、捕获的Crash进行防护，生成有效的日志进行上报，尽可能的还原堆栈。 Crash后续流程 - Crash发生后如何做才能最大限度的保护用户体验，如何优雅的Crash II：Crash防护Crash防护方式主要分两种：针对非内存问题通常采用AOP方式，内存问题采用zombie对象的方式， AOP：iOS中AOP的相关知识网上线程的代码也很多，这里就不在赘述，但是在AOP这种频繁调用的场景中就需要注意的地方和坑点比较多。 AOP的影响范围问题：当时用了普通的方式对数组相关的方法进行了Hook，结果上线后发现大量的类似Crash。[UIKeyboardLayoutStar release]: message sent to deallocated instance UIKeyboardLayoutStar 在通过一些其他场景可以判断出是因为HookNSMutableArr的相关方法，导致系统类的调用受到了影响。 通过Xcode调试发现，因为Hook的本质就是在原有的系统调用前插入一个用户自定义的函数进行方法交换，那么在某种极端情况下（比如多线程），传入该函数的变量被释放，这样一来再走到原本系统调用的时候正常释放时就会出现重复释放的情况。大概的流程为 该场景在测试过程中很难复现，但是一旦到了线上，用户量覆盖够大后该问题就会显现出来。解决方式很简单，Hook尽量在MRC下进行，使用autorelease pool进行包装。保证内部变量在当前的runloop结束时候进行释放。 AOP的性能问题：上面说了AOP的原理是会多一层方法调用，那么再结合iOS的方法转发流程可想而知，AOP必定会造成性能的损耗，而且在Crash防护场景下频繁调用，性能问题一定不能忽略。 通过上图看出，方法调用流程最终会返回出对应的IMP指针供外部调用，作为动态语言，OC无法确定开发者会再什么时候插入或者交换哪个函数，所以必须通过这一套流程进行类似校验的逻辑。 使用过AOP的同学一定知道在AOP前会先做一层校验 +(void)hookClass:(Class)classObject isClassMetohd:(BOOL)classMethod fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector &#123; Class class = classObject; Method fromMethod = class_getInstanceMethod(class, fromSelector); Method toMethod = class_getInstanceMethod(class, toSelector); // 添加前进行检测 if (classMethod) &#123; class = object_getClass(classObject); fromMethod = class_getClassMethod(class, fromSelector); toMethod = class_getClassMethod(class, toSelector); &#125; if(class_addMethod(class, fromSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) &#123; class_replaceMethod(class, toSelector, method_getImplementation(fromMethod), method_getTypeEncoding(fromMethod)); &#125; else &#123; method_exchangeImplementations(fromMethod, toMethod); &#125;&#125; 所以在方法我们在上面代码中的toSelector中 当我们需要调用回原方法时直接调用对应的函数指针即可 最终我对直接调用IMP的方法做了测试，分别是Demo中和App中的某一个场景，测试数据如下,对比结果还是较为明显。这也就是为什么Swift或者一些其他静态语言比OC快的原因。 Zombie：使用僵尸对象来解决内存问题一直是苹果主推的方式，Xcode也有相关设置，在Debug下打开相应开关，但是一旦把该功能放到线上做防护或监控就要考虑很多的问题。 zombie入口问题：换句话说就是在哪个地方生成zombie对象，看了一些相关的SDK都是采用Dealloc作为入口函数，不是不行，只是不是最优。原因有两点: 1:苹果已经不建议在ARC下主动调用dealloc，目前只能采用performSelector或者其他动态调用的方式。 2:容易漏掉 Objc_destructInstance，所有的成员变量、属性都会在这个函数中释放，如果漏掉这个函数就会生成一个并不干净的僵尸对象，内存占用过高，白白浪费内存空间。 综上两点我最终选择在Free函数中生成僵尸对象 zombie内存阈值问题：僵尸对象会占用内存空间，然而在线上环境操作内存一定要小心且一定要有一套完整的逻辑，当超过某一个内存阈值后需要及时清空僵尸对象。内存阈值的确定便成了关键，这里会遇到两个问题： 1：内存问题一定会和机型强相关，如何根据不同的机型调整不同的阈值？ 2：如何做到根据线上情况灵活动态调整？ 我们的底线是在加入zombie后不能触发memorywarning，所以我先对大部分机型做了memorywarning阈值测试： 从上图可以看出当App占用内存达到总内存的 57%~69%时候会触发内存警告，而且由于iphone中有一部分内存是系统保留内存并不会给到开发者，所以我们可用的也就50%左右，我总结出如下公式： 公式1：不能触发内存警告 Y = 0.5 * deviceMem – currentAppMem 公式2: 僵尸对象的内存占用再大也不会超过App本身的内存 Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem) 上面两个公式看似完美，但是还是有优化的地方，因为并不是APP中所有的变量都有可能成为僵尸对象，可能只是其中的某一部分需要被监控, 所以得到最终的内存阈值计算公式： Y = min ( ( 0.5 * deviceMem – currentAppMem ) , currentAppMem / N ) 因为app占用内存随时在变，所以可以加一个定时器每隔一定时间去更新该值。 上面公式的 N 还有一个好处就是我们可以后台动态下发，根据线上内存引起Crash量，如果Crash量大，那可能就需要更大的内存阈值去保存僵尸对象，就可以把N调小，反正调大，这样就可以无视机型的差异根据Crash的情况进行远程配置。 通过如图的线上数据可以看出 随着N的减小，zombie的内存阈值在增加，但是并不会超过内存警告阈值，确保了内存健康。 下图表示了不同的N值对应不同的捕获野指针问题的数量，各自App可以根据自己的业务情况进行调整。 zombie更新策略问题：目前大家的做法都是在加入新的zombie对象时候检查是否超过阈值,达到阈值后删掉之前的zombie对象再加入新的对象，这样的清理逻辑是依赖于新zombie对象的加入，如果没有新对象的加入那么缓存空间也不会有变化，zombie空间一旦生成就无法删掉，无法做到缓存的自清理，等于App无故增大了内存占用。 同样借鉴LRU最近最久未使用的逻辑，每隔30s会检测下缓存情况，超过30s还未被使用的zombie对象将被删除，30s是一个经验值，通过大量测试发现，内存问题一般会发生在对象被销毁的30s内，超过30s再出现的概率及小。这样可以做到缓存自清理的逻辑。 通过Instrument测试发现该zombie逻辑并不会对App本身的内存造成太大的影响。 var options = {"narrow":false,"autoplay":true,"showlrc":0,"mutex":true,"music":[{"title":"奔赴星空","author":"尹昔眠","url":" https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E5%B0%B9%E6%98%94%E7%9C%A0%20-%20%E5%A5%94%E8%B5%B4%E6%98%9F%E7%A9%BA.mp3","pic":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimge.kugou.com%2Fstdmusic%2F240%2F20210402%2F20210402114314135880.jpg&refer=http%3A%2F%2Fimge.kugou.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1622613157&t=cd770b23f2e60662dde0e28d397877c8","lrc":"https://歌词.lrc"}]}; options.element = document.getElementById("aplayer8"); new APlayer(options);]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Crash防护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编和栈]]></title>
    <url>%2F2020%2F11%2F28%2F%E6%B1%87%E7%BC%96%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[汇编和栈当一个函数传递了六个以上的参数时，多余的参数将通过堆栈传递。但是在堆栈上传递到底是什么意思呢？现在该通过深入研究一些“与堆栈相关的”寄存器以及堆栈中的内容，来深入探讨从程序集角度调用函数时的情况。当您进行逆向工程程序时，了解堆栈的工作方式非常有用，因为当没有可用的调试符号时，您可以帮助推断出在某个函数中正在操纵哪些参数。在下一单元中，您将使用本章中的知识在LLDB中构建命令，该命令将通过在内存中抓取函数来发现一些有趣的事情。让我们开始吧 让我们重游堆栈正如先前在第6章“线程，框架和遍历”中所讨论的，当程序执行时，内存会被布局，因此栈从“高地址”开始并向下增长，向着低地址增长；也就是说，朝向堆。 之前说过：栈是从 高地址 -&gt; 低地址，堆是从 低地址 -&gt; 高地址，而Windows中栈是在堆的下方，所以Windows中内存是从 中间向两边分布 。 而Linux中 栈是在堆的上面，所以Linux中的内存是 从两边向中间分布 。 很迷惑吗？通过下面这个图片你可以看出栈的移动方式。 栈从高位地址开始。确切地说，它的高度取决于操作系统的内核。内核为每个正在运行的程序（每个线程）提供栈空间。 栈的大小是有限的，并且随着内存地址空间的向下增长而增加。当栈上的空间用完时，指向栈 “顶部” 的指针从最高地址向下移动到最低地址。 一旦栈达到内核给定的有限大小，或者如果栈越过了堆的边界，则称栈溢出。这是一个致命错误，通常称为栈溢出。 栈指针和基本指针寄存器您尚未了解的两个非常重要的寄存器是RSP和RBP。栈指针寄存器RSP指向特定线程的栈头。栈的顶部将向下生长，因此将项目添加到栈时，RSP将减少。 RSP将始终指向栈的头部。下图展示了栈调用时栈指针变化的视觉效果。 在上图中，堆栈指针的顺序如下： 栈指针当前指向第3帧。 指令指针寄存器指向的代码调用一个新函数。堆栈指针将更新为指向Frame 4，该feame可能负责指令指针中此新调用函数中的暂存空间和数据。 函数的具体执行在第4帧中完成，执行完之后指针从第四帧弹出，并继续指向第三帧. 还有一个重要的寄存器是基址指针寄存器（RBP），在执行在方法/函数内部时有多种用途，程序使用RBP的偏移量来访问局部变量或函数参数。之所以能这样是因为RBP在函数序言中的函数开始处被设置为RSP寄存器的值。 有趣的是，基本指针的之前内容在被设置为RSP寄存器的值之前就已存储在栈中。这是函数序言中发生的第一件事。由于基本指针已保存到堆栈中并设置为当前堆栈指针，因此只需知道基本指针寄存器中的值即可遍历堆栈。调试器在向您显示堆栈跟踪时会执行此操作。 请注意：某些系统不使用基本指针，而且他们在编译你的程序的时候也不会出现基础指针。 其实他们的逻辑可能是使用了其他的寄存器来当做指针寄存器。 但这意味着调试变得更加困难。 下面这个图片可以帮助解释。 当一个函数序言完成设置时，RBP的内容将指向堆栈帧下面的前一个RBP 注意：当您通过单击Xcode中的帧或使用LLDB跳到另一个堆栈帧时，RBP和RSP寄存器都将更改值以对应于新的帧！ 这是可以肯定的，因为函数的局部变量是由RBP的偏移量来获取的，如果RBP不变，则您将无法向该函数打印局部变量，甚至可能导致程序崩溃。 在探索RBP和RSP寄存器时，这可能会引起混乱，因此请始终牢记这一点。 您可以通过选择不同的帧并在LLDB控制台中键入cpx $ rbp或cpx $ rsp在LLDB中对此进行验证。 那么，为什么这两个寄存器很重要？ 当使用调试信息编译程序时，调试信息将引用基本指针寄存器中的偏移量以获得变量。 这些偏移量被赋予名称，与您在源代码中为变量赋予的名称相同。编译并优化程序以进行发布时，将打包打包到二进制文件中的调试信息。 尽管删除了这些变量和参数的引用的名称，但是您仍然可以使用堆栈指针和基指针的偏移量来查找这些引用的存储位置。 堆栈相关的操作码到目前为止，您已经了解了调用约定以及内存的布局方式，但是还没有真正探究许多操作码在x64汇编中的实际作用。 现在是时候更详细地介绍几种与堆栈相关的操作码了。 操作码 push当需要将诸如int，Objective-C实例，Swift类或引用之类的任何内容保存到堆栈时，将使用 push 操作码。 push递减堆栈指针（请记住，因为堆栈向下增长），然后存储到新RSP指针所指向的内存地址里面。 push 指令后，最新推送的值将位于RSP指向的地址。 而先前的值应为RSP加上最近推送的值的大小—–对于64位体系结构，通常为8个字节。要查看具体示例，请考虑以下操作码： push 0x5 这将使RSP递减，然后将值5存储在RSP指向的内存地址中。 因此，用C伪代码： RSP = RSP - 0x8 *RSP = 0x5 操作码 poppop 操作码与 push 操作码完全相反。 pop从RSP寄存器中获取值并将其存储到目的地。 接下来，RSP递增0x8，还是那句话 栈是从大到小的增长，所以递增以下是 pop 的示例： pop rdx 这将RSP寄存器的值存储到RDX寄存器中，然后递增RSP寄存器。 这是下面的伪代码： RDX = *RSP RSP = RSP + 0x8 操作码 callcall 操作码负责执行功能。 call 将在被调用函数完成后将要返回的地址压入； 然后跳转到该函数。想象一下内存中位于0x7fffb34df410的函数，如下所示： 0x7fffb34de913 &lt;+227&gt;: call 0x7fffb34df410 0x7fffb34de918 &lt;+232&gt;: mov edx, eax 当执行一条指令时，首先将RIP寄存器递增，然后执行该指令。 因此，当执行调用指令时，RIP寄存器将递增至0x7fffb34de918，然后执行0x7fffb34de913指向的指令。 由于这是一条调用指令，因此将RIP寄存器压入堆栈（就像执行了压入一样），然后将RIP寄存器设置为值0x7fffb34df410，即要执行的功能的地址。伪代码类似于以下内容： RIP = 0x7fffb34de918 RSP = RSP - 0x8 *RSP = RIP RIP = 0x7fffb34df410 之后，在位置0x7fffb34df410处继续。 操作码 retret 操作码与 call 相反，它从栈顶弹出栈顶值（如果程序集的push和pops匹配，它将是调用操作码推入的返回地址），然后将RIP寄存器设置为此地址。 因此，该操作可以返回到调用该函数的位置。 现在，您已经对这四个重要的操作码有了基本的了解，是时候看看它们在起作用了。确保所有 push 操作码都与您的 pop 相匹配非常重要，否则堆栈将不同步。 例如，如果没有相应的 pop 消息用于弹出，则当在函数末尾执行 ret 时将弹出错误的值。 该操作将返回到某个随机位置，甚至可能不在程序中的有效位置。幸运的是，编译器将负责同步您的 push 和 pop 操作码。 您只需要在编写自己的程序集时担心这一点。 在一些操作中观察RBP和RSP寄存器现在，您已经了解了RBP和RSP寄存器以及操纵堆栈的四个操作码，现在是时候看看它们的作用了。在Registers应用程序中，存在一个名为StackWalkthrough（int）的函数。此C函数将一个整数作为参数，并用汇编语言编写（AT＆T汇编语言，记住要能够找到源操作数和目标操作数的正确位置），并且位于StackWalkthrough.s中。打开此文件，环顾四周；无需立即了解所有内容。您将在一分钟内了解其工作原理。通过桥接标头Registers-Bridging-Header.h，Swift可以使用此函数，因此您可以从Swift调用以汇编方式编写的此方法。现在利用这一点。打开ViewController.swift，并在viewDidLoad（）下面添加以下内容： viewDidLoad(): override func awakeFromNib() { super.awakeFromNib() StackWalkthrough(5) } 这将给StackWalkThrough传入了参数5。5仅是一个用于显示堆栈工作方式的值。在深入研究RSP和RBP之前，最好快速了解一下StackWalkthrough中发生的事情。在StackWalkthrough函数上创建一个符号断点。 构建并运行。Xcode会在StackWalkthrough中中断。一定要通过source”查看StackWalkthrough函数(即使它是汇编)。通过源代码查看函数将显示AT&amp;T汇编(因为它是用AT&amp;T ASM编写的)。Xcode将显示以下程序集: push %rbp ; Push contents of RBP onto the stack (*RSP = RBP, RSP decreases) movq %rsp, %rbp ; RBP = RSP movq $0x0, %rdx ; RDX = 0 movq %rdi, %rdx ; RDX = RDI push %rdx ; Push contents of RDX onto the stack (*RSP = RDX, RSP decreases) movq $0x0, %rdx ; RDX = 0 pop %rdx ; Pop top of stack into RDX (RDX = *RSP, RSP increases) pop %rbp ; Pop top of stack into RBP (RBP = *RSP, RSP increases) ret ; Return from function (RIP = *RSP, RSP increases) 上面的输出中已经为您添加了注释来帮助理解发生了什么。通读一遍，如果可以的话，试着理解它。您已经熟悉了mov指令，程序集的其余部分由您刚刚了解的与函数相关的操作码组成。这个函数接受传入的整型参数(您还记得，第一个参数是在RDI中传入的)，将其存储到RDX寄存器中，并将该参数压入堆栈。然后将RDX设置为0x0，然后将从堆栈中 pop 的值存储回RDX寄存器。请确保您在心里很好地理解这个函数中发生了什么，因为接下来您将研究LLDB中的寄存器。回到Xcode中，在ViewController.swift的awakeFromNib函数的StackWalkthrough(5)行中使用Xcode的GUI创建一个断点。保留前面的StackWalkthrough符号断点，因为在研究寄存器时，您需要在StackWalkthrough函数的开始处停止。构建和运行并等待GUI断点触发。 现在通过 Debug\Debug Workflow\Always Show Disassembly 菜单让他以汇编形式展示，您将看到很可怕的东西： 哇！ 看那个！ 您已经正确进入了 call 操作码指令。 您是否想知道要输入什么功能？ 从这里开始，您将逐步完成每条汇编指令，同时打印出感兴趣的四个寄存器：RBP，RSP，RDI和RDX。 为了解决这个问题，在LLDB中输入以下内容 (lldb) command alias dumpreg register read rsp rbp rdi rdx 这将创建命令dumpreg，它将dump四个感兴趣的寄存器。现在执行dumpreg: (lldb) dumpreg 然后你将看到一些熟悉的东西 rsp = 0x00007fff5fbfe820 rbp = 0x00007fff5fbfe850 rdi = 0x0000000000000005 rdx = 0x0040000000000000 在本节中，dumpreg的输出将覆盖在每个汇编指令上，以准确显示每个指令期间每个寄存器发生的情况。 同样，即使为您提供了这些值，您自己执行和理解这些命令也很重要。您的屏幕将类似于以下内容： 一旦跳入函数调用，请密切注意RSP寄存器，因为一旦RIP跳到StackWalkthrough的开头，它就会发生变化。 如您先前所知，RDI寄存器将包含第一个参数的值，在这种情况下为0x5。在LLDB中，键入以下内容： (lldb) si 这个命令是单步调试的命令，它告诉LLDB执行下一条指令，然后暂停调试器。现在，您已进入StackWalkthrough。 对于每一步，再次使用dumpreg转储寄存器。 请注意RSP寄存器中的差异。 RSP指向的值现在将包含前一个函数的返回地址。 对于此特定示例，指向0x7fff5fbfe758的RSP将包含值0x100002455-awakeFromNib中紧随调用之后的地址。现在通过LLDB进行验证： (lldb) x/gx $rsp 输出将与awakeFromNib中调用操作码之后的地址立即匹配。接下来，执行si，然后执行下一条指令的dumpreg。 RBP的值被压入堆栈。 这意味着以下两个命令将产生相同的输出。 执行两个都进行验证。 (lldb) x/gx $rsp 这将查看栈指针寄存器所指向的内存地址。 注意：等等，我只是在没有上下文的情况下向您抛出了一条新命令。 x命令是内存读取命令的快捷方式。/ gx表示以十六进制格式将内存格式化为一个巨大的字（8个字节，还记得第11章“汇编和内存”中的术语吗？）。奇怪的格式是由于该命令在gdb中的常用，您看到此命令语法已移植到lldb中，从而使从调试器的转换更加容易。 现在看一下基础指针寄存器的值 (lldb) p/x $rbp 接下来让我继续单步调试 基础指针被分配给堆栈指针的值。 使用dumpreg以及以下LLDB命令验证两者的值相同： (lldb) p (BOOL)($rbp == $rsp) 请务必在表达式两边加上括号，否则LLDB无法正确解析它。再次执行si和dumpreg。 这次看起来像这样： RDX 寄存器被清零了，我们继续单步调试 RDX 被设置为RDI，你可以用dumper继续验证 RDX被推入堆栈。 这意味着堆栈指针已递减，并且RSP指向一个值，该值将指向0x5的值。 确认下： (lldb) p/x $rsp 这显示了指向RSP的当前值。 这意味着什么？ (lldb) x/gx $rsp 您将得到 0x5。 再次输入si以执行下一条指令： RDX设置为0x0。 这里没有什么太令人兴奋的，继续前进…继续前进。 再次输入si和dumpreg： 堆栈的顶部 pop 到RDX中，您知道最近将其设置为0x5。 RSP递增0x8。 再次输入si和dumpreg： 基本指针从堆栈中 pop，并重新分配回它进入该函数时的原始值。 调用规则指定RBP在函数调用之间应保持一致。 也就是说，RBP离开职能后便无法更改为其他值，所以我们做一个好公民，恢复它的原来的值。 进入ret操作码。 注意即将更改的RSP值。 再次输入si和dumpreg： 返回地址从堆栈中pop并设置为RIP寄存器； 您知道这一点，因为您已经回到了调用该函数的位置。 然后，控制会在awakeFromNib中恢复，哇！ 那很有趣！ 一个简单的功能，但是它说明了堆栈如何通过调用，推入，弹出和退出指令工作。 栈和7个以上的参数如第10章所述，x86_64的调用规则将按顺序使用以下寄存器作为函数参数：RDI，RSI，RDX，RCX，R8，R9。 当一个函数需要六个以上的参数时，需要使用堆栈。注意：当将大型结构传递给函数时，可能还需要使用堆栈。 每个参数寄存器只能保存8个字节（在64位体系结构上），因此，如果该结构需要8个以上的字节，则也需要在堆栈上传递该结构。 有严格的规则规定他们的调用方式，所有编译器都必须遵守。 打开ViewController.swift并找到名为executeLotsOfArguments的函数。 您在第10章中使用了此功能来浏览寄存器。 现在，您将再次使用它，以了解如何将参数7及其以后的参数传递给该函数。将以下代码添加到viewDidLoad的末尾： _ = self.executeLotsOfArguments(one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10) 接下来，使用Xcode GUI在刚添加的行上创建一个断点。 生成并运行该应用程序，然后等待该断点出现。 您应该再次看到反汇编视图，但如果没有，请使用“始终显示反汇编”选项。 正如您在与堆栈相关的操作码一节中了解到的，call负责函数的执行。因为在RIP现在的位置和viewDidLoad的结束之间只有一个调用操作码，这意味着这个调用必须负责调用executeLotsOfArguments但是调用前的其他指令是什么呢?让我们找出答案。这些指令根据需要设置堆栈以传递附加参数。你有你通常的6个参数被放入适当的寄存器，正如看到的指令在哪里RIP现在，从mov edx, 0x1开始。但是参数7和以上需要在堆栈上传递。这可以通过以下说明来完成: 0x1000013e2 &lt;+178&gt;: mov qword ptr [rsp], 0x7 0x1000013ea &lt;+186&gt;: mov qword ptr [rsp + 0x8], 0x8 0x1000013f3 &lt;+195&gt;: mov qword ptr [rsp + 0x10], 0x9 0x1000013fc &lt;+204&gt;: mov qword ptr [rsp + 0x18], 0xa 看起来很吓人，我会解释。包含RSP和可选值的方括号表示取消引用，就像C编程中的*一样。上面的第一行说“将0x7放入RSP指向的内存地址中。”第二行说“将0x8放入RSP所指向的内存地址加0x8。”等等。这会将值放入堆栈。但是请注意，没有使用push指令显式推送这些值，这会减少RSP寄存器。这是为什么？ 嗯，如您所知，在调用指令期间，返回地址被压入堆栈。然后，在函数序言中，将基本指针压入堆栈，然后将基本指针设置为堆栈指针。您还没有学到的是，编译器实际上会在堆栈上留出“暂存空间”的空间。也就是说，编译器根据需要在堆栈上为局部变量分配空间。通过在函数序言中查找sub rsp，VALUE指令，可以轻松确定是否为堆栈帧分配了额外的暂存空间。例如，单击viewDidLoad堆栈框架并滚动到顶部。观察已创建多少暂存空间： 看看一个变量指向的值……它现在肯定不能保持0x1的值.为什么一个引用一个看似随机的值?答案是由嵌入到寄存器应用程序的调试构建中的DWARF调试信息存储。你可以把这些信息转储到内存中，帮助你了解一个变量在引用什么。LLDB中输入以下 (lldb) image dump symfile Registers 你会得到大量的输出。搜索(Cmd + F)单词“one”;在搜索的时候加上引号。然后会有如下输出 Swift.String, type_uid = 0x300000222 0x7f9b4633a988: Block{0x300000222}, ranges = [0x1000035e0-0x100003e7f) 0x7f9b48171a20: Variable{0x30000023f}, name = &quot;one&quot;, type = {d50e000003000000} 0x00007f9b4828d2a0 (Swift.Int), scope = parameter, decl = ViewController.swift:39, location = DW_OP_fbreg(-32) 根据输出，名为execute.Int的变量位于executeLotsOfArguments中，其位置可以在DW_OP_fbreg（-32）中找到。 这个相当模糊的代码实际上意味着基本指针减去40，即RBP-32。或者以十六进制表示，RBP-0x20。 这是重要的信息。 它告诉调试器，始终可以在此内存地址中找到名为one的变量。 嗯，并非总是如此，但总是在该变量有效时（即它在范围内）。 您可能想知道为什么它不能只是RDI，因为那是将值传递给函数的地方，并且它也是第一个参数。 好了，RDI稍后可能需要在函数中重用，因此使用堆栈是更安全的选择。 调试器仍应在executeLotsOfArguments上停止。 确保您正在查看“始终显示汇编”输出并寻找汇编。 应该是第16行： mov qword ptr [rbp - 0x20], rdi 一旦在executeLotsOfArguments的汇编输出中找到它，就在该程序行上创建一个断点。继续执行，以使LLDB停止在这一行汇编上。 打印一个输出 (lldb) po one 还是乱码。 mph记住，RDI将包含传递给函数的第一个参数。 因此，为了使调试器能够看到应该为1的值，需要将RDI写入存储1的地址。 在这种情况下，RBP-0x20。现在，在LLDB中执行汇编指令步骤： (lldb) si (lldb) po one 噢！…是的！ 工作正常！ 所引用的值1正确持有值0x1。您可能想知道如果改变一个会发生什么。 好吧，在这种情况下，RBP-0x20也需要更改。 这可能是需要在其中写入该值以及在何处使用它的另一条指令。 这就是为什么调试版本比发行版本要慢得多的原因。 栈的探索不用担心 本章即将完成。 但是，在堆栈探索中应该记住一些非常重要的要点。如果您已经在使用函数，并且该函数已经完成了函数序言，则以下各项将适用于x64程序集： RBP将指向此功能的堆栈帧的开始地方。 RBP将包含前一个堆栈帧的起始地址。 （在LLDB中使用x / gx $ rbp进行查看）。 （RBP + 0x8）将指向堆栈跟踪中前一个函数的返回地址（在LLDB中使用x / gx’$ rbp + 0x8’进行查看）。 （RBP + 0x10）将指向第7个参数（如果有）。 （RBP + 0x18）将指向第8个参数（如果有）。 （RBP + 0x20）将指向第9个参数（如果有）。 （RBP + 0x28）将指向第十个参数（如果有）。 RBP-X，其中X是0x8的倍数，将引用该函数的局部变量。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编和内存]]></title>
    <url>%2F2020%2F11%2F21%2F%E6%B1%87%E7%BC%96%E5%92%8C%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[汇编和内存你已经开了汇编学习的旅程，并且在前几章中你已经学习了汇编调用的一些黑魔法，你现在知道了，当一个函数被调用，他的参数和返回值是如何传递的。但是您还没学到的是将代码加载到内存后如何执行代码。 在本章中，您将探索程序的执行方式。 您将看到一个特殊的寄存器，该寄存器用于告诉处理器应该从何处读取下一条指令，以及不同大小和内存分组如何产生截然不同的结果。 设置英特尔风格汇编体验™如上一章所述，显示汇编有两种主要方法。 一种类型是AT＆T程序集，这个也是LLDB的默认程序集。 这种格式具有以下格式： opcode（操作码） source（源） destination（目的地） 看一个具体的例子 movq $0x78, %rax 这个操作会将十六进制值 0x78 移动到 RAX 寄存器中。 尽管这种汇编形式对某些人来说很不错，但从现在开始，您将使用英特尔的表示形式。 注意：汇编的选择有点像一场大战，有的人说用Inter的格式，有的说是用AT&amp;T的格式，在StackOverflow中查看以下讨论选择使用英特尔是因为大家都觉得英特尔在阅读方面更好，但有时在写作方面更差。 由于您正在学习调试，因此大部分时间是在阅读汇编而不是编写汇编。 把以下的两行内容添加进 ~/.lldbinit file 文件底部 settings set target.x86-disassembly-flavor intel settings set target.skip-prologue false 第一行告诉LLDB以Intel风格显示x86汇编（32位和64位）。第二行告诉LLDB不要跳过函数序言。 您在本书的前面已经了解了这一点，从现在开始，请不要跳过序言，因为您将直接从函数的第一条指令检查汇编。 关于函数序言和函数尾声可以再参考这篇文章 注意：在编辑〜/ .lldbinit文件时，请确保您不使用TextEdit之类的程序，因为它将在文件中添加不必要的字符，这可能导致LLDB无法正确解析该文件。 一种简单（尽管很危险）的添加方法是通过如下的Terminal命令：echo“ settings set target.x86-disassembly-flavor intel” &gt;&gt;〜/ .lldbinit。确保其中有两个“ &gt;&gt;”，否则将覆盖〜/ .lldbinit文件中的所有先前内容。 如果您对终端机不满意，最好的选择是nano（您之前使用过的编辑器）。 英特尔风格将交换源值和目标值，删除’％’和’$’字符以及进行许多其他许多更改。 由于您还不会使用AT＆T语法，因此这里就不解释全部的差异，我们只单单学习Inter程序集就够了。 看下面的示例，就是以Inter风格来展示，他看起来比较干净，比较好阅读。 mov rax, 0x78 同样，这会将十六进制值0x78移到RAX寄存器中。与前面显示的AT＆T风格相比，Intel风格交换了源操作数和目标操作。 现在，目标操作数在源操作数之前。 在进行汇编时，务必始终确定正确的风格，这很重要，因为如果您不清楚要使用的风格，则可能会采取不同的操作。 从现在开始，我们就开始使用Inter的汇编格式了。 如果您看到以$字符开头的数字十六进制常量或以％开头的寄存器，你就要把他们转换成Inter的形式 注:笔者反而觉得AT&amp;T的风格更适合中国汉语的语法，只是前面的 % 和$有些奇怪罢了 创建cpx命令首先，您将创建自己的LLDB命令，之后会用到。再次打开〜/ .lldbinit（vim）。 然后将以下内容添加到文件底部： command alias -H “Print value in ObjC context in hexadecimal” -h “Print in hex” – cpx expression -f x -l objc – cpx是一个便捷命令，您可以使用Objective-C上下文以十六进制格式打印出某些内容。 尤其是在打印出寄存器内容时会用到。请记住，寄存器在Swift上下文中不可用，因此您需要使用Objective-C上下文。现在，您已经具有从汇编的角度探讨本章内容所需的工具！ 位，字节和其他术语在开始探索内存之前，您需要了解一些有关内存分组方式的词汇。 位 ：可以包含1或0的值称为位。您可以说在64位体系结构中每个地址有64位。很简单。 字节：当8位组合在一起时，它们称为字节。一个字节可以容纳多少个唯一值？您可以通过计算2 ^ 8（从0开始到255的256个值）来确定。 许多信息以字节表示。例如，C语言中 sizeof（）函数以字节为单位返回对象的大小。 如果您熟悉ASCII字符编码，您会想起所有ASCII字符都可以保存在一个字节中。现在是时候看看实际操作中的术语并学习一些技巧。打开Registers macOS应用程序，您将在本章的资源文件夹中找到该应用程序。接下来，构建并运行该应用程序。一旦运行，请暂停程序并启动LLDB控制台。这将导致使用非Swift调试上下文，因为默认情况下暂停应用程序会带来非Swift上下文。在LLDB中键入以下内容： p sizeof(‘A’) 这将打印出组成’A’字符所需的字节数 (unsigned long) $0 = 1 然后输入如下命令 p/t ‘A’ 你会得到 (char) $1 = 0b01000001 这是ASCII中字符A的二进制表示。显示信息字节的另一种更常见的方法是使用十六进制值。 需要两个十六进制数字以十六进制表示一个信息字节。 然后我们输入以下命令来打印出“ A”的十六进制表示形式： p/x ‘A’ 你将会得到 (char) $2 = 0x41 十六进制非常适合查看内存，因为一个十六进制数字恰好代表4位。 因此，如果您有2个十六进制数字，则您有1个字节。 如果您有8个十六进制数字，则您有4个字节。 等等。这里还有一些适用于您的术语，这些术语在以后的章节中会很有用： Nybble：4位，十六进制单个值 Half word：16位或2个字节 Word：32位或4个字节 Double word or Giant word：64位或8字节。 使用此术语，您将可以探索不同的内存块。 RIP寄存器当程序执行时，将要执行的代码加载到内存中。 程序中接下来要执行的代码的位置由一个非常重要的寄存器决定：RIP或指令指针寄存器。让我们来看看实际情况。 再次打开“register demo”应用程序，然后导航到AppDelegate.swift文件。 修改文件，使其包含以下代码： @NSApplicationMain class AppDelegate: NSObject, NSApplicationDelegate { func applicationWillBecomeActive( _ notification: Notification) { print(&quot;\(#function)&quot;) self.aBadMethod() } func aBadMethod() { print(&quot;\(#function)&quot;) } func aGoodMethod() { print(&quot;\(#function)&quot;) } } 构建并运行该应用程序。 毫无疑问，控制台将会输出 该方法名 applicationWillBecomeActive（_ :) ，然后输出 aBadMethod 。我们在在aBadMethod的开始处创建一个断点： 再次构建并运行。 在aBadMethod的开头命中断点后，导航至Debug \ Debug Workflow \ Always Show Disassembly in Xcode。 现在，您将看到程序的实际汇编！ 然后我们在控制台输入以下命令： cpx $rip 这将使用您先前创建的cpx命令打印出指令指针寄存器。您会注意到输出LLDB的地址与Xcode中绿线突出显示的地址是一样的： (unsigned long) $1 = 0x0000000100008910 当然了每个人的电脑上显示的地址是不同的，而且每次执行时候的地址都可能不一样，但是在单次运行中绿线和控制台上显示的肯定是完全一样的。你试着在控制台下打以下命令： (lldb) image lookup -vrn ^Registers.*aGoodMethod 这是一个很常用的查找命令，其中包含典型的正则表达式参数以及添加的参数 -v ，该参数输出详细信息就像 --verbose。您会看到很多的东西。 在控制台中使用 command + F 来搜索关键字 range = [ 其中范围中的第一个值便是 该地址称为加载地址。 这是此函数在内存中的实际物理地址!这与您在image lookup 命令中看到的常规输出不同，它仅显示函数相对于可执行文件的偏移量，也称为实现偏移量。 寻找函数地址时，区分加载地址和可执行文件中的实现偏移很重要，因为它会有所不同。 将这个新地址复制到范围括号的开头。 对于此特定示例，aGoodMethod的加载地址位于0x0000000100008910。 现在将aGoodMethod的地址指向RIP寄存器。输入以下指令 register write rip 0x0000000100008910 单击继续，使用Xcode调试按钮单击“继续”。 请一定用Xcode的按钮来继续，不要是用 continue 命令，因为在修改RIP寄存器并在控制台中继续操作时就会崩溃。按下Xcode继续按钮后，您会看到神奇的事情 -&gt; 未执行aBadMethod（），而是执行了aGoodMethod（）。 通过查看控制台日志中的输出来验证这一点。 注意：修改RIP寄存器实际上非常危险。 您需要确RIP寄存器上的数据不会再被使用了，因为新功能将对RIP寄存器做出不正确的假设。 由于aGoodMethod和aBadMethod在功能上非常相似，因此您从一开始就停了下来，并且由于没有对Registers应用程序进行任何修改，因此不必担心。 寄存器和比特分解如上一章所述，x64具有16个通用寄存器：RDI，RSI，RAX，RDX，RBP，RSP，RCX，RDX，R8，R9，R10，R11，R12，R13，R14和R15。为了保持与i386的32位架构等以前的体系结构的兼容性，可以将寄存器分为32位，16位或8位值。 对于具有不同体系结构历史的寄存器，寄存器名称中的最前面的字符确定寄存器的大小。 例如，RIP寄存器以R开头，它表示64位。 如果您希望使用等效于RIP寄存器的32位，则可以将R字符换成E，以获得EIP寄存器。 为什么这些有用？ 因为使用寄存器时，有时传递到寄存器的值不需要全部使用64位。 例如，考虑布尔数据类型：您真正需要的只是1或0以指示是或否（尽管实际上，布尔值将占用寄存器一个字节）。 基于语言的功能和约束，编译器知道这一点，有时只会将信息写入寄存器的某些部分。让我们来看看实际情况。删除Registers项目中的所有断点。 生成并运行项目。 现在，让程序暂停。输入以下内容： register write rdx 0x0123456789ABCDEF 这会将值写入RDX寄存器。让我们停一分钟。 提示：您应该注意，写入寄存器可能会导致程序崩溃，尤其是当您希望写入的寄存器具有某种类型的数据时。 但是你现在是在demo上做调试，所以请不要担心您的程序是否崩溃！确认此值已成功写入RDX寄存器： p/x $rdx 输出 (unsigned long) $0 = 0x0123456789abcdef 然后输入 p/x $dx 这将打印出DX寄存器，该寄存器是EDX寄存器的最低有效部分。 因此，这是一个半字。 您应该看到以下内容： 0xcdef 再输入 p/x $dl 这将打印出DL寄存器，它是DX寄存器的最低有效位-这次是一个字节。 您应该看到以下内容 0xef 最后输出如下指令 p/x $dh 这为您提供了DX寄存器的最高有效部分，即DL给出的另一半。 DL中的L代表“低”而DH中的H代表“高”也就不足为奇了。探索汇编时，请注意不同尺寸的寄存器。 寄存器的大小可以为其中包含的值提供线索。 例如，您可以轻松地查找通过AL寄存器返回布尔值的函数，因为布尔值将使用8个字节，而AL是64位“返回值寄存器” RAX的8位部分 寄存器 R8 到 R15由于R8至R15系列寄存器仅针对64位架构而创建，因此它们使用完全不同的格式表示较小的寄存器。 现在，您将看下R9的不同大小如何选择。生成并运行Registers应用程序，然后暂停调试器。像以前一样，将相同的十六进制值写入R9寄存器： register write $r9 0x0123456789abcdef 输入以下内容，以确认您已设置R9寄存器成功： p/x $ r9 输入以下内容，这将打印R9寄存器的低32位。请注意，它与您为RDX指定低32位（即EDX）的方式有何不同。 p/x $ r9d 然后输入以下内容，这次您获得R9的低16位。同样，这与您为RDX进行此操作的方式不同 p/x $ r9w 再输入以下内容，打印出R9的低8位 p/x $ r9l 尽管这看起来有些乏味，但是您正在建立阅读汇编语言的技巧。 内存中断现在，您已经了解了指令指针，是时候进一步探索其背后的内存了。顾名思义，指令指针实际上是一个指针。它不执行RIP寄存器中存储的指令，而是执行RIP寄存器中指向的指令。 在LLDB中看到这一点也许会更好地描述它。返回Registers应用程序中，打开AppDelegate.swift并再次在aBadMethod上设置一个断点。生成并运行该应用程序。 命中断点并停止程序后，导航回到汇编视图。如果您忘记了该操作，但尚未为其创建键盘快捷键，则可以在Debug \ Debug Workflow \ Always Show Disassembly下找到它。您会看到一堆汇编指令。看一下RIP寄存器的位置，该位置应指向函数的最开始。对于该项目，aBadMethod的起始地址始于0x100008910。和往常一样，您的地址可能会有所不同。在LLDB控制台中，键入以下内容： cpx $rip 到现在为止，这将打印出指令指针寄存器的内容。如预期的那样，您将获得aBadMethod起始地址。 但是同样，RIP寄存器指向内存中的值。 它指的是什么？ 嗯，您可以摆脱疯狂的C编码技巧（您还记得吗？）并取消引用指针，但是使用LLDB可以找到一种更为优雅的方法。输入以下内容，将地址替换为您的aBadMethod函数的地址： memory read -fi -c1 0x100008910 哇，该命令到底能做什么？ memory read 采用一个值，并读取您提供的内存地址所指向的内容。 -f 命令是一个格式参数。 在这种情况下，它是汇编指令格式。 最后，您说的是只希望使用count或-c参数打印一条汇编指令。您将获得类似于以下内容的输出： -&gt; 0x1000017c0: 55 pushq %rbp 这是一些很好的输出。 它告诉您十六进制（0x55）中提供的汇编指令以及操作码，这些指令是 pushq ％rbp 操作 注意：等等，您看到’％’吗？！ LLDB中存在一个错误，当您以指令格式打印代码时，该错误不符合您的汇编风格。 请记住，如果您看到这种情况，则源和目标操作数将被反转！这就是inter指令集和AT&amp;T指令集的区别。 让我们再看一下输出中的 “ 55”。 这是整个指令（即整个pushq ％rbp）的编码。 不相信我吗？ 您可以验证它。 在LLDB中输入以下内容： expression -f i -l objc – 0x55 这实际上要求LLDB将0x55解释为x64操作码。 您将获得以下输出： $1 = 55 pushq％rbp 该命令有点长，但这是因为如果您在Swift调试上下文中，则需要切换到Objective-C上下文。 但是，如果移至Objective-C调试上下文，则可以使用简短得多的便捷表达式。 尝试单击Xcode左侧面板中的其他框架，以进入一个不包含Swift或Objective-C / Swift桥接代码的Objective-C上下文。 单击Objective-C函数中的任何框架。 下一步，在LLDB控制台中键入以下内容： p/i 0x55 好多了，对吧？现在，回到手中的应用程序。 在LLDB中键入以下内容，再次用aBadMethod函数地址替换地址： memory read -fi -c10 0x1000017c0 你讲获得以下输出： -&gt; 0x100008910: 55 pushq %rbp 0x100008911: 48 89 e5 movq %rsp, %rbp 0x100008914: 48 81 ec c0 00 00 00 subq $0xc0, %rsp 0x10000891b: 4c 89 6d f8 movq %r13, -0x8(%rbp) 0x10000891f: b8 01 00 00 00 movl $0x1, %eax 0x100008924: 89 c7 movl %eax, %edi 0x100008926: e8 d5 05 00 00 callq 0x100008f00 ; symbol stub for: generic specialization &lt;preserving fragile attribute, Any&gt; of Swift._allocateUninitializedArray&lt;A&gt;(Builtin.Word) -&gt; (Swift.Array&lt;A&gt;, Builtin.RawPointer) 0x10000892b: 48 89 c7 movq %rax, %rdi 0x10000892e: 48 89 45 a8 movq %rax, -0x58(%rbp) 0x100008932: 48 89 55 a0 movq %rdx, -0x60(%rbp) 这里需要注意一些有趣的事情：汇编指令的长度可以变化。 看一下第一条指令，然后看输出中的其余指令。 第一条指令的长度为1个字节，用0x55表示。 以下指令的长度为三个字节。确保您仍在Objective-C上下文中，并尝试打印出负责此指令的操作码。 它只有三个字节，所以您只需将它们连接在一起 p/i 0x4889e5 您将获得与 mov ％rsp，％rbp 指令完全无关的另一条指令！ 您会看到以下内容： e5 89 inl $0x89, %eax 是怎么做到的呢？ 也许现在是谈论字节序的好时机。 字节序…这东西倒过来了x64以及ARM系列体系结构设备均使用低位字节序，这意味着数据以最低有效字节在先的形式存储在内存中。 如果要将数字0xabcd存储在内存中，则会先存储0xcd字节，然后再存储0xab字节。回到指令示例，这意味着指令0x4889e5将以0xe5、0x89、0x48的形式存储在存储器中。返回到您先前遇到的mov指令，请尝试反转用于构成汇编指令的字节。 在LLDB中输入以下内容： p/i 0xe58948 您现在将获得预期的汇编表示： $2 = 48 89 e5 movq %rsp, %rbp 让我们再看看一些小端实践的例子。 在LLDB中输入以下内容： memory read -s1 -c20 -fx 0x100008910 此命令读取地址为0x100008910的内存。 -s1选项可读取1个字节的大小块，-c20选项可读取20个字节的大小块。 您会看到类似这样的内容： 0x100008910: 0x55 0x48 0x89 0xe5 0x48 0x81 0xec 0xc0 0x100008918: 0x00 0x00 0x00 0x4c 0x89 0x6d 0xf8 0xb8 0x100008920: 0x01 0x00 0x00 0x00 现在，将大小增加一倍，数量减少一半，就像这样： memory read -s2 -c10 -fx 0x100008910 你会看到这样的输出 0x100008910: 0x4855 0xe589 0x8148 0xc0ec 0x0000 0x4c00 0x6d89 0xb8f8 0x100008920: 0x0001 0x0000 请注意，当将内存值分组在一起时，由于使用了低位字节序，它们将被颠倒。现在，将大小再增加一倍，数量再减少一半： memory read -s4 -c5 -fx 0x100008910 然后你会看到如下输出 0x100008910: 0xe5894855 0xc0ec8148 0x4c000000 0xb8f86d89 0x100008920: 0x00000001 与之前的输出相比，这些值再次被颠倒。记住这一点非常重要，但在探索你自己的记忆时，这会让你变得很混乱。不仅内存的大小会给您一个潜在的错误答案，而且顺序也会给您一个潜在的错误答案。当你开始对着电脑大喊大叫时，当你试图弄清楚某样东西应该如何工作时，请记住这一点!]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编寄存器的规则]]></title>
    <url>%2F2020%2F11%2F19%2F%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[汇编寄存器的规则在本章中，您将了解到CPU使用的寄存器，并研究和修改传入函数的参数。您还将了解常见的苹果计算机架构，以及如何在函数中使用它们的寄存器。这就是所谓的架构调用约定。 了解汇编如何工作以及特定架构的调用约定如何工作是一项极其重要的技能。它可以让您观察没有源代码的函数参数，并允许您修改传入函数的参数。此外，有时转到底层汇编层面会更好，因为您的源代码可能对您不知道的变量有不同的或未知的名称。例如，假设您想知道函数调用的第二个参数，但是我并不知道参数的名称是什么。汇编的知识会帮助你来观察这些函数中的参数。 汇编101等等，所以到底什么是汇编？来看一个场景：您是否曾经打了一个断点，但是中断到没有源代码的地方？然后看到看到大量内存地址和可怕的简短命令?你是不是缩成一团，悄悄地对自己说你再也不会看这些密集的东西了?嗯…这就是所谓的汇编!这里有一张Xcode中的断点调试图，它展示了模拟器中函数的汇编。 通过上图可以看出汇编代码可以被分成几个不同的部分。汇编指令中的每一行都包含一个操作码，可以认为是对计算机来说非常简单的指令。那么操作码是什么样子的呢？操作码是在计算机上执行一项简单任务的指令。例如下面的程序集片段: pushq %rbxsubq $0x228, %rsp movq %rdi, %rbx 在这个汇编模块中，您可以看到三种操作码:pushq、subq 和 movq可以将操作码项看作要执行的操作。操作码后面的内容是源标签和目标标签。也就是说，这些是操作码所作用的对象。在上面的示例中，有几个寄存器，显示为 rbx 、rsp 、rdi 和 rbp。前面的 % 告诉您这是一个寄存器。 此外，您还可以找到一个十六进制的数字常量，如0x228。这个常数之前的美元符号告诉你它是一个绝对值。现在不需要知道这段代码在做什么，因为您首先需要了解每个符号的含义。然后你会学到更多关于操作码的知识，并在以后的章节中编写你自己的程序。 注意：在上面的示例中，请注意，在寄存器和常量之前有一堆％和$。 这就是反汇编程序格式化程序集的展示方式。 但是可以通过两种主要方式展示汇编。 第一个是 英特尔程序集 ，第二个是 AT＆T程序集 。默认情况下，Apple的反汇编程序工具都会以AT＆T格式显示，就如上例所示。 尽管这是一种很好的格式，但在眼睛上可能会有些困难。 在下一章中，您将把汇编格式更改为Intel，并且从那以后将完全使用Intel汇编语法。 x86_64 vs ARM64作为Apple平台的开发人员，学习汇编时要处理两种主要架构：x86_64架构和ARM64架构。 x86_64是最可能在macOS计算机上使用的体系结构，除非您运行的是“古老”的Macintosh。x86_64是64位体系结构，这意味着每个地址最多可以容纳64个1或0。 另外，较旧的Mac使用32位架构，但是Apple在2010年底停止生产32位Mac。 在macOS下运行的程序可能是64位兼容的，包括Simulator上的程序。 话虽如此，即使您的macOS是x86_64，它仍然可以运行32位程序。如果对使用的硬件架构有疑问，可以在终端中运行以下命令来获取计算机的硬件架构： uname -m 在能耗要求很高的移动设备（如iPhone）上使用ARM64体系结构。ARM强调节能功能，因此它减少了一组操作码，有助于简化复杂的汇编指令，从而降低了能耗。 这对您来说是个好消息，因为关于ARM的体系结构你需要学习的并不多。这是与之前显示的方法相同的屏幕截图，除了这次是在iPhone 7上的ARM64程序集中：您现在可能无法区分这两种架构，但是您很快就会知道它们就像手背一样. Apple最初在其许多iOS设备中都提供了32位ARM处理器，但此后便转移到了64位ARM处理器。 32位iOS设备几乎已过时，因为Apple已通过各种iOS版本逐步淘汰了它们。 例如，iPhone 5是最终的32位iOS设备，iOS 11不支持该设备。支持iOS 11的“最低” iPhone是64位设备iPhone 5s。近年来，32位设备已出现在其他Apple产品中。 Apple Watch的前两代是32位设备，但是第三代是64位设备。 此外，在较新的macOS设备上发现的Apple Touch Bar（无疑是花哨的）也使用32位架构。 由于最好专注于您将来的需求，因此本书将主要关注两种架构的64位汇编。 此外，您将首先开始学习x86_64程序集，然后过渡到学习ARM64程序集，以免感到困惑。 好吧，不要太困惑。 x86_64 寄存器调用规则您的CPU使用一组寄存器来操纵正在运行的程序中的数据。这些是存储的基础，就像计算机中的RAM一样。但是，它们位于CPU本身上，因此CPU的这些部分可以快速访问这些寄存器。效率非常高，大多数指令涉及一个或多个寄存器，并执行一些操作，例如将寄存器的内容写入内存，将存储器的内容读取到寄存器或对两个寄存器执行算术运算例如 加，减等。 在x64中（从现在开始，x64是x86_64的缩写），机器使用16个通用寄存器来操纵数据。这些寄存器是RAX，RBX，RCX，RDX，RDI，RSI，RSP，RBP和R8至R15。这些名称对您现在意义不大，但是您很快就会发现每个寄存器的重要性。“在x64中调用函数时，寄存器的方式和使用遵循非常特定的规则。这决定了函数的参数应该去哪里以及函数完成时函数的返回值应该在哪里。这很重要，因此可以将一个编译器编译的代码与另一个编译器编译的代码一起使用。 比如你看下面这个行代码： NSString *name = @&quot;Zoltan&quot;; NSLog(@&quot;Hello world, I am %@. I&apos;m %d, and I live in %@.&quot;, name, 30, @&quot;my father&apos;s basement&quot;); NSLog函数调用中传递了四个参数。 其中一些值按原样传递，而一个参数存储在局部变量中，然后在函数中作为参数引用。 但是，通过汇编查看代码时，计算机并不关心变量的名称(name)； 它只关心该变量在内存中的位置。 在x64汇编中调用函数时，以下寄存器用作参数。 尝试将它们提交到内存中，因为将来您会经常使用它们： 第一个参数：RDI 第二个参数：RSI 第三个参数：RDX 第四个参数：RCX 第五个参数：R8 第六个参数：R9 如果有六个以上的参数，则使用程序的堆栈将其他参数传递给该函数。 回到简单的Objective-C代码，上面的OC代码可以像下面这样的伪代码流程在寄存器中传递： RDI = @"Hello world, I am %@. I'm %d, and I live in %@.";RSI = @"Zoltan";RDX = 30;RCX = @"my father's basement";NSLog(RDI, RSI, RDX, RCX); NSLog调用完成后，指定的寄存器将包含如上所述的适当值。但是，一旦函数序言（准备堆栈和寄存器的函数的开始部分）完成执行，这些寄存器中的值就可能改变。生成的程序集可能会覆盖存储在这些寄存器中的值，或者在代码不再需要这些引用时丢弃这些引用。这意味着，一旦离开函数的开始，就不能再假定这些寄存器将保存您要观察的期望值，除非您实际查看汇编代码看看它在做什么。使用此调用规则的浏览寄存器会严重影响您的调试（和断点）策略。必须在函数调用开始时停止以查看或修改参数，而不必实际进入程序集。 Objective-C 和寄存器如上一节所述，寄存器使用特定的调用规则。 您也可以将该知识其应用于其他语言。当Objective-C执行方法时，将执行一个名为 objc_msgSend 的特殊C函数。 这些功能实际上有几种不同的类型，但稍后会介绍更多。 这是Objective-C动态消息分发的核心。 作为第一个参数，objc_msgSend获取在其上发送消息的对象的引用。 随后是一个选择器，它只是一个char *，用于指定在对象上调用的方法的名称。 最后，如果选择器指定应有参数，则objc_msgSend在函数中采用可变数量的参数。让我们来看一个在iOS环境中的具体示例： id UIApplicationClass = [UIApplication class];objc_msgSend(UIApplicationClass, "sharedApplication"); 第一个参数是对UIApplication类的引用，其后是sharedApplication选择器 其实就是需要被调用的方法。 判断是否有参数的一种简单方法是简单地检查Objective-C选择器中的冒号。 每个冒号将代表一个方法中的参数。我们下面来看一个OC的方法： NSString *helloWorldString = [@"Can't Sleep; "stringByAppendingString:@"Clowns will eat me"]; 最终编译会变成： NSString *helloWorldString; helloWorldString = objc_msgSend(@"Can't Sleep; ", "stringByAppendingString:", @"Clowns will eat me"); 第一个参数是NSString的实例（@“ Can’t Sleep;”），后跟方法选择器，然后是方法调用的参数。 将理论付诸实践在本节中，您将使用本章资源包中提供的名为Registers的项目。通过Xcode打开该项目，然后运行。 这是一个非常简单的应用程序，仅显示64位寄存器里面的内容。 需要注意的是，该应用程序不会实时的显示寄存器的值； 它只能在特定的函数调用期间显示寄存器的值。 这意味着您不会看到这些寄存器的值有太多更改，因为在调用获取寄存器值的函数时它们可能具有相同（或相似）的值。现在，您已经了解了Registers macOS应用程序背后的功能，为NSViewController的viewDidLoad方法创建一个符号断点。 记住，因为您正在使用Mac应用程序，所以请使用“ NS”代替“ UI”。 生成并重新运行该应用程序。触发断点后在LLDB控制台中键入以下内容： (lldb) register read 这将列出处于暂停执行状态的所有主要寄存器。 但是输出了太多信息。 您应该有选择地打印出寄存器，并将其视为Objective-C对象。如果您还记得的话，-[NSViewController viewDidLoad]将被转换为以下程序集伪代码： RDI = UIViewControllerInstance RSI = "viewDidLoad"objc_msgSend(RDI, RSI) 考虑到x64调用规则，并且知道objc_msgSend的工作方式，您可以找到要加载的特定NSViewController。在LLDB控制台中键入以下内容： (lldb) po $rdi 然后你会看到如下输出： &lt;Registers.ViewController: 0x6080000c13b0&gt; 它输出了RDI寄存器中的NSViewController引用，您现在知道该引用是该方法的第一个参数的位置。 在LLDB中，为寄存器加上$字符很重要，因此LLDB知道您需要的是寄存器的值，而不是源代码中与范围相关的变量。 是的，这与您在刚刚反汇编视图中看到的汇编不同！ 烦人吧？ 注：善于观察的你可能已经注意到了在OC代码中打断点，在LLDB的回溯内看不到objc_msgSend的影子。这是因为objc_msgSend方法簇执行了jmp。意思就是说objc_msgSend扮演了中转的角色，一但OC代码开始执行，所有的关于objc_msgSend的栈中的回溯都将消失。这是一种叫做尾递归调用的优化。因为mesgsend开始执行证明之前的栈帧已经清空了。 尝试打印出RSI寄存器，不出意外的话应该是方法名。 在LLDB控制台中输入以下内容： (lldb) po $rsi 结果你会输出这个 140735181830794 为什么是这样？ Objective-C选择器基本上只是一个char *。 这意味着，像所有C类型一样，LLDB不知道如何格式化此数据。 因此，您必须将此引用显式转换为所需的数据类型。将RSI寄存器强制转换为正确的类型使用如下指令 po (char *)$rsi 或者 po (SEL)$rsi 便可以得到方法名字 "viewDidLoad" 现在，该探讨带有参数的Objective-C方法了。 由于您已经断点了viewDidLoad，因此可以放心地假设NSView实例已加载。 感兴趣的方法是mouseUp：由NSView的父类NSResponder实现的选择器。在LLDB中，在NSResponder的mouseUp：选择器上创建一个断点，然后继续执行。 如果您不记得该怎么做，则需要以下命令： (lldb) b -[NSResponder mouseUp:] (lldb) continue 现在，点击应用程序窗口。 确保单击NSScrollView的外部，因为NSScrollView它会拦截您的单击，并且不会命中-[NSResponder mouseUp：]断点。 点击后，LLDB就会在mouseUp：断点处停止。 通过在LLDB控制台中键入以下内容，打印出NSResponder的引用： (lldb) po $rdi 会出现如下的输出 &lt;NSView: 0x608000120140&gt; 但是，该方法是带参数的！ 在LLDB控制台中输入以下内容： (lldb) po $rdx 输出 “NSEvent: type=LMouseUp loc=(351.672,137.914) time=175929.4 flags=0 win=0x6100001e0400 winNum=8622 ctxt=0x0 evNum=10956 click=1 buttonNumber=0 pressure=0 deviceID:0x300000014400000 subtype=NSEventSubtypeTouch” 也可以看到参数类型 po [$rdx class] NSEvent 太酷了，是吗？有时使用寄存器和断点很有用，以便获得内存中还存在的对象的引用。例如，如果您想将前部NSWindow更改为红色，但是在代码中没有对该视图的引用，又不想重新编译任何代码怎么办？ 您只需创建一个断点就可以轻松调试，从寄存器中获取引用并根据需要操纵该对象的实例。 您现在将尝试将主窗口更改为红色。” 注：尽管NSResponder实现了mouseDown:方法，但NSWindow重写了它。你可以输出所有实现了mouseDown:的类，你就可以看出这个方法被那些类重写了，而不用去看源码。输出所有实现了mouseDown:方法的OC类的命令是：image lookup -rn ‘\ mouseDown:‘ 首先使用LLDB控制台删除所有以前的断点： breakpoint delete 像如下输出 (lldb) breakpoint deleteAbout to delete all breakpoints, do you want to do that?: [Y/n] YAll breakpoints removed. (3 breakpoints)(lldb) 然后在LLDB控制台中键入以下内容： (lldb) breakpoint set -o -S “-[NSWindow mouseDown:] (lldb) continue 这句话的作用是设置一个单发断点，只会触发一次，然后点击应用程序触发断点，在LLDB控制台中键入以下内容： (lldb) po [$rdi setBackgroundColor:[NSColor redColor]] (lldb) continue 之后就可以看到效果 Swift和寄存器在Swift中探索寄存器时，您将遇到两个问题，这使汇编调试比Objective-C困难。 首先，在Swift调试上下文内寄存器不可用。意味着你不得不获取到任何你想要的数据，并使用OC调试上下文打印出传入Swift函数的寄存器。记住你可以使用expression -l objc -O命令，或者使用在书中第八章（“Persisting and Customizing Commands”）的cpo命令。幸运的是，register read命令依然是可以使用的。 其次，Swift相对于OC并不是动态的。事实上，有时候最好假设Swift像C语言一样。如果知道了一个内存地址，你应该显示地强转为你想要的类型。不然Swift调试器没有任何线索去解释内存地址。 话虽这么说，但是Swift使用了相同的寄存器调用规则。 但是有一个非常重要的区别。 当Swift调用一个函数时，它不需要使用objc_msgSend，除非您当然标记了使用动态方法。 这意味着当Swift调用函数时，先前分配给选择器的RSI寄存器实际上就是函数的第二个参数。好了，足够的理论-是时候将其付诸实践了。 在Registers项目中，导航到ViewController.swift并将以下函数添加到该类： func executeLotsOfArguments(one: Int, two: Int, three: Int, four: Int, five: Int, six: Int, seven: Int, eight: Int, nine: Int, ten: Int) &#123; print("arguments are: \(one), \(two), \(three), \(four), \(five), \(six), \(seven), \(eight), \(nine), \(ten)") &#125; 现在，在viewDidLoad中，使用适当的参数调用此函数： self.executeLotsOfArguments(one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10) 在与executeLotsOfArguments声明相同的行上放置一个断点，以便调试器将在函数的开始处停止。 这很重要，否则如果函数已经开始执行，则寄存器可能会被破坏。然后删除您在-[NSViewController viewDidLoad]上设置的符号断点。生成并运行该应用程序，然后等待executeLotsOfArguments断点停止执行。我们先列出所有的寄存器。 在LLDB中，键入以下内容： register read -f d 这将列出所有的寄存器，并使用-f d选项以十进制显示格式。 输出将类似于以下内容： (lldb) register read -f dGeneral Purpose Registers: rax = 10 rbx = 7 rcx = 4 rdx = 3 rdi = 1 rsi = 2 rbp = 140732785005232 rsp = 140732785004720 r8 = 5 r9 = 6 r10 = 9 r11 = 8 r12 = 140668105198352 r13 = 105553138827696 r14 = 104 r15 = 8 rip = 4430734802 Registers`Registers.ViewController.executeLotsOfArguments(one: Swift.Int, two: Swift.Int, three: Swift.Int, four: Swift.Int, five: Swift.Int, six: Swift.Int, seven: Swift.Int, eight: Swift.Int, nine: Swift.Int, ten: Swift.Int) -&gt; () + 178 at ViewController.swift:68:15 rflags = 514 cs = 43 fs = 0 gs = 0(lldb) 如您所见，寄存器遵循x64调用规则。 RDI，RSI，RDX，RCX，R8和R9保留您的前六个参数。 注意:关于LLDB，我一直没有告诉您的是，LLDB可以以$arg{X}形式来引用寄存器，其中X是参数号。还记得RDI是第一个参数，而RSI是第二个参数吗?在LLDB中，可以通过$arg1引用第一个参数(RDI)。随着示例的进行，您可以使用$arg2引用第二个参数(RSI)，以此类推。这些方便值也可以在ARM64调用约定中使用，即使ARM64使用不同的寄存器。您应该记住寄存器调用规则，以便本书尽量减少使用这些寄存器辅助变量。 您可能还会注意到其他参数存储在其他一些其他寄存器中。 确实如此，但这只是为其余参数设置堆栈的代码中的剩余部分。 请记住，第六个参数之后的参数将进入堆栈。 RAX，用于返回的寄存器等等–还有呢！到这里，你已经了解了函数中六个寄存器是如何调用的，但是返回值呢？ 幸运的是，只有一个指定的寄存器用于返回值：RAX。回到executeLotsOfArguments函数并改变函数的返回值，像这样： func executeLotsOfArguments(one: Int, two: Int, three: Int, four: Int, five: Int, six: Int, seven: Int, eight: Int, nine: Int, ten: Int) -&gt; String &#123; print("arguments are: \(one), \(two), \(three), \(four), \(five), \(six), \(seven), \(eight), \(nine), \(ten)") return "Mom, what happened to the cat?" &#125; 然后viewdidlaod中调用 let _ = self.executeLotsOfArguments(one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10) 在executeLotsOfArguments中的某处创建一个断点。 再次生成并运行，然后等待函数停止执行。 接下来，在LLDB控制台中键入以下内容： (lldb) finish 命令会结束完成函数的执行并停住调试器。这时，函数返回值会在RAX内。输入如下命令： (lldb) register read rax 你将会看见如下输出 rax = 0x0000000100003760 "Mom, what happened to the cat? 了解RAX中的返回值非常重要，因为它将构成您将在后面的部分中编写的调试脚本的基础。 改变寄存器值为了巩固您对寄存器的理解，您将在一个已编译的应用程序中修改寄存器。关闭Xcode和Registers项目。 打开终端窗口，然后启动iPhone X Simulator。 通过键入以下内容来执行此操作： xcrun simctl list | grep “iPhone X” Phone: iPhone 12 Pro Max (16A6D554-3C10-4A67-9039-31B8BE33871F) (Shutdown) UDID就是你要找的。使用它并通过如下命令打开iOS模拟器（替换其中的UDID部分）： open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app –args -CurrentDeviceUDID 16A6D554-3C10-4A67-9039-31B8BE33871F 保证模拟器已经启动而且在主屏幕上。你可以通过按下Command + Shift + H键回到主屏幕。一旦模拟器准备好了，回到终端窗口将LLDB绑定到SpringBoard程序上。 lldb -n SpringBoard 这样会将LLDB绑定到正在模拟器上运行的SpringBoard实例上！SpringBoard就是在iOS上控制主屏幕的程序。 一旦绑定，输入如下命令： (lldb) p/x @”Yay! Debugging可以看到类似如下的输出： (__NSCFString *) $3 = 0x0000618000644080 @"Yay! Debugging!" 注意下刚刚创建的这个NSString实例，因为很快你会用到它。现在，给UILabel的setText:方法设置一个断点： (lldb) b -[UILabel setText:] (lldb) breakpoint command add LLDB会吐出一些输出且进入多行编辑模式。这个命令让你在刚刚打的断点处添加多个额外要执行的命令。输入如下，使用刚才的NSString地址替换下面的内存地址： &gt; po $rdx = 0x0000618000644080&gt; continue&gt; DONE 回去重新看下你刚刚做的。你在UILabel的setText:方法上添加了一个断点。一旦遇到该方法，你就会用一个叫Yay! Debugging!的NSString实例替换RDX—第三个参数。 使用continue命令让调试器继续执行： (lldb) continue 看看SpringBoard模拟器程序什么发生了改变。从下往上扫带出控制中心，观察改变的地方： 尽管这似乎是一个很酷的花招编程技巧，但它却展示了通过有限的汇编和寄存器的知识能够在程序内产生你之前没见过的大的变化。 从调试的角度来看，这也很有用，因为您可以快速直观地验证-[UILabel setText：]在SpringBoard应用程序中的执行位置，并运行断点条件以查找设置特定UILabel文本的确切代码行。 寄存器和SDK了解寄存器的工作方式以及应用程序的功能可以快速帮助您找到感兴趣的项目。举个简单的例子：通常，我会遇到一个UIButton，并想知道IBAction和接收器，当我点击该按钮时会发生什么。在最高断点处，我可能会发疯……认识我自己，我通常在UIView或UIViewController（也许是UITableViewCell？）中包含IBAction，并且通常使用某种名称为“ tapped”的方法。因此，也许下面的LLDB命令会起作用？ (lldb) rb View(Controller|Cell)?\s(?i).*tapped 但是我错误地假设同事/其他开发人员正在使用与我相同的命名约定；这个想法行不通。相反，我知道，每当执行IBAction方法时，它都必须经过UIApplication单例，在该单例中，它将遍历响应者链来找到合适的接收者。为此，将调用UIControl的-sendAction：to：forEvent：方法。我可以在此方法上设置一个断点，并探索sendAction：和to：参数以查找IBAction正在执行的代码。这个想法可以应用到您拥有和没有源代码的应用程序中。我经常发现，即使在我确实有源代码的应用程序中，使用此方法也更快，然后在应用程序中看到数千个IBAction。 …但仅出于演示目的，让我们将其应用于iOS Maps应用程序。我对右上方按钮的名称和接收者感到好奇，该按钮可以直接定位用户的具体位置。 通过LLDB附加到Maps应用程序并为-[UIControl sendAction：to：forEvent：]设置断点后，很容易找到UIButton的名称和接收者。sendAction：参数（RDX）将使用选择器，而to：参数将是IBAction的接收器（RCX）。 用寄存器知识和轻按UIButton查找代码，这有多酷？ 下一步好的，学了这么长时间，来休息下，看看你学到了什么： 架构（X86）定义了一个调用规则，该规则规定了函数参数及其返回值的存储位置。 在Objective-C中，RDI寄存器是调用NSObject的引用，RSI是选择器，RDX是第一个参数，依此类推。 在Swift中，RDI是第一个参数，RSI是第二个参数，依此类推，前提是Swift方法未使用动态分配。 RAX寄存器用于函数中的返回值，无论您使用的是Objective-C还是Swift。 您可以利用寄存器做很多事情。尝试浏览您没有源代码的应用；将为解决棘手的调试问题奠定良好的基础。 尝试附加到iOS Simulator上的应用程序，并使用程序集，智能断点和断点命令绘制出UIViewController的生命周期。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[招聘iOS开发者啦！]]></title>
    <url>%2F2019%2F02%2F21%2FNeed-People%2F</url>
    <content type="text"><![CDATA[岗位职责 : 1.负责iOS平台上全民K歌APP的开发工作； 2.与产品、测试及其他团队协作，分析产品需求，制定技术方案，攻克技术难题； 3.新技术研究和引入。 岗位要求 : 1.本科以上学历，计算机相关专业； 2.2年以上相关工作经验； 3.计算机基础扎实，精通Objective-C，熟悉iOS平台并有良好的软件开发经验； 4.熟悉https及流媒体上传下载协议，精通TCP/IP协议； 5.良好的编码风格，以及足够的调试技术和问题解决能力； 6.责任心强，积极向上、乐于学习新技术； 7.英语良好，能阅读英文资料； 了解音频/视频的编解码，有音视频直播相关经验者优先。 有意者发简历到 “zhangninghao11@gmail.com”认真脸 var options = {"narrow":false,"autoplay":true,"showlrc":3,"mutex":true,"music":[{"title":"大鱼","author":"周深","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv"}]}; options.element = document.getElementById("aplayer7"); new APlayer(options);]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[At The End Of 2018]]></title>
    <url>%2F2019%2F02%2F14%2FAt-the-end-of-2018%2F</url>
    <content type="text"><![CDATA[前言今年的总结来的比去年稍微晚一些，本来打算像去年一样在最后一个工作日出炉的，但是因为年前事情比较多，而且再加上父母要来过年，又请了半天假回家收拾屋子，所以没有按时完成任务。总的来说今年算是我人生中比较重要的一年，不光是我自己，还有自己的妹子，甚至2018对于中国互联网也是一次历史性的转折。 写这篇文章之前我还看了下去年的年终总结，想看看当时立了哪些flag，完成了哪些、辜负了哪些，最终的结论是勉勉强强完成百分之五十，不过虽然一半没有完成，但是今年还发生了一些其他的事情，总的来说收获不小，相比去年有过之而无不及，人总是要进步的嘛~ 辞旧大背景2018年是不平凡的一年，尤其是对于互联网行业，都在说2018是互联网的寒冬，2018是过去十年最难的一年，同时也是未来十年最好的一年。作为一个在深圳的互联网从业者来说确实感慨颇深，一个个熟悉的朋友“被离职”，一家家曾经耳熟能详的公司“跑路”、“优化”。再加上各大媒体为了眼球效应大肆渲染，确实搞得大家人心惶惶。不过还是有一些公司趁着这个机会疯狂找人，想弯道超车，由此可见互联网还是有无限的潜力的。 职业生涯今年对我影响最大应该算是从美图离职吧，不过这个真的跟互联网寒冬没有关系，完全是个人原因。其实到现在为止，美图在我心里依然占据很重要的一部分，从2016年6月13日到2018年6月13日，在美图的整整两年中我学到新的技术，认识到新的朋友，接触到新的圈子，更重要的是美图教会了我一种精神，一种上进，一种不服输的精神，总是想学更多的东西，想认识更多的人，总是有一种饥饿感。当然这一切也离不开我那些优秀的同事们。这也印证了那句话，你的圈子决定你成为一个生么样的人。美图公司给我留下的印象依然是站在图像处理领域的最高点，每一款产品都能让人眼前一亮，同时也一直在引领着“美颜”趋势的发展。 5月底的时候身边的同事陆续地走了，去了BAT或者国外发展，不管是继续求学还是继续工作，他们都有了新的目标，当时对于不服输的我来说其实影响很大，于是也去鹅厂试了下并且拿到了offer。正好当时也觉得在美图带的时间也算比较久，而且对于个人的成长也似乎到了瓶颈，当时只是做一些业务需求，正好自己也想接触一些新的东西，所以就来了鹅厂。 现在想想当时的情况感觉还是挺不可思议的，鹅厂的面试流程一项以严(hen)谨(man)著称，之前看论坛上流程要几个月的大有人在，而我5月底还在纠结要不要来腾讯，而六月中旬就拿到了offer，在这里还是要感谢我的现在的导师一直持续跟、催促进面试流程，才使得有这样的效率。历史总是惊人的相似，想起我当时来深圳的时候，2016年的5月底我还在北京的出租房门前给我妈打着电话纠结是否要来深圳打拼，从北京到深圳，地理位置的巨大变化不说，包括圈子，工作，生活基本都要从头开始，但是过了不到一个月 6月13号我已经做在了深圳美图的工位上，有的时候人生就是需要这样的而果断甚至是决绝吧。来到鹅厂算是去年一个很大的转折吧。 个人生活个人生活方面无非就是健身、旅游、读书之类除了工作之外的事情，其实去年立了flag，说今年要去两个国家，结果只在五一时候跟妹子去了泰国，逛了三个城市。总结了原因，并不是时间或者是经济的原因，主要是2018互联网寒冬、人心惶惶、各种各样的负面消息层出不穷，谁也不敢放松太久，说白了还是为生活所迫吧🙂🙂🙂。 国内的话也没去太多地方、去广州吃了早茶、去珠海看了情侣路，香港澳门就不算了，毕竟过年回家基本都能路过，也走过好多地方。今年地图上又打了不少点，看到这些还是蛮有成就感的 广州广州主要是吃，特色小吃比较多，在广州能吃到正宗的广东风味，比深圳要强很多，奈何我不是吃货总的体验还是不错的小蛮腰那个岛上的夜景很好看。 曼谷作为泰国的首都，就像国内的一线城市一样，街道上车水马龙，周围都是高耸的写字楼，虽然不如深圳这样现代化，但是作为泰国的城市，现代化程度也是泰国中最好的，到了晚上会更加热闹些，夜景也很好看，大部分都是来旅游的中国游客，熙熙攘攘，好不热闹，第二张图是比较有名的火车头小吃街，东西很不错，都是慕名而来，里面隐藏了很多的网红店，物价在当地算是比较贵的了，但是和深圳比起来还是相当的便宜。 芭提亚芭提亚最著名的就是人妖表演，但是我们没去看，因为对那些还是有点….，晚上感受了下夜生活，白天去了海边，不过说实话芭提亚还是和那种随便一拍就是壁纸的仙本那有一定差距的，海鲜也一般，但是仍然能能感受到这边的热情和奔放。 清迈我们把清迈作为最后一站还是很合理的，一个很安逸清静的小镇，特别适合在长途旅行后放松心情，这里你会感觉到，明显生活会慢半拍，好多的寺庙，皇宫，也适合了解这边的历史。感觉这边的人和大象都很温顺，芭提亚也有大象，但是可能是因为接待了太多的游客，脾气会大些吧，😊😊😊。 这个城市非常适合拍照，一是景色优美，而是不用那么急急忙忙，给人一种很放松的感觉，我们这次的照片一多半都出自清迈。 其他2018年还发生了很多，妹子很不幸的成了互联网寒冬的受害者，不过后来在自己的努力下下又拿到了Adelaide的offer 后来问了好多朋友，原来大部分人情况都差不多，互联网寒冬，国内形势严峻，都准备继续去国外求学，一是为了避险，二是为了提高自己。虽然出国前需要考虑的东西还是很多的，但是不管怎样妹子通过自己的努力拿到这样的成绩还是值得高兴的，至于后面是否选择留学，还是看实际的情况吧。 还有就是今年的公租房差一点就排到了，带车位带学位，当天都带好了材料准备去认租了，结果临走前告诉我房子已选完，不用去了😭😭😭，可能还需要再等上一年，不过我也在公司内部申请了，希望能快点吧。 关于读书，今年没有读几本书，但是我发现一个有趣的现象，发现微信里所关注的公众号不仅仅再是之前的搞笑类的了，而是更多的类似于“互联网思维” 这样的公众号，慢慢的对这个时代敏感度提高，现在也养成了每天睡觉前都会把今天所有的大新闻读一遍，然后总结出来的习惯，也算是在27岁时候达到了老爸在七岁时对我的要求。 今年最开心的应该就是爸妈来深圳过年了，一直想让他们来，之前一直请不下假，他们工作比我还忙，不过这次终于来了，带我爸去了他心心念的香港和澳门，之前是因为工作关系，没办法出境，这次终于突破层层阻碍踏上了特别行政区的土地。希望以后他们有更多的时间过来。我还跟我爸说，这次时间紧迫，没法去台湾了，我爸态度很坚决的说：“台湾一定要等回归了再去！” 迎新和去年一样，不想立太多的flag，怕万一一个都做不到了丢人，毕竟白纸黑字都写在这里，其实做不到不是因为堕落，而是你真的不知道未来会发生什么，尤其是对于当代的互联网人来说唯一不变的就是一直在改变，而我们需要做的就是随机应变，顺应时代，拥抱变化，有的人会说，如果不设定一些目标，到时候无法量化自己收获，导致年终没什么可写，其实对于我来说立不立flag对我真的没那么重要，每天回到家，感到今天很充实就够了，就像老罗在“时间的朋友”里说的：你有你的计划，而世界另有计划。不过还是说下对未来的期望吧： 去一到两个国家 坚持一周三次5公里…. 最后我喜欢写总结的感觉，因为这能让我把今年经历的所有重要的事情在脑子立过一遍，就会觉得没有白过，让每一年都过得有价值。 最后希望每人看到我这篇文章的人都能不忘初心，我们明年再见… 才疏学浅，文笔拙劣，于2019.2.14仓促执笔…. var options = {"narrow":false,"autoplay":true,"showlrc":3,"mutex":true,"music":[{"title":"大鱼","author":"周深","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv"}]}; options.element = document.getElementById("aplayer6"); new APlayer(options);]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>回首2018展望2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN切换到Git]]></title>
    <url>%2F2018%2F08%2F23%2FChangeSvnToGit%2F</url>
    <content type="text"><![CDATA[背景：SVN和Git同样都是在特定时代下比较优秀的版本控制系统，但是随着时代的发展，SVN越来越不能满足多人开发的需求，尤其是在多种多样，天马星空的业务场景面前，SVN会显得力不从心。 最近在将公司的项目从SVN迁移到git，踩了不少坑，所以来记录下: 因为迁移的快慢和整个仓库的大小，电脑配置有关，所以我先说下这边的情况 仓库：仓库大概是3.5G左右，包含了14500+的提交次数，其中包含了超过500M的单个文件 电脑：电脑配置就看图吧 ： 在以上两种情况下，排除掉采坑的时间，总耗时在10小时左右，当时中途我也用过一台联系X1的本尝试过，配置如下： 后来联想这台电脑放弃了，因为总耗时已经超过30小时， 操作：1.生成作者文件：因为我们知道，在SVN上提交和在Git上提交对应提交者的信息展示是不同的，SVN只会保存一个用户名，而Git会保存该用户的邮箱，所以我们迁移的第一步就要生成一个映射文件，将SVN上的用户名和其邮箱对应起来,就比如 molier = molier &lt;123456@qq.com&gt;,转换的办法有很多，如果你团队里面的人不是很多的是时候,可以自己去提交记录中手动生成这样一个TXT文件XXX = XXX &lt;XXX@XXX.com&gt;XXX = XXX &lt;XXX@XXX.com&gt;.... 但是如果，多人开发人数很多的时候,手动转很累，我们就需要一个Atlassian的工具包 svn-migration-scripts.jar，通过命令拉取SVN仓库的用户并生成对应的开发者信息映射文件，需要Java运行时环境支持,大家可能还需要安装JDK： java -jar svn-migration-scripts.jar authors https://svn.example.com &gt; authors.txt 这样之后会在当前目录生成一个 authors.txt 文件 2.转换仓库 整体转换: 标准的SVN文件布局：如果SVN仓库使用标准的了/trunk, /branches和/tags的目录结构，就可在运行命令时加上参数–stdlayout，使用如下命令 git svn clone --stdlayout --authors-file=authors.txt &lt;svn-repo&gt;/&lt;project&gt; &lt;克隆到文件夹的名字&gt;非标准的的SVN文件布局: 如果SVN仓库是非标准的目录布局，那就需要分别显示指定参数–trunk, –branches, –tags。 git svn clone --trunk=/trunk --branches=/branches --branches=/bugfixes --tags=/tags --authors-file=authors.txt &lt;svn-repo&gt;/&lt;project&gt;&lt;克隆到文件夹的名字&gt; 部分转换: 如果仓库非常庞大的话可以选择部分转换，也就只转换指定提交之后的提交，可以试用如下代码 git svn clone -r123456:HEAD --stdlayout --authors-file=authors.txt &lt;svn-repo&gt; &lt;克隆到文件夹的名字&gt; 不过这里需要注意的是如果使用这种方式来转换那么一定要指定SVN的代码根部，而不能指定分支，因为SVN的提交编号都是按照时间顺序来往下依次排列，不同的分支也可能提交编号是连续的，所以如果只关心编号的话就不能再指定分支了。 以上三步中所用到的 authors.txt 即为上一步所生成的，作者 -&gt; 作者 &lt;作者邮箱&gt; 的对应关系文件. 坑点完成以上操作的话如果一切正常那么你就会获得一个新的Git仓库，然后就可以添加到远端，进行多人开发了，至于git的操作并不在本文的范围内，下面会讲一下遇到的坑以及解决办法。 坑点一：时间久转换仓库是比较耗时的，因为他会一个提交一个提交的转换，转换的速度和你的仓库提交次数和电脑配置成正比，我当时转了十几个小时比较正常，而且转换完之后他还有个自己整理文件的过程也是很耗时的，不过如果你选择部分转换的话也可能很快，假如你一共15000个提交，然后你从14999来转换可能几分钟就够了。当然最好的办法就是下班前开始执行，第二天来了基本就差不多了。不过别高兴的太早，请看坑点二。 坑点二：垃圾过多导致暂停因为是要遍历所有的历史提交，所以可能会有很多的无用文件 比如项目一开始代文件结构很乱，然后慢慢的经过重构，之类的优化步入正轨，这过程中必然会删掉大量的无用、冗余的文件，虽然这些文件已经不复存在了，但是提交记录会有，而且通过git的原理来看他还是会把这些东西一一保存下来，所以就会造成大量无用的文件越来越多，而Git是有一个缓冲区(具体大小不确定)当你无用文件把缓冲区沾满了，那么转换过程会停止会爆出如下错误Auto packing the repository in background for optimum performance.See "git help gc" for manual housekeeping.error: The last gc run reported the following. Please correct the root cause and remove .git/gc.log.Automatic cleanup will not be performed until the file is removed.warning: There are too many unreachable loose objects; run 'git prune' to remove them.gc --auto: command returned error: 255 大概意思是垃圾太多，转移暂停让你先清理垃圾，其实只要按照他说的 进到我们转了一半的仓库 进行 git gc 就可以，但是这样一来我们就需要一直守在电脑前，随时准备输入 git gc 而且假如你下班前开始跑结果第二天上班一看跑到一半就暂停了，白白浪费了一晚上的时间，真的会崩溃的。所以通过google找到了解决办法 也就是开始转换的时候先进入仓库输入 git config gc.auto 0 关闭gc功能，然后就可以一直跑到黑了，你大可以放心的运行命令然后下班回家。不过还有一点需要注意的是垃圾文件是否过多和你仓库大小没有太大关系，及时你仓库提交不多，但是每次提交都有很大改动的话也还是会出现这个问题，所以这里建议不管你仓库多大，都要先进行一下这个操作，以防万一。 坑点三：大文件处理git和SVN不同，在git上提交的单个文件是有大小限制的，超过这个大小就不允许提交到仓库中，通常我们会用git LFS来解决，具体的安装，添加步骤网上大把的教程，就不在这里说，不过他只会告诉你大文件的大小和限制的大小，具体的大文件是哪个他不会告诉你，这里可以用以下命令查看git ls-tree -r -t -l --full-name HEAD | sort -n -k 4 | tail -n 10 //查找git 仓库中排名前十的大文件(升序) 他会输出前十个最大的文件，然后你再按需处理。但是当你把大文件添加到LFS中后再次推送还是会爆出同样的错误，而且还是同样的文件，也就是说你根本没添加成功，其实并不是这样的，在添加LFS中只要你操作没错，就是添加成功了，他还会报错的原因是因为虽然你工程中的大文件已经添加，但是你的历史提交记录中是包含大文件的代码快照的，所以你需要将历史上所有包含大文件的提交记录重写，删掉大文件相关的东西，git 中重写commit的命令是：git filter-branch --force --index-filter 'git rm -rf --cached --ignore-unmatch 你大文件所在的目录' --prune-empty --tag-name-filter cat -- --all 这个过程也比较漫长，他会便利你所有的提交记录并一一修改，不过就是漫长的等待就可以了，等到完成之后我们需要将代码push到远端，因为我们修改了所有的commit 我们需要强制push使用如下命令git push origin master --force 坑点四: 打包时间过长再上一步我们执行完推送命令的时候，会先进行文件打包处理，这个过程也是非常漫长，而且非常消耗电脑资源的，按照我的电脑配置来说，这个过程一旦开始，电脑基本就是内存、cpu全满的状态，鼠标也没法动，所以这个过程要有心理准备。漫长的等待之后就推送成功了。]]></content>
      <categories>
        <category>通用开发</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代码版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitFlow流程]]></title>
    <url>%2F2018%2F08%2F23%2FGitFlow%2F</url>
    <content type="text"><![CDATA[关于gitflow概念：Git Flow是构建在Git之上的一个组织、管理软件开发活动的模型。Git Flow是一套使用Git进行源代码管理时的一套行为规范和，通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被称为“Git Flow”。 原理：gitflow的核心就branch，通过在项目的不同阶段对branch的不同操作包括但不限于create、marge、rebase、等来实现一个完整的高效率的工作流程。一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用，尤其是多人合作开发时提高效率。用一张图来了解gitflow的流程：从右向左看 从上到下看 Branch：Branch是gitfolw的核心。主要分为两大类 Main Branchs 和 Supporting branches, 其中 Main Branchs 中又包含了 Master 和 Develop，而 Supporting branches 中包含了 Feature 、Release、Hotfix 以及其他自定义分支，下面逐一讲解： Master: 描述： master分支上存放的是最稳定的正式版的代码，并且该分支的代码应该是随时可在开发环境中使用的代码（Production Ready state）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master分支上的代码要被更新，同时，每一次更新，都需要在master上打上对应的版本号(tag)。 生成及销毁： 任何人不允许在master上进行代码的直接提交，只接受合入，Master上的代码必须是要从经过多轮测试且已经发布一段时间(根据DAU以及项目实际情况来定，个人建议K歌国际版可以定为一周)且线上已经稳定的 release 分支合并进去，然后在Master 上生成tag(通常就是对应的版本号) 命名： master Develop: 描述： develop分支是保存当前最新版本开发成果的分支。该分支上的代码允许有BUG，但是必须保证编译通过，且该分支可以作为每天夜间测试的分支(如果有夜间测试的话)所以该分支也叫做Nightly build。当develop分支上的代码已实现了软件需求说明书中所有的功能(必须经过开发自测，但是不必经过QA)且相对稳定时候，就可以基于此分支来拉出新的release分支交付QA进行测试。 生成及销毁： Develop分支是由一个人(通常是Team Leader)从Master中拉出，任何人不得在Develop上进行代码提交，只接受合入。Develop上所有代码一定都是由 Supporting branches 中的Branch合并进来，且合入Develop的分支必须保证功能完整，可以独立运行，可允许包含一些BUG(但是最好经过自测，不要有太大或者太明显的BUG，比如一启动就crash之类的)。 命名： develop 流程： Feature: 描述： Feature分支通常叫做功能分支，也可以叫做个人分支，一般命名为 feature/XXXX,该分支就是每一个开发人员进行开发的分支，比如做一些功能、需求之类的东西，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。 生成及销毁： 每个开发者从通常会Develop分支中拉取自己的feature，且开发者可以随意的在自己的feature上进行操作 包括但不限于 提交、回滚、删除。如果最终需要合并入develop那就要保证功能的完整性以及代码的稳定新，比如我在feature上做了3个需求但是由于时间关系我只做了两个，那也可以将feature合并入develop，然后剩下的那一个需求等有时间了再去feature上做完之后再合入develop。所以这里说的功能的完整性并不是值得要做完所有的功能，而是要保证你所要做的所有需求中的某一个或者某几个功能已经做完，不允许把做到一半的功合并入develop。合并入develop尽量上删除远端的feature分支，本地的feature可以视情况而取舍。 命名： feature通常是从develope上拉取 所有通常用 dev功能描述英文名 来命名。比如 feature/dev_refresh_molierzhang 流程： Release: 描述： Release分支通常叫做发布分支，也可以叫做测试-发布分支，一般命名为 Release/1.2.3（后面是版本号）,该分支是为测试-发布新的产品版本而开辟的。因为包含测试流程，所以在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。注意：该分支上的代码一定是可编译可运行的，允许包含小BUG 生成及销毁： 当develop分支上的代码已经包含了该版本所有即将发布的功能和需求，并且已通过自测且已基本稳定，我们就可以考虑准备基于develop拉取release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。成功的派生了release分支之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。开发人员可以在此分支上修改BUG，进行提交、回滚等操作，但是与feature不同的是release分支是被多人操作的，不像feature，所以一定要小心避免冲突。当现在QA测试没有问题，便从release上发布上线，且经过一段时间的验证没有问题后合入master，并且删除release分支，其实根据release分支的特性我们可以使用Git Hook触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。 命名： release/1.2.3 后面跟对应的版本号 流程： 同feature Hotfix: 描述： Hotfix叫热修复分支，除了是计划外创建的以外，hotfix分支与release分支十分相似，当已经发布的版本（Master上代码）遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的tag版本拉取hotfix分支来组织代码的紧急修复工作。这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行、独立的开展工作。 生成及销毁： 由Master上拉取，进行修复，负责修改BUG的同事可以进行提交及其它操作，后续的热修复测试也在此分支上进行。通过测试验证没问题后有一个人(通常为teamleader)合并入Master分支，且同时也要合并入Develop分支 命名： Hotfix/1.2.3 后面跟对应的版本号 流程： 总结Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow开发模型让开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。 所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。 效率工具 推荐 sourceTree 和 gitkarken(用免费版即可，不用充钱) 前者对gitsubmodel的支持不太好，不过目前介于我们没有实现组件化所以暂时可以无视；后者完美支持gitsubmodel，但是在拉取一些比较大的库的时候可能会卡死，前公司一个项目30G+ 会有卡死情况出现，后者界面炫酷一些 iOS的话Xcdoe自带git 也可以试试。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>效率工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于实现唱吧清唱功能的理解]]></title>
    <url>%2F2018%2F06%2F19%2FMusicAbout%2F</url>
    <content type="text"><![CDATA[简介AVFoundation在iOS上多媒体的处理主要依赖的是AVFoundation框架，而AVFoundation是基于CoreAudio、CoreVideo、CoreMedia、CoreAnimation之上高层框架，在AVFoundation框架之上苹果还提供给我们更高层一些处理媒体数据的框架。 如AVKit、iOS的UIKit、OS的AppKit。AVFoundation提供了大量强大的工具集，可通过这个框架处理音视频编程，但是如同苹果中的的Kit一样，封装的越高级，个性化就会困难些，一些实际项目中的奇葩需求难以实现。本章所讲的内容是AVFoundation上层加下层的AVAudioEngine实现。 AVAudioEngineAVAudioEngine是Objective-C的音频API接口，具有低延迟(low-latency)和实时(real-time)的音频功能，并且具有如下特点： 读写所有Core Audio支持的格式音频文件 播放和录音使用 (files) 和音频缓冲区 (buffers) 动态配置音频处理模块 (audio processing blocks) 可以进行音频挖掘处理 (tap processing) 可以进行立体声音频信号混合和3d效果的混合 音乐设备数字接口MIDI 回放和控制，通过乐器的采样器 AVAudioEngine的工作原理可以简单的分为三个部分: 从图中可以看出AVAudioEngine的每一步操作都是一个音频操作节点(Node)，每个完整的操作都包含输入节点和输出节点以及经中间的若干个处理节点，包括但不限于，添加音效、混音、音频处理等。整体的流程和GPUImage的流程差不多，都是链式结构，通过节点来链接成一个完整的流水线，其中每个节点都有自己特有的属性，可以通过改变属性的值来改变经由该节点后的音频输出效果，用音效节点举例：一个声音流通过这个音效节点，假如这个节点可以给该段声音添加一个回响的效果，那么通过该节点特有的属性可以设置回想的间隔、干湿程度等，这样一来经过这个节点处理过的声音流就会变成我们想要的样子，然后他作为为一个输入了再次流入其他节点。上图的Mixer其实是包含若干个这样的音效节点 原理清唱的功能很简单，就是通过麦克风录制声音，然后添加音效或者做一些处理之后再输出，因为不要配乐，所以省略了一大部分操作(添加配乐完整K歌在下期会讲到)，但是有一个问题就是耳返，也叫返送： 这个东西是必不可少的，因为有了耳返你就可以实时调整自己的声音，极大的降低了走调的风险和尴尬，一个很简单的例子，现在有不少人喜欢在水房唱歌或者是洗澡的时候唱歌，原因就是在水房或者是卫生间通常会有回音，而回音就是天然的耳返，所以在有回音的地方唱歌就会感觉自己的声音洪亮而且音准很好(因为你可以实时的通过回音来调整自己的声调)。演唱会上唱歌的人的耳机中都是耳返。而且耳返要有一个要求就是，你所听到的你自己的声音一定要和观众或者是其他的人听到的一样，不然就不会有作用，我们平时自己说话自己能听到是因为声音通过骨传导到达我们的耳朵，而听众听到的是通过空气介质传播，所以是否有耳返直接决定了你演唱质量的好坏。 使用AVAudioEngine来完成这个功能其实就是运用了他的实时音频的特点，他可以几乎在没有延迟的情况下同时创建音频的输入和输出，而且对这个做了高度的封装使我们能更加关心音效调整 实现创建音频文件用来接收待录制的声音：//创建音频文件。 NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString * filePath = [path stringByAppendingPathComponent:@"123.caf"]; NSURL * url = [NSURL fileURLWithPath:filePath]; 创建AVAudioEngine，并打通输入和输出节点： 创建AVAudioEngine，并初始化。这里要弄成属性不然会被释放，没有效果 @interface ViewController ()&#123;@property (nonatomic, strong) AVAudioEngine * engine;@property (nonatomic, strong) AVAudioMixerNode * mixer;@end self.engine = [[AVAudioEngine alloc] init];self.mixer = [[AVAudioMixerNode alloc] init]; 打通输入和输出节点： [_engine connect:_engine.inputNode to:_engine.outputNode format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]]; 所使用的是如下方法。 /*! @method connect:to:format: @abstract Establish a connection between two nodes @discussion This calls connect:to:fromBus:toBus:format: using bus 0 on the source node, and bus 0 on the destination node, except in the case of a destination which is a mixer, in which case the destination is the mixer's nextAvailableInputBus.*/- (void)connect:(AVAudioNode *)node1 to:(AVAudioNode *)node2 format:(AVAudioFormat * __nullable)format; 开启AVAudioEngine: 该方法可能会开启失败，需要开发者自定去处理 [_engine startAndReturnError:nil]; 以上步骤走完后并且开启成功你就会发现你从耳机里面可以实时的听到你的声音了。 音效： 正常来说光有耳返还不够，因为清唱虽然没有配乐伴奏，但是是支持用户调节音效的，类似于变声。这就用到AVAudioEngine中的AVAudioUnitEffect类。 1.AVAudioUnitReverb:混响，混响可以模拟咱们在一个空旷的环境，比如教堂、大房间等，这样咱们在说话的时候，就会有回音，并且声音也比较有立体感。其中该类别下面又分为typedef NS_ENUM(NSInteger, AVAudioUnitReverbPreset) &#123; AVAudioUnitReverbPresetSmallRoom = 0, AVAudioUnitReverbPresetMediumRoom = 1, AVAudioUnitReverbPresetLargeRoom = 2, AVAudioUnitReverbPresetMediumHall = 3, AVAudioUnitReverbPresetLargeHall = 4, AVAudioUnitReverbPresetPlate = 5, AVAudioUnitReverbPresetMediumChamber = 6, AVAudioUnitReverbPresetLargeChamber = 7, AVAudioUnitReverbPresetCathedral = 8, AVAudioUnitReverbPresetLargeRoom2 = 9, AVAudioUnitReverbPresetMediumHall2 = 10, AVAudioUnitReverbPresetMediumHall3 = 11, AVAudioUnitReverbPresetLargeHall2 = 12 &#125; NS_ENUM_AVAILABLE(10_10, 8_0); 从名字可以看出是在模拟不同环境下的音效，比如其中的大中小屋子，大厅等。 该类别可以自定义的属性是wetDryMix，就是可以让我们的声音更空灵。 /*! @property wetDryMix @abstract Blend of the wet and dry signals Range: 0 (all dry) -&gt; 100 (all wet) Unit: Percent */@property (nonatomic) float wetDryMix; 可以通过如下方式创建AVAudioUnitReverb AVAudioUnitReverb * reverd = [[AVAudioUnitReverb alloc] init];reverd.wetDryMix = 100;[reverd loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom]; 2.AVAudioUnitEQ:均衡器，咱们可以使用均衡器来调节咱们音频的各个频段，比如，我想让我的低音更加浑厚，我就可以调节EQ的20-150HZ的频段，如果你想让你的声音更加明亮，那可以调节500-1KHZ的频段,这个调节涉及到一些专业方面的知识，如果只是想让用户去使用的话，可以用苹果给我们更封装好的几个效果即可，这个就类似于photoshop和美图秀秀的区别。 typedef NS_ENUM(NSInteger, AVAudioUnitEQFilterType) &#123; AVAudioUnitEQFilterTypeParametric = 0, AVAudioUnitEQFilterTypeLowPass = 1, AVAudioUnitEQFilterTypeHighPass = 2, AVAudioUnitEQFilterTypeResonantLowPass = 3, AVAudioUnitEQFilterTypeResonantHighPass = 4, AVAudioUnitEQFilterTypeBandPass = 5, AVAudioUnitEQFilterTypeBandStop = 6, AVAudioUnitEQFilterTypeLowShelf = 7, AVAudioUnitEQFilterTypeHighShelf = 8, AVAudioUnitEQFilterTypeResonantLowShelf = 9, AVAudioUnitEQFilterTypeResonantHighShelf = 10, &#125; NS_ENUM_AVAILABLE(10_10, 8_0); 上面是一些苹果帮助我们定义好的滤波器，比如低通滤波器 衰弱高频、可以引发共鸣的 低通滤波器不过一般在清唱的时候这个用处不大，这个效果主要用到在配合伴奏的时候，如果伴奏音调过高，可以使用该方法适当的提高人声音调或者降低伴奏的音调， 可以通过如下方式使用,然后更改这个节点一些属性值。 AVAudioUnitEQ * eq = [[AVAudioUnitEQ alloc] initWithNumberOfBands:1];AVAudioUnitEQFilterParameters * filter = eq.bands.firstObject;filter.filterType = AVAudioUnitEQFilterTypeResonantHighShelf;filter.bandwidth = 10;filter.gain = 20; 3.AVAudioUnitDistortion：失真，这个就是我们常说的电音，一般说唱或者摇滚，重金属之类的曲风会用到这个效果，同样苹果给我们提供了预设的几个效果，如果不是有专业的需求我们可以直接使用。 typedef NS_ENUM(NSInteger, AVAudioUnitDistortionPreset) &#123; AVAudioUnitDistortionPresetDrumsBitBrush = 0, AVAudioUnitDistortionPresetDrumsBufferBeats = 1, AVAudioUnitDistortionPresetDrumsLoFi = 2, AVAudioUnitDistortionPresetMultiBrokenSpeaker = 3, AVAudioUnitDistortionPresetMultiCellphoneConcert = 4, AVAudioUnitDistortionPresetMultiDecimated1 = 5, AVAudioUnitDistortionPresetMultiDecimated2 = 6, AVAudioUnitDistortionPresetMultiDecimated3 = 7, AVAudioUnitDistortionPresetMultiDecimated4 = 8, AVAudioUnitDistortionPresetMultiDistortedFunk = 9, AVAudioUnitDistortionPresetMultiDistortedCubed = 10, AVAudioUnitDistortionPresetMultiDistortedSquared = 11, AVAudioUnitDistortionPresetMultiEcho1 = 12, AVAudioUnitDistortionPresetMultiEcho2 = 13, AVAudioUnitDistortionPresetMultiEchoTight1 = 14, AVAudioUnitDistortionPresetMultiEchoTight2 = 15, AVAudioUnitDistortionPresetMultiEverythingIsBroken = 16, AVAudioUnitDistortionPresetSpeechAlienChatter = 17, AVAudioUnitDistortionPresetSpeechCosmicInterference = 18, AVAudioUnitDistortionPresetSpeechGoldenPi = 19, AVAudioUnitDistortionPresetSpeechRadioTower = 20, AVAudioUnitDistortionPresetSpeechWaves = 21&#125; NS_ENUM_AVAILABLE(10_10, 8_0); 其实里面有些还是比较有感觉的，比如扭曲的立方体，或者外星人的喋喋不休等。有兴趣的可以说都试试 使用方式同之前的效果一样 AVAudioUnitDistortion * dist = [[AVAudioUnitDistortion alloc] init];[dist loadFactoryPreset:AVAudioUnitDistortionPresetDrumsBitBrush];dist.preGain = 4;dist.wetDryMix = 100; 4.AVAudioUnitDelay:延迟，延迟就是 发出一个声音之后，过段时间再次发出，一直衰减到听不见。类似咱们的回声。可以通过里面的属性去细微的调节延迟的时间、速度等。 添加音效：主要流程就是链式关系 input(Mic或者音频文件) -&gt;效果器-&gt;output 如果是多个音效 input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;output 我们以AVAudioUnitReverb效果为例 AVAudioUnitReverb * reverb = [[AVAudioUnitReverb alloc] init];[reverb loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom];reverb.wetDryMix = 100;//把混响附着到音频引擎[_engine attachNode:reverb];//依次链接输入-&gt; 混响 -&gt; 输出[_engine connect:_engine.inputNode to:reverb format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];[_engine connect:reverb to:_engine.outputNode format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops]];//启动引擎[_engine startAndReturnError:nil]; 同理添加多个音效则需要严格按照 input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;output 顺序来添加 综上：完成了以上所有操作后你就可以实时在耳机中听到自己经过音效处理过的声音了，而且这样带着耳机唱歌效果会非常好，声音洪亮不易跑调。还可以针对不同的曲风调整自己的音效。 声音混合、写入本地：我们需要把我们清唱的歌曲录制到本地，正常的录制时使用AVAudioRecorder来进行录制的，像这样 AVAudioSession * session = [AVAudioSession sharedInstance]; [session setCategory:AVAudioSessionCategoryPlayAndRecord error:nil]; [session setActive:YES error:nil]; NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; self.filePath = [path stringByAppendingPathComponent:@"SoWeak"]; self.recordFileUrl = [NSURL fileURLWithPath:self.filePath]; //设置参数 NSDictionary *recordSetting = [[NSDictionary alloc] initWithObjectsAndKeys: //采样率 8000/11025/22050/44100/96000（影响音频的质量） [NSNumber numberWithFloat: 8000.0],AVSampleRateKey, // 音频格式 [NSNumber numberWithInt: kAudioFormatLinearPCM],AVFormatIDKey, //采样位数 8、16、24、32 默认为16 [NSNumber numberWithInt:16],AVLinearPCMBitDepthKey, // 音频通道数 1 或 2 [NSNumber numberWithInt: 2], AVNumberOfChannelsKey, //录音质量 [NSNumber numberWithInt:AVAudioQualityHigh],AVEncoderAudioQualityKey, nil]; self.recorder = [[AVAudioRecorder alloc] initWithURL:self.recordFileUrl settings:recordSetting error:nil]; if (self.recorder) &#123; _recorder.meteringEnabled = YES; [_recorder prepareToRecord]; [_recorder record]; &#125; 但是很明显这样录制声音需要开启session 而声音的session是一个单利，如果这样开启了那么我们后面就不能用AVAudioEngine来进行音频采集了，也就没有之前的效果。所有根据以往的经验，AVAudioEngine在开启引擎之后一定会有一个delegate或者是block回调出采集到的数据的。于是我们找到了AudioNode中的这个方法：- (void)installTapOnBus:(AVAudioNodeBus)bus bufferSize:(AVAudioFrameCount)bufferSize format:(AVAudioFormat * __nullable)format block:(AVAudioNodeTapBlock)tapBlock; 其中的block的buffer 便是我们采集到的数据。 /*! @typedef AVAudioNodeTapBlock @abstract A block that receives copies of the output of an AVAudioNode. @param buffer a buffer of audio captured from the output of an AVAudioNode @param when the time at which the buffer was captured @discussion CAUTION: This callback may be invoked on a thread other than the main thread.*/typedef void (^AVAudioNodeTapBlock)(AVAudioPCMBuffer *buffer, AVAudioTime *when); 我们需要把buffer转成AVAudioFile然后通过AVAudioFile的write方法写入初始化AVAudioFileAVAudioFile * audioFile = [[AVAudioFile alloc] initForWriting:url settings:@&#123;&#125; error:nil];然后在block中实现[audioFile writeFromBuffer:buffer error:nil]; 这个时候写入成功然后播放本地录音文件发现只有自己的原生，并没有后面添加的音效，回音等效果。 其实是因为我们虽然添加了音效但是我们没有把音效和原生混合在一起，即使我们实时听到的是没有问题的，但是当保存到本地之后如果没有做混合，系统会默认将最原始的声音写入本地，这里我们需要用到 AVAudioMixerNode 他是继承与AVAudioNode 也属于一个特殊音频处理节点，使用方式和之前的音效节点一样，添加在所有的处理之后、输出之前即可，像这样 input(Mic或者音频文件) -&gt;效果器1-&gt;效果器2-&gt;Mixer-&gt;output 不过唯一需要注意的是这个mixer最好也写成属性、不然会出问题。 所以一个完整的带音效的清唱录制为：//创建音频文件。 NSString * path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString * filePath = [path stringByAppendingPathComponent:@"123.caf"]; NSURL * url = [NSURL fileURLWithPath:filePath]; AVAudioFile * audioFile = [[AVAudioFile alloc] initForWriting:url settings:@&#123;&#125; error:nil]; self.recordFileUrl = url; AVAudioUnitReverb * reverd = [[AVAudioUnitReverb alloc] init]; reverd.wetDryMix = 100; [reverd loadFactoryPreset:AVAudioUnitReverbPresetLargeRoom]; [self.engine attachNode:reverd]; [self.engine attachNode:_mixer]; [self.engine connect:self.engine.inputNode to:reverd format:audioFile.processingFormat]; [self.engine connect:reverd to:_mixer format:audioFile.processingFormat]; [self.engine connect:_mixer to:self.engine.outputNode format:audioFile.processingFormat]; [_mixer installTapOnBus:0 bufferSize:4096 format:[_engine.inputNode inputFormatForBus:AVAudioPlayerNodeBufferLoops] block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123; [audioFile writeFromBuffer:buffer error:nil]; NSLog(@"我录制到的数据是 === %@", buffer); &#125;]; [self.engine startAndReturnError:nil]; 总结通过如上方法可以完整的实现清唱功能，但是唱吧清唱使用的是AudioUnit，AudioUnit是iOS中音频的非常底层的实现，由C语言实现，因为唱吧中除了清唱之外还有很多非常复杂的音频处理功能，所以只有AudioUnit可以满足，但是对于清唱这个功能来说，两种实现方式达到了同样的效果，本文介绍的更加轻量级，不过关于AudioUnit也正在学习过程，后续会输出相应的文章。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>音频</tag>
        <tag>唱吧</tag>
        <tag>K歌</tag>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RxSwift的一点理解]]></title>
    <url>%2F2018%2F05%2F08%2FRX-Swift-Study-One%2F</url>
    <content type="text"><![CDATA[Hello RxSwift!这本书可以让你用Swift来编写响应式编程代码。但是到底什么是RxSwift,这里有很好的定义： RxSwift是由可被观察的事件的异步队列和可操作的功能性的运算符组成的库，并且他可以由调度者通过参数的方式进行调度。 听起来很复杂？其实不用担心，因为无论是你编写响应式编程，还是理解他们背后的思想和一些相关的东西，官方通常都是用一些很吓人的术语来解释。尤其是当你第一次接触，或者是之前从未有人向你介绍过这些的时候，你就会觉得很可怕。 本书的目标就是带你逐步的去理解RxSwift的API，并且去运用每一个API，然后把它们运用到实际的iOSApp中。 你将会从RxSwift中最基本的功能开始，然后循序渐进的由中级到高级。花一些时间去广泛的理解里面的概念，这样以来读完本书后你就会精通RxSwift额思想和使用。其实Rx是非常广的话题，以至于不能单单通过这一本书来讲完，因此我们通过这本书让你对RX有一个坚实的了解，这样你就能继续提高自己的Rx水平了 其实我们并没有非常确信RxSwift的思想是什么，让我们在这个章节里面通过几个简单的例子来帮助我们理解响应式编程。 RxSwift本质其实就是当你的数据或者对象发生变化时候他会把这个变化放在一个单独的管道(队列)里面,以此来达到简化异步并发的过程的目的 这里打个比方一个按钮我点击了就会触发一个时间 那么我每点击一次就会生成一个Action我们用一个管道去装在这些Action，每加一个Action就会把他放管道里面，我们可以理解为管道里面流动的Actions，且管道与管道之间相互独立。同理我们可以吧Button改成一个UITExtField，Action就是每一次输入事件。 作为一个iOS的开发者我相信这已经很好帮你去理解什么是RxSwift了吧，这应该是比你在一开始看到的那些专业术语好理解的多。 如果你还是不清楚，那么你至少应该理解，RxSwift可以很轻松的帮你编写异步操作的代码，你要知道编写异步操作的代码是比较难的，所以所任何一点点的帮助都是受大家所欢迎的。 异步编程的介绍如果你想用一种通俗简单的语言来描述异步编程，比如你在做一个iSO的App，那么你一定想到如下几个东西： 接受Button的点击事件 当text field的Action和键盘的弹出和收起动画之间的关系 从网上下载大图片 往硬盘里面存数据 播放视频 以上的所有东西看似是发生在同一时刻其实真的是吗？我们思考一个问题：比如你在看视频，这时候你点击了textfield弹出键盘，大家都知道键盘由下往上弹出是有一个动画的，就算键盘已经出现到了屏幕上，只要动画没有做完你的视频就不会暂停，真的是这样吗，内部又是如何实现的？如下图: 程序里面不同的部分不会阻塞彼此的执行，iOS提供了几种API，通过多核CPU来在不同的线程上进行不同的工作。 其实编写真正并行的代码其实是很复杂的，打个比方假如两个线程同时访问同一个资源，就会产生资源争夺的问题，比如谁先访问，谁后访问。 UIKit中的一些异步的API苹果在iOS SDK中提供了很多api，帮助你编写异步代码。你在你的项目中使用过这些但是可能还没有考虑过它们，因为它们是编写移动应用程序的基础。毕竟苹果爸爸封装好的，我们拿来用就好了，干嘛想那么多。 你一定用过以下几点 NotificationCenter delegate Grand Central Dispatch(GCD) Closures（Block） 由于大部分的类都是异步的，并且UI在内部也是异步的，所以很难去猜测整个程序的执行顺序，因此你的APp会因为一些外部的原因而表现不同，比如用户的输入不同、网络环境的不同、或者一些其他的东西。用户每次在打开你的APp其实代码的执行顺序都是不同的(当然除了一些自动化测试的场景，那些条件都是预先设置好的。) 其实写好异步代码并不是绝对不可能的，毕竟苹果给我提供了非常强大的API，相比较于其他平台这要好很多。不过问题在于编写复杂的异步代码很难，部分原因是因为苹果给我们提供了大量的SDK，而且他们并不统一。如果使用delegate我们需要遵循特制的格式，block，NotificationCenter等等都是这样的，所以并没有一种通用的、贯穿所有异步方法的API，这样就导致读懂并且书写这样的异步代码很难。可以看下下图: 我们来比较两个代码片段来总结下这章。一个是异步一个是同步。 同步代码对数组的每个元素进行操作你应该很熟悉了吧，其实就是循环遍历嘛。这是一个非常简单而又坚实的功能，因为它保证了两件事: 它是同步执行的。 在循环遍历时候他是不可变的 花点时间想想这意味着什么。当你遍历一个数组的时候，你不需要检查所有的元素是否仍然存在，并且您不需要重新返回，以防另一个线程在集合的开始插入一个元素。您假定您总是在循环的开始时遍历整个集合。试试以下代码: var array = [1, 2, 3]for number in array &#123; print(number) array = [4, 5, 6]&#125;print(array) 最后的输出结果： 数组在for循环中是不可变的吗？执行顺序是什么？ 异步代码再考虑一个类似的代码，如下用户通过点击事件触发下面代码，每次点击都会输出数组下一个元素，然后用户重复点击直到把数组所有的元素输出完成：var array = [1, 2, 3]var currentIndex = 0//this method is connected in IB to a button@IBAction func printNext(_ sender: Any) &#123; print(array[currentIndex]) if currentIndex != array.count-1 &#123; currentIndex += 1 &#125;&#125; 试想一下如果放在我们现实的App中真的可以这么执行吗？这个可说不准，因为如果在用户的两次点击之间又有其他的线程对这个数组进行了操作(增加、删除元素)那么数据就会发生错乱。而且如果currentIndex被另一个线程改变了那么你也不会得到预期的结果。 其实多线程最重要的就是数据争夺的问题，然而RxSwift很好的解决了这个问题]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AlamoFire的使用(下载队列，断点续传)]]></title>
    <url>%2F2018%2F03%2F30%2FAlamoFire%2F</url>
    <content type="text"><![CDATA[前言最近开始做了一个新项目，几乎没有时间来写自己的博客，大部分都在写feature（BUG），自己研究的东西很少，本来之前说好每个月要写两篇文章也没能坚持下来，最近在项目中遇到了一些问题，就在这里总结下吧。一些小的技巧而已，大神可以忽略了。 背景新项目包含了上传下载网络请求相关功能，由于是swift编写所以自然而然选择了 AlamoFire (好像也没得选)来做底层，正常的网络请求post、get等都是直接傻瓜式调用 AlamoFire 的接口，本文主要将一些细节问题 设置通用超时时间使用Alamofire发起请求时候有这两个接口 /// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,/// `method`, `parameters`, `encoding` and `headers`.////// - parameter url: The URL./// - parameter method: The HTTP method. `.get` by default./// - parameter parameters: The parameters. `nil` by default./// - parameter encoding: The parameter encoding. `URLEncoding.default` by default./// - parameter headers: The HTTP headers. `nil` by default.////// - returns: The created `DataRequest`.public func request(_ url: URLConvertible, method: Alamofire.HTTPMethod = default, parameters: Parameters? = default, encoding: ParameterEncoding = default, headers: HTTPHeaders? = default) -&gt; Alamofire.DataRequest/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the/// specified `urlRequest`.////// - parameter urlRequest: The URL request////// - returns: The created `DataRequest`.public func request(_ urlRequest: URLRequestConvertible) -&gt; Alamofire.DataRequest 而我们在调用的时候通常会直接这么用 let req : URLRequest = URLRequest(url: URL(fileURLWithPath: "32"), cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10) // 第一种方法调用，后面参数直接用default Alamofire.request(URL(fileURLWithPath: "32")) // 第二中调用，使传入request Alamofire.request(req) let semaphore = DispatchSemaphore(value: 0) 其中第一种方法我们不能传入超时时间，第二中方法我们可以通过传入的URLRequest来设置超时时间，但是我们通常一个项目中大部分的请求，可能除了某些特殊的下载请求之外所有的超时时间都是一样的，这样的话我们需要同样的代码写好多遍，这个时候有两个办法 对生成Request的方法做一个封装，通用的参数如超时时间、header、请求方式 写死在方法里面，对于会变动的参数如 URL 和可以通过参数传入. 创建 Alamofire.SessionManager 通过sessionManager来设置超时时间等一些通用的东西 let networkManager : SessionManager = &#123; let config : URLSessionConfiguration = URLSessionConfiguration.default config.timeoutIntervalForRequest = 10 let manager = Alamofire.SessionManager.init(configuration: config) return manager &#125;() 断点续传Alamofire支持断点续传下载，原理就是将下载一半的数据保存到本地，然后下次再启动时候通过data的拼接来进行继续下载。用法也很简单，只是调用接口而已，关键是看开发者如何自己去维护这个已下载的数据，比如是存内存还是存硬盘，要存多久，淘汰策略是什么之类的。其实就是两个步骤， 断点和续传 第一步 断点监听下载中断，中断后将已经下载的数据进行保留，我这边用一个属性来存，具体到项目实现大家可以采用自己存储方式，存到硬盘或者数据库之类的 Alamofire.download("http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4", method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) in return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, false)[0]+"123.mp4")), [.createIntermediateDirectories, .removePreviousFile]) &#125;.responseJSON &#123; (response) in switch response.result &#123; case .success: print("success") case .failure: //意外中断后在此处处理下载完成的部分 self.tmpData = response.resumeData default: print("failed") &#125; &#125; 第二步 续传当下载再次启动时候，需要在上一步数据的基础上继续下载，我们调用Alamofire这个方法/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.////// If `destination` is not specified, the contents will remain in the temporary location determined by the/// underlying URL session.////// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken/// on background URL session configurations. There's an underlying bug in the `resumeData` generation logic where the/// data is written incorrectly and will always fail to resume the download. For more information about the bug and/// possible workarounds, please refer to the following Stack Overflow post:////// - http://stackoverflow.com/a/39347461/1342462////// - parameter resumeData: The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`/// when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional/// information./// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.////// - returns: The created `DownloadRequest`.public func download(resumingWith resumeData: Data, to destination: Alamofire.DownloadRequest.DownloadFileDestination? = default) -&gt; Alamofire.DownloadRequest 这个接口需要我们传入已存在的数据，然后基于我们传入的数据进行下载，它支持从新指定目的地路径，如果你有需要可以重新指定Alamofire.download(resumingWith: tmpData!) 同样他返回一个request的对象，我们可以通过点语法来拿到进度、response等信息 批量下载当我们需要同时下载很多东西的时候，往往需要我们自己维护一个下载队列，比如下一个载素材列表之类的。Alamo给我们提供了下载的接口，但是下载的线程队列需要我们自己去维护，其实就是一个多线程并发队列。 GCD我们很自然而然的想到GCD，但是GCD有一个问题无法控制最大并发数，而且对队列的管理也并不完善，比如我们要下载100个文件，如果同时下载的话开辟100个线程，那肯定是不行的，先不说移动设备是否支持(最多70个左右)，即使支持了那这个开销太大。虽说GCD的话可以使用信号量进行线程控制，但是每个线程的暂停启动之类的又是问题，而且毕竟是曲线救国的方法。 OperationQueueOperation及OperationQueue是基于GCD封装的对象，作为对象可以提供更多操作选择，可以用方法或block实现多线程任务，同时也可以利用继承、类别等进行一些其他操作；但同时实现代码相对复杂一些。但是他毕竟不像GCD那样使用C语言实现，所以效率会相比GCD低一些。但是对线程的控制的灵活性要远高于GCD，对于下载线程来说可以优先选择这个。 实现我们把每一个下载任务封装成一个operation。注意Operation不能直接使用，我们需要使用他的子类，这里我选择使用 BlockOperation 他的闭包则是需要执行的下载任务，然后我们把他添加进queue中便开始执行了任务 let op : BlockOperation = BlockOperation &#123; [weak self] in Alamofire.download("http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4", method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil) &#123; (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) in return (URL(fileURLWithPath: String(describing : NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, false)[0]+"123.mp4")), [.createIntermediateDirectories, .removePreviousFile]) &#125;.downloadProgress &#123; [weak self] (pro) in let percent = Float(pro.completedUnitCount) / Float(pro.totalUnitCount) if count == 0 &#123; self?.downLoadLabel.snp.remakeConstraints &#123; (make) in make.width.equalTo(300 * percent) make.height.equalTo(30) make.top.equalTo((self?.stopButton.snp.bottom)!).offset(30) make.left.equalToSuperview().offset(30) &#125; &#125; else &#123; self?.downLoadLabel2.snp.remakeConstraints &#123; (make) in make.width.equalTo(300 * percent) make.height.equalTo(30) make.top.equalTo((self?.downLoadLabel.snp.bottom)!).offset(30) make.left.equalToSuperview().offset(30) &#125; &#125; &#125;.responseJSON &#123; (response) in switch response.result &#123; case .success: print("success") case .failure: self?.tmpData = response.resumeData default: print("failed") &#125; &#125; &#125; queue.addOperation(op) 每一个opeeation对象我们都可以设置他的优先级、启动、暂停、等属性，简单的调用接口就可以，在此就不一一作解释了。然后我们需要对我们的queue进行设置，我们设置最大并发数，大家可以根据实际情况来设置，demo中我只有两个下载任务，所以我就设置最大并发数为1 这样就是一个一个下载。let queue : OperationQueue = &#123; let que : OperationQueue = OperationQueue() que.maxConcurrentOperationCount = 1 return que &#125;() 我们运行然后点击开始下载 很奇怪我们发现他还是同时下载，我们又试了其他的个数，无论多少都是同时下载，最大线程数量完全不起作用，再反过来看下上面加入queue的任务。正常来说每一个operation都要等上一个operation完成后才会执行，而系统判断完成的标准就是上一个operation的闭包走完，我们闭包中放入的是一个下载任务，而Alamofire的下载都是异步执行，所以导致operation的闭包走完了，但是其实下载是异步在另一个线程执行的，实际上下载没有完成，知道原因我们对症下药，只需要保证operation闭包中的代码是同步执行的就OK了。而Alamofire是基于URLSession来实现的，并没有像connection那样提供同步的方法，所以我们使用信号量卡一下，像这样 这样之后就会按照我们设置好的队列进行了 有人会说下载同步进行会不会有影响，其实不会的首先我们实现同步的方式是信号量，本质上还是异步的只是我们阻塞的当前的下载线程，这个被阻塞线程一定不是主线程(除非Alamofire的开发者把他回调到主线程下载，这个基本不可能)，而且当我们把这个下载任务加到一个operation中之后，就注定不会在主线程中了，没一个operation都会被系统分配到一个非主线程的地方去做，所以这样不会性能有任何影响。 总结因为时间紧迫，暂时做了这么多，也遇到了这些问题，所以写出了总结下，本文还会继续更新，会慢慢的整个网络层分享出来。就是可能更新会慢，毕竟工作量有点饱和。多谢关注 var options = {"narrow":false,"autoplay":true,"showlrc":0,"mutex":true,"music":[{"title":"Thank You Very Much","author":"Margaret","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/Thankyou.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000000VbGX83hRicw.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=001Ii3g54dIYpO"}]}; options.element = document.getElementById("aplayer4"); new APlayer(options);]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的iOS线上热修复方案]]></title>
    <url>%2F2018%2F03%2F14%2FSimple-HotFix-Mtehod%2F</url>
    <content type="text"><![CDATA[向大佬致敬总是喜欢把参考资料、致谢等写在文章最前面，毕竟是站在人家的肩膀上，向大佬致敬，写这篇文章的也是参考他的 然后加上一些自己的思考，主要目的还是自己再写一遍Demo和文档，以便加深记忆，也帮助自己更好的理解，有句话说：看懂的东西不一定就是学会了，自己能在不看资料的前提下写出来才算是略知一二。 以下是 原文链接有兴趣的还可以看下大佬博客 工作原理分析要实现热修复其实原理就是我们可以动态的修改代码，在方法前、中、后插入自己想要的东西或者代码。其实这个需求并不难，iOS的运行时机制可以满足我们的这个要求，但是如果是已经上架了的APP,已经打成了Ipa包我们该如何修改呢？这里就需要服务端去控制，通过下发不同的内容来达到我们想要的目的，但是这里有一个要求，服务端所下发的内容并不能是任意的，而是要通过下发的内容调起我们App内的RunTime机制然后进行偷梁换柱。满足这个要求的数据格式只有字符串化的JS代码，因为我们知道在iOS中JS代码是可以调用OC的代码。综上所述打到热修复整套流程所需的技术如下： Runtime： 可以在本站搜索Runtime关键字找到Runtime相关资料 与服务器交互： 现在大部分APP都具有于服务端交互的能力，就是我们常说的网络请求AFNetWorking等 JS与OC交互： 大家可以参考这篇文章，主要参考方式二，使用JavaScriptCore进行交互 进行了上述操作后每次用户启动，App都会进行如下操作 这样一来如果开发在项目发布出去后发现有Crash那么可以立即通过服务器下发JS代码来制定APp每次执行新方法(新方法的定义也是在下发的JS代码中)，可以避免一些问题。 实际使用第三方这里用到一个第三方库Aspects这个库可以理解为一个iOS中的Runtime库，我们不用写繁琐的代码，直接调用他的接口即可， + (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 其中的枚举就是选择我们要插入方法的位置，其中包含 typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123; AspectPositionAfter = 0, /// Called after the original implementation (default) AspectPositionInstead = 1, /// Will replace the original implementation. AspectPositionBefore = 2, /// Called before the original implementation. AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// Will remove the hook after the first execution.&#125;; 这个库据说是对上线没有影响。 配置工程用实际代码来证明下，这是我Controller中的一个代码，很明显会产生数组越界的Crash，假如我们在上线后才发现了这个问题，这时候需要修复 #import "ViewController.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self crashMethod:0]; // Do any additional setup after loading the view, typically from a nib.&#125;- (void)crashMethod:(NSInteger)argument&#123; if (argument == 0) &#123; NSArray * arr = @[@"1"]; [arr objectAtIndex:2]; &#125;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 导入上面说的那个第三方.h和.m 然后自己建立一个桥接类，用来处理JS和O的交互，大概的结构就是这样 其中交互类中暴露出如下接口 #import &lt;Foundation/Foundation.h&gt;#import "Aspects.h"#import &lt;objc/runtime.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@interface Felix : NSObject/** 初始化 */+ (void)fixIt;/** 开始执行JS代码 @param javascriptString 需要执行的JS */+ (void)evalString:(NSString *)javascriptString;@end .m文件的内容可以到大佬博客中参考这里不放出，不然篇幅太长。 开始使用因为我们最好用能控制代码里面的所有方法，所以我们要尽早的注册交互类，在APpdelegate中如下注册 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. [Felix fixIt]; NSString *fixScriptString = @" \ fixInstanceMethodReplace('ViewController', 'crashMethod:', function(instance, originInvocation, originArguments)&#123; \ if (originArguments[0] == 0) &#123; \ console.log('crash！！！！！'); \ &#125; else &#123; \ runInvocation(originInvocation); \ &#125; \ &#125;); \ \ "; [Felix evalString:fixScriptString];// 如果是多个方法建议用循环执行// NSArray * hotFixStr = @[fixScriptString];// for (int i = 0; i &lt; hotFixStr.count; i ++) &#123;// [Felix evalString:hotFixStr[i]];// &#125; return YES;&#125; 其中JS的代码就是我们所要修改的内容，可以看到当参数为0的时候输出crash！！！然后不再继续执行了。实际项目中这段代码是由服务器动态返回的，如果我们要修改多个方法，就需要服务器返回JS字符串数组我们这边来进行循环处理即可。这时候在运行下代码不会崩溃，下面会输出一个crash！！！！ 思考这个方法相比较之前的JSpatch 是非常轻量级的，而且也只是实现了简单的容错功能，并不能做一些复杂的操作，比如生成一个对象之类的，不过对于一般的控制已经可以满足了，毕竟在苹果爸爸这么严厉的管制下能有这样的方法也还不错啊。 var options = {"narrow":false,"autoplay":true,"showlrc":0,"mutex":true,"music":[{"title":"不知归期的故人","author":"房东的猫","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E4%B8%8D%E7%9F%A5%E5%BD%92%E6%9C%9F%E7%9A%84%E6%95%85%E4%BA%BA.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004NFJ230yX0Nz.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=000zreoj2VtcID"}]}; options.element = document.getElementById("aplayer3"); new APlayer(options);]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>热修复</tag>
        <tag>JSPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[At The End Of 2017]]></title>
    <url>%2F2018%2F02%2F12%2FAt-The-End-Of-2017%2F</url>
    <content type="text"><![CDATA[前言今天是2017年的最后一个工作日，准确的说是我最后一个工作日，公司的同事都走的差不多了，寥寥无几的办公室显得格外冷清，和安静，不过越是这样的环境越容易让我回忆、感慨，因此便有了这篇文章。 我的一些朋友在元旦的时候就做了总结，而我选择在了这个时候，因为我觉得虽然是12月31日，但是我的工作并没有停止，旧的工作没有做完，新的工作还没时间规划，元旦也只是个小长假而已。虽然现在对于明年要做的事情也还是没有详细的定位，但是大致的方向应该算是有了。 辞旧只有辞旧才能迎新，说实话2017年收货真的不小，今年也是我在美图成长最快的一年。2016年6月12日凌晨从北京匆匆赶来深圳，一天的时间紧紧张张，办了户口，办了社保转移之类的手续，下午又来到公司楼下踩点儿，防止第二天入职的时候找不到地方。13号正式成为Meitu的一员，刚开始都是陌生的，也可以说是懵逼的，接触的东西多了就会发现自己欠缺的东西也多了，什么都想要学，从入职到17年其实都是在适应期，没有什么实质性的进步，不过真的是涨了见识，知道了很多东西。 记得来深圳之前一个前辈跟我说过：“当你去到一个新的城市一个新的公司大多数人都需要半年左右的适应期，适应期内会觉得和公司格格不入，各种不爽，等这一阶段过去了那就会突飞猛进。”一开始我还不相信，但是现在真的知道了。半年的适应期过去了，2017年逐渐步入正轨，这也是我在一开始说2017年是我个人成长最快的一年，不光是技术，还包括其他精神层面的一些东西。 学习相关SDK毕竟是做开发的，还是先从技术说起，这一年完成了iOS端的DNS解析耗时优化SDK，也可以叫做HttpDns。其实这个东西原理很简单(这里就不在赘述，毕竟不是技术文章，想了解更多的可以在我的小站搜索 httpdns 字段)。但是做了很久，刚开始做的时候，我想应该是业内的前几名吧，我只看到过腾讯，阿里有过相关的文档，而阿里的也只是实现了简单的几个功能而已，腾讯的不开源，不过应该也不会有多深入。除此之外没有任何有用的文档，自己一点点摸索，一点点踩坑，项目接了好久都是有问题，也不稳定，那段时间真的很难，很痛苦。好在最后慢慢都克服了，当我把最终的文档放到网上，确实赢来了很多的阅读量，还被推上过头条，我想这就是对我付出努力的回报吧，着实很欣慰。唯一的遗憾就是由于涉及到一些业务的代码，无法做到开源。不过这将是我2018年的目标。 App其实完整的App没有做，但是也主要维护了一个App，刚接到代码看了下最早的代码是2012年，一些第三方库也比较老。老旧的代码，无法发挥新设备的性能，于是开始重构、优化，几年前写代码的人大部分离职了，只能自己看，看不懂了就用自己的方式重写。每次App上架后盯着崩溃的后台看，是否产生了新的问题、旧的问题是否修复，然后看App Store用户的评论，用户最关心什么，用户会产生哪些问题，都一一记录，修改，其实每当这个时候感觉还是挺幸福的，而且正好赶上iPhone X发布，新的屏幕适配早就做好了，就等着真机出来去看看，应该也是公司第一个完成适配的App，虽然当时有些小问题还没有发现。后来看着产品越来越稳定心里也是很爽的。 其他翻译过几篇文章、尽量保证每周在公司做一次技术分享(感谢我的leader让我养成这个习惯)、建立了个人博客开始记录自己的生活、在一些技术论坛上有了属于自己的粉丝，不过我不是大佬，只是和大家沟通、讨论罢了。 生活相关情感2017年首先是换了一个工作的城市，其实是为了逃离北京的雾霾，也是为自己更好的发展，不得不承认南方的环境确实要比北方强一些，政府机关的办事效率也更高一些。三月份妹子为了我也来到了深圳,真的很感动，横跨了整个中国来找我，她虽然没什么怨言，但是我知道对于一个女孩子来说这意味着什么，有时候她开玩笑总是说我没有感情，其实我只是不善表达而已，作为一个军人家庭出身的孩子，我完美的受到了家庭的影响，说一不二，对她从来不惯，从来不哄，不能容忍她矫情，不能容忍她挑食，有时候严厉的真的像我的父亲对我一样，但是同样我也会对她绝对的忠诚，因为还是很爱她，不管以后如何，她已经是我生命中除了母亲之外最重要的人。 旅游可能是因为沿海城市很方便的原因，这一年我们去了不少城市，走过不少地方， 其实还有很多地方，只是大部分照片没有传到google相册里，google的相册我的初衷是用来保存livephoto的。那天看到妹子用一个本子记着我们一起去过的地方，我才发现我们走过不少地方。我当时想我可以做一个小App把这些地方记录下来，但是遭到拒绝，她说出去旅游就是为了放下工作，去寻找大自然中最原始，最纯净的东西，她不想因为这个增加我的工作量，而且用最原始的纸和笔更符合旅行的意义。 香港 澳门 上海 西塘 Kota Kinabalu Semporna 还有很多地方拍了很多照片，现在看下真的是很美好的回忆，后来我和妹子一直认为，以后即使再忙也一定要多出去走。这也是为什么我过年没有使用年假，因为年假基本会攒到出国。以后我的博客可能会开出相册模块，记录下更多的美好。 其他2017年也有经常健身吧，因为南方空气潮湿湿气重，如果不让自己保持大汉淋漓的话很容易生病。坚持过几个月，但是后来因为工作忙，加班等借口还是没坚持下来，没有父亲的监督果然靠自己不行。说好的八块腹肌已经要九九归一了。不过也真的明白身在异乡什么时候最孤独，最无助，那就是生病的时候。 我的2017 差不多就这些东西，可能跟大佬们比起来真的是小打小闹，但是过得充实，心里踏实只有自己懂。 迎新2018年在短短的休息之后就会到来，虽说没有做好万全的准备，但是至少不会手足无措。 学习相关 还是学习为主，首先要做的就是把自己的apple的开发者账号续费，自己可以做一些练习、App之类的东西，同时把各种证书、打包，持续集成这块整明白。毕竟现在用公司的证书不敢乱弄。 自己从零到一做一个直播的App不管是绿色直播还是成人直播，一定要做出来保证完美运行。 雅思词汇全掌握。 壮大自己的博客。 生活相关 去一到两个国家。 五公里坚持下来。 成都，重庆，云南…. 其他之所以没在迎新中写太多东西并不是因为没计划，而是有些东西不想在这里说出来，用老罗的话说就是万一实现不了，丢人。 我记得看过一本书说“伟大的人不是努力学习新知识的人，而是善于总结的人。”我也不求变成伟大的人，只是希望自己的每一年都有所收货，希望自己做好迎接新一年的打算，希望过得踏实点。 最后在这里给大家拜个早年：祝大家新年快乐，心想事成。新的一年我会与大家分享更多的东西 才疏学浅，文笔拙劣，于2018.2.13仓促执笔…. var options = {"narrow":false,"autoplay":true,"showlrc":0,"mutex":true,"music":[{"title":"에필로그 (Epilogue)","author":"이동준","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000","lrc":"https://歌词.lrc"}]}; options.element = document.getElementById("aplayer5"); new APlayer(options);]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>回味2017展望2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博客评论插件的讨论]]></title>
    <url>%2F2018%2F02%2F11%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考资料习惯把参考资料写在文章的前面，毕竟是踩在人家的肩膀上，先有他才有我这文章，前后顺序不能乱。他的这篇文章总结的很全，但是对于每一个评论还欠缺细致的描述，这篇文章下我会做些补充， 之前用的livere关于博客的评论插件,在最开始的搭建博客之前就有过考虑和纠结，国内的评论界面浮夸流程繁琐，且服务不稳定，说倒就倒，比如多说；国外的又时刻面临着被墙的风险，自己搭建服务器虽说不难，但是也没有精力去搞这些。后来使用了livere，韩国的产品，一开始被他简洁的界面方便的后台吸引，而且还支持各种移动APP登陆，微信、QQ之类的。不过后来使用过程中缺点显现出来了。 缺点1：手机端适配不好，手机端无法进行微信登陆。2：评论无法导出，不过如果哪天他也要挂了说不定也会支持导出，毕竟实现不难。3：经常发评论时候当前页面卡死，其实已经发送成功了，但是界面一直卡在loading。4：加载比较慢一些。 其他的评论插件综上所述我决定换掉它，这种东西要趁早，不然等评论多了还需要朱转移操作。下面说下其他评论插件，因为之前放了大佬的文章，他总结的也很全面，我这边就挑几个大家耳熟能详的来说，而且只说缺点。 disqus他唯一一个缺点就是被墙了，他要求每一个看你博客的读者都要科学上网才可以，对于我的博客来说，不仅仅是写一下技术文档，有时候会更新下照片、游记之类的，所以不想对读者有太高的要求。 搜狐畅言搜狐旗下的评论系统，比较靠谱，有搜狐做后盾也不会轻易说没就没，但是对于我来说他有着太强烈的中国元素，域名、网站需要备案，而且他的界面是在是夸张，又是盖章，又是浮窗的，有种”大扎好，我系渣渣辉”的感觉。 过年了，放上了红灯了，红鞭炮，而且水印还去不掉。最最关键是你发评论要登录，如果是用微信登陆还必须要先关注他公众号. 关注成功后还需要你绑定手机号，虽然不是强制让你绑定，但是如果你不想绑那么好，你每点击一下就会弹出绑定手机号的窗口。对于我一个主打技术的博客来说确实不太适合，如果大家想写一写娱乐微博说不定适合你。 Gitment基于github的issue实现的，唯一一点不好的就是使用Gitment评论一定要用github账号登陆，这点对于读者来说要求有点高吧。 Valine比较优秀的一款轻量级评论插件，这个也是我最后纠结很久的，Valine依赖于Leancloud的后端服务，我们需要去leanclould注册一个账号，里面分为免费版和商业版还有企业版。后两个价格对于我来说有点高，如果有钱的大佬可以无视。 免费版有一定限制首先API请求每天30000，你可以暂时理解为每天30000条评论吧(实际不到这个数，你还要刷新之类的)，这个其实对于我来说已经够了，如果你是浏览量非常大的微博 那可能有点悬；10GB的储存空间是我最担心的，永久10G总有一天就会满，到时候只能升级付费版，或者换一个评论平台，不过还好，因为他是支持markdown的，所以图片GIf的之类的都是通过链接形式，10G应该够用一阵了。不过也正是因为这个markdown编辑也需要一定的语法基础，不会markdown的传图片还是麻烦事，多为读者考虑嘛。还有一个最致命的就是他没有管理员的概念，即使你是本文的作者，那你在下面评论或者和网友互动的时候也是没有任何显示的，就像普通评论一样，这个就有点不方便了。 Hypercomments这个也是我最后选择的评论插件，同样也提供付费和免费的服务 免费版完全满足我的博客使用，没有发现以上一些第三方的缺点，同时界面也不错，唯一不足的就是新评论的邮件提醒不知道怎么调出来，我在后台配置了但是并没有提醒。综上所述整体还是比较稳定的。 最后大概就这么多，顺便祝大家新年快乐，阖家幸福！ var options = {"narrow":false,"autoplay":true,"showlrc":3,"mutex":true,"music":[{"title":"Love Story","author":"린 (LYn)","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg"}]}; options.element = document.getElementById("aplayer1"); new APlayer(options);]]></content>
      <categories>
        <category>通用开发</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
        <tag>网站</tag>
        <tag>评论插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于iPhone X下Home键的隐藏和延迟响应]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%85%B3%E4%BA%8EiPhone-X%E4%B8%8BHome%E9%94%AE%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[iOS 11通用相关Edge ProtectiPhone X 刚出来的时候苹果第一时间更新了新设备的交互文档，其中针对了大家最关心的“系统手势和App自带手势冲突”的问题也给出了相应的解决办法: 虽然苹果用黑体字写着强烈不建议开发者干涉系统的手势，但是为了增强用户体验还是开出了接口，苹果管这个叫做 “edge protect” 因为进入App后系统手势都是从边缘触发，引起冲突的地方也会是在边缘中。 根据官方文档描述，在冲突区域第一次执行手势的时候会优先触发App的内部手势，当短时间内再次进行同样的操作则会触发系统手势。也就是将系统手势延迟到下一次执行。 API Discussion根据官方文档找到对应的API // Override to return a child view controller or nil. If non-nil, that view controller's screen edges deferring system gestures will be used. If nil, self is used. Whenever the return value changes, -setNeedsScreenEdgesDeferringSystemGesturesUpdate should be called.- (nullable UIViewController *)childViewControllerForScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);// Controls the application's preferred screen edges deferring system gestures when this view controller is shown. Default is UIRectEdgeNone.- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);// This should be called whenever the return values for the view controller's screen edges deferring system gestures have changed.- (void)setNeedsUpdateOfScreenEdgesDeferringSystemGestures API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos); childViewControllerForScreenEdgesDeferringSystemGestures该方法是用来控制子试图控制器是否允许开发者控制edge protect的开启或是关闭。如果实现了这个方法并且返回值不为空那么子VC的edge protect设置就会遵循父VC的设置，跟随父VC是否延迟执行系统手势。 preferredScreenEdgesDeferringSystemGestures该方法是设置edge protect的方法，返回值是一个边界的枚举 typedef NS_OPTIONS(NSUInteger, UIRectEdge) &#123; UIRectEdgeNone = 0, UIRectEdgeTop = 1 &lt;&lt; 0, UIRectEdgeLeft = 1 &lt;&lt; 1, UIRectEdgeBottom = 1 &lt;&lt; 2, UIRectEdgeRight = 1 &lt;&lt; 3, UIRectEdgeAll = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight&#125; NS_ENUM_AVAILABLE_IOS(7_0); 因为不论我们从shang、左、下、右边都可触发系统手势，所以方法保护了四个边框，将边界触发的手势延迟执行，这个方法从iOS11开始使用，不过枚举中虽然有左右的边界保护，但是系统手势中还不清楚左右滑动会触发什么效果，实验发现对于VC的左边界右滑动pop手势是无效的，也就是说这个pop手势一直有着最高的优先级。不过上下就很好理解，底部上拉出控制中心，顶部下拉是通知中心。 无限制 当不做任何限制时候在顶部和底部很容易触发到系统的手势，他们会优先于Tab.eView的scroll手势执行，虽说屏幕大部分的界面还是执行TableView手势的，但是当用户误触到边界的时候还是会稍稍影响体验，尤其是在全屏模式下、相机、视频、游戏等 Edge Protent 在对应的ViewControll中添加如下代码，我们这边开启的是所有边界限制其中包括了上、下边界。在下拉或者上拉的话会先触发App内部手势，同时出现一个小箭头然后在箭头消失之前再次滑动就会触发系统手势。 -(UIRectEdge)preferredScreenEdgesDeferringSystemGestures&#123; return UIRectEdgeAll;&#125; setNeedsUpdateOfScreenEdgesDeferringSystemGestures这个方法是在应用内部动态控制edge protect，我们可以在上个方法中返回一个BOOL变量，然后根据需要改变该变量的值，然后调用该方法进行刷新。 iPhone X使用相关iPhone X在系统手势上面交互和其他设备还是有一定区别的，因为加入了Home Indicator的原因，引入了新的手势，同时对以往的手势也做了相应的调整。 iPhone X Edge Protect在iPhone X 中通知中心和控制中心全部都移动到了由顶部刘海处下拉和右上角下拉来触发。原本底部的所有手势都被Home Indicator占用。其实Edge Protect在这里依然适用，只是对于Home Indicator的手势有一个小插曲。正常来说他在底部，就应该受到UIRectEdgeBottom 或者是 UIRectEdgeAll控制，但是一开始苹果并没有这么做，不论怎么写代码，他都有着最高的优先级，在iPhone X刚发布我就试图去处理交互问题，因为海报工厂并没有传统的UITabBarController，且里面所有的tableView都是直通到底，但是始终都无法延迟执行与Home Indicator相关的任何手势。 后来看了其他游戏，视频类App在iPhone X上的表现也都是如此。腾讯的王者荣耀，网易的吃鸡都是一样。腾讯官方给出的解释是暂时开起引导式访问，也仍然不方便。后来在今年1月25日苹果推送了iOS 11.2.5的版本更新，然后王者荣耀也跟着进行了一波更新，在进入游戏时候就会发现，底部的Home Indicator当你一段时间不去触碰它的时候由黑色或者白色(根据当前的屏幕显示的内容来决定)变成非常透明的灰色，当你第一次进行操作会默认执行App内手势，同时激活Home Indicator，短时间内进行第二次操作就可以返回桌面 一开以为是有新的API出现，不过看了交互文档并没有新的东西，而且小版本的系统更新应该也不会出现新的东西。所以找到了之前的edge protect 代码运行后确实可以达到效果。对于视频，游戏等App，确实可以起到很好的防误触的效果。遗憾的是并没有太多的人使用这个功能。目前主流的大型游戏，包括Gameloft出品的游戏都没做相应的处理。 iPhone X Home Indicator Hidden如果说上面的Edge Protect适合在游戏中使用，那么Home Indicator Hidden则更适合在非游戏环境下增强App的沉浸感，尤其是全屏视屏播放、录制的时候。同样三个API，和Edge protect的用法完全一样。 // Override to return a child view controller or nil. If non-nil, that view controller's home indicator auto-hiding will be used. If nil, self is used. Whenever the return value changes, -setNeedsHomeIndicatorAutoHiddenUpdate should be called.- (nullable UIViewController *)childViewControllerForHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);// Controls the application's preferred home indicator auto-hiding when this view controller is shown.- (BOOL)prefersHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);// This should be called whenever the return values for the view controller's home indicator auto-hiding have changed.- (void)setNeedsUpdateOfHomeIndicatorAutoHidden API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos); 上面写的是自动隐藏，也就是说系统会根据当时的使用情况来进行显示或者隐藏，而不是永久的隐藏掉，实际测试发当界面两秒内没有进行任何交互操作的时候Home Indicator会逐渐隐去，直达屏幕上出现了点击的操作，注意是点击，TableView的滑动并不能触发显示，不过只是是隐藏，但是手势依然可以使用。 如果是feed流界面搭配酷一点的UI就会提高沉浸感，比如这样： 有的人可能会问如果说点击的手势会触发它再次显示那我获取window上的交互每次在它即将显示的时候通过setNeedsUpdateOfHomeIndicatorAutoHidden在让他隐藏不就好了吗？这样一来既不影响系统手势也不会让它在显示出来，其实我自己试过不行的，毕竟苹果不会让你这样改。 坑点需要注意的是：prefersHomeIndicatorAutoHidden和preferredScreenEdgesDeferringSystemGestures不可一起使用，如果一起使用的话后者是不生效的。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>屏幕适配</tag>
        <tag>iOS 11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能是最全的使用HEXO搭建个人博客教程]]></title>
    <url>%2F2018%2F01%2F25%2F%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[背景作为一个开发者不能没有博客，最近花了几天的时间搭建了这个博客，处理了很多细节，在这篇文章中我会把我从开始到现在以及后续的优化整理出来，帮助更多的人搭建、维护、更新、自己的博客。 一开始我所有的博客都写在新浪微博，因为微博上更容易推广自己的文章，微博用户量大，但是后来微博的弊端慢慢的显示出来了，毕竟不是开发者的天地，我的博客中经常会插入大量的代码，而微博不支持markdown编辑，普通的编辑器对代码块的兼容性非常差，别说高亮了，有时候排版都会错乱，最后外观很不好看，如下图： 而且微博的账号系统也存在一定的弊端，所以后来转向简书、掘金等技术平台，不得不承认相对于微博来说这些平台对开发者就要友好多了，不过后来又发现一个问题。因为我在写文章的时候使用的是本地的markdown编辑器，而这些平台对markdown语法的一些小细节并不严谨或者说统一如下图： 两个平台的编辑器无法做到统一，以至于每次写完文章都需要针对两个平台做不同的修改。 综上所述，最简单的也最一劳永逸的方法就是搭建自己的博客平台，而HEXO很好的帮我们解决了这个问题，其实对于一个开发者来说并不是什么难事，整个流程对于大部分有代码基础的开发者来说一上午时间就可以搞定，不过最难的也是最头痛的就是对细节的调整，对UI的修改、优化等，不过本文会对此逐一讲解。 环境配置 Node.js cURL: $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 $ nvm install stable Git 一般的开发者不会没有这个吧，我是安装Xcode就会有这个了， 使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装 bitbucket账号 一般都会使用HEXO+GitHub page的形式搭建自己的博客，但是这里有个问题就是GitHub是开源的，任何人都能在上面看到你的源代码，虽然这并没有什么太大的影响，不过对于我来说感觉怪怪的，所以我就用了bitbucket page来处理我的博客，所有的东西都一样只不过这个是个私有库罢了（免费五个人） 开始建站第一步：创建仓库进入github/bitbucket（后续都以github为例）新建repo，这里要注意repo的名字一定要满足your Account Name/github.io。如果是bitbucket那就是your Account Name/bitbucket.io，因为只有这样的仓库名称最后才能以静态页面展示。如图：XXX的内容一定要与红色的框里的文本一致。 第二步：创建本地文件夹创建文件夹之后CD到你创建的文件夹中执行hexo的初始化相关命令 $ hexo init$ npm install 执行完毕之后你的文件夹里就有内容了，标准的目录结构是这样（只列出几个必要的文件夹及其子目录） ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：其中我们以后的大部分操作都会在_config.yml中进行，这个文件是我们的站点的配置文件。 scaffolds：模板文件，规定了我们创建一篇文章的时候最开始的样子， source：可以暂时的理解成我们文章的存放处 themes：主题文件 第三步：部署到Git修改我们的的站点配置文件_config.yml中如下字段 其中： type值对应的是你所部署的的服务器类型，我们这里填写git就可以。 repo是你的仓库地址，也就是仓库克隆的地址，推荐用https的链接。 branch不写默认是master，通常我们写成master就可以。 以上配置完成后保存 然后回到终端执行npm install hexo-deployer-git --save安装一个插件，这样才能将你写好的文章部署到github服务器上并让别人浏览到。安装完成后在终端中依次执行如下代码(为了简单后续统称为三步) hexo clean 清理缓存 hexo generate 进行渲染 简写 hexo g hexo server 部署到本地(调试使用) 简写 hexo s。然后浏览器输入 http://localhost:4000 就可以看到你博客的效果啦，不过这是本地调试用，其他人是看不到的。(调试完毕后记得 control + C 关闭本地端口，不然下次就进不去啦) 调试完毕后使用 hexo deploy 简写为 hexo d来部署到git服务器。 执行完以上操作后打开浏览器地址了输入http://你github名字.github.io就可以看看到效果啦，这回是所有人都能看到的，用手机也可以。至此第三步已经完成,最终的结果如下图： 第四步：写文章使用如下命令 hexo new post “文章名字” 就可新建文章啦，建立好的文章在 source/_posts 中，你可以用markdown语法编辑内容就可以。编辑完成后执行第三步中终端的操作就可以啦，刷新下浏览器就可看到你的新文章啦。如下图: 个性化一：主题获取主题是我么个性化的基础和前提，我们想做任何个性化上的修改基本上都是在我们主题上的修改，先找到一个自己满意的主题是首要任务。关于主题网上有很多很多，HEXO官方的主题目录也收录了好多来着世界各地开发者的主题。或者开发者也可以直接去网上搜索HEXO theme关键字来获取主题。 安装主题一般都是repo，只要讲起clone到博客目录themes/XXXX下就可了，XXXX对应的就是你给主题起的名字，像这样：git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet 这样就可以保证每次主题的作者有更新了我们就可以 pull获取更新。不过这样有个问题后面我会在HEXO多终端同步一栏讲到，所以这里我们选择另一种方式去安装，就是直接把主题的repo下载下来然后解压放到themes中。其实对于已经稳定的主题作者一般不会频繁更新，不稳定的主题我们也不会用，所以用后者安装也是一样的。 然后我们回到刚才的站点配置文件中_config.yml修改如下字段，对应的名字就是你刚才那个主题文件夹的名字：我这边是next， 然后保存，再去终端执行那三步，接着刷新网页就可以看到新的界面啦。下面是我换了NEXT主题刷新后的效果。因为该注意已经非常完善，所有后续用该主题做例子来讲 二：主题菜单添加按钮主题菜单也可以说是主题按钮。也就是上面顶部的两个，next主题默认的两个是Home、Archive，我们一般会加上tag about category等。这些都是需要在主题上进行修改，我们需要修改主题的配置文件，首先在主题的文件夹下找到_config.yml文件，没错和之前的站点配置文件同名，只不过他们的路径不同，大家千万不要弄混，站点配置文件是配置站点通用的东西，而主题配置文件是配置一些主题的元素。在主题配置文件找到menu字段 可以看到主题作者注释掉了一部分按钮只保留了两个最基本的，这里需要注意前面的Key并不是代表的是按钮名字，因为该主题是支持多语言，所以这个key只是个标识，具体的按钮名字要去该路径下查找 其中每一个文件对应了不同的语言，我们以汉语为例，进入zh-Hans.yml中修改这些字段 其中key就是之前我们在主题配置文件中的key，而后面的value则是简体中文状态下按钮的名字。修改完成后我们保存执行那三步就可以看到我们新添加的按钮了。 添加页面添加按钮后我们需要点击按钮显示统一的页面。这时候我们需要添加页面。以tag页面为例，hexo中添加页面的命令是hexo new page XXXXX 后面XXX则是要添加页面的名称，我们这里写tags。为了测试新建的tag页面我们对之前的页面添加个tag。去 source/_post中找一篇文章我们在开头添加如下字段,多标签以此类推 然后编辑我们刚才生成的tag页面(source/tags/index.md)指定其type为tags 然后保存执行那三步就会有如下效果 点击对应的tag即可跳转到改tag所对应的文章。其他页面同理。 三：添加阅读更多button我们在首页的时候其实就是我们的文章列表，但是这时候有个问题，如果我们某一篇或者某几篇文章很长，那首页是不是更长呢？其实在首页我们可以只显示文章部分内容，通过点击阅读更多按钮来进入文章详情。这个时候就需要截断文章。我们在文章的合适地方采用&lt;!--more--&gt;来截断,用默认文章来看 然后执行那三步就会如下效果 点击阅读更多。 四：更改主题背景首先找到如下路径 themes\next\source\css_custom\custom.styl 会发现里面是空的，这个文件是Next主题为我们预留的做一些自定的css样式的地方，我们添加如下代码。 //背景图片相关@media screen and (min-width:1200px) &#123; body &#123; background-image:url(/images/bg.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover &#125; #footer a &#123; color:#eee; &#125;&#125; 这里大家应该就可以看出括号里面的图片路径就是我们的背景图片，我们只需把图片放入 themes\next\source\images 中即可，记住图片名字要写对，要有后缀。同理括号里面我们可以直接放一个图片的链接比如 https://tpc.googlesyndication.com/simgad/6893153702744595670 做完这些操作保存，然后执行那三步即可看到效果，不过可能浏览器有缓存，可以清理下缓存再刷新看看。 五：修改博客背景透明度既然再上一步中修改了背景图片，如果被NExt本身的白色挡住确实不好看，我们可以尝试把本身的白色背景变成透明的，这样会美观很多，同样还是修改刚才的文件 themes\next\source\css_custom\custom.styl 在上一步的基础上我们可以添加如下代码 //改变背景色和透明度.main-inner &#123; background: #fff; opacity: 0.9;&#125; 其中第一个属性为颜色值，第二个属性就是我们的透明度啦。适当修改，不然会适得其反连字都看不清啦。做完上两步就是我的这个博客的效果。 六：修改作者头像为圆形， 我们默认是方形的头像，想修改为圆形的话同样是上两步的那个路径下添加如下代码 .site-author-image &#123; border-radius: 100%; padding: 2px; border: 2px dashed #fff; animation: cycle 2s 0.5s forwards; transition: border-radius 2s;&#125; 保存 -&gt; 三步 即可看到效果 七：添加背景动画 背景动画使用Js来处理，会JS的同学可以自己写喜欢的动画，我这边就用了网上比较通用的动画。找到以下路径 themes\next\layout\_layout.swig 在文章 &lt;/body&gt;的上面添加如下代码 &lt;script type="text/javascript"color="255,255,255" opacity='1' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 然后 保存 -&gt; 三步即可看到效果 其中src为JS的路径，有兴趣的可以自定义效果。 八：添加评论页面 HEXO的评论页面官方推荐了disqus，无奈已经被墙，即使开发时候自己有克服的方法但是也不能保证所有看你博客的人都有克服的方法。所有我们打算采用其他的的一些第三方来实现，首先先对市面上的几个产品做下对比： 比较： disqus 比较大牌的评论系统，服务稳定，唯一的缺点是国内无法使用。暂不考虑 多说国内比较出名的评论系统，已经关闭服务暂不考虑。 gitment一款基于github issue的评论系统，风格很像github，只是目前还不是太稳定，且界面无法自定，可能会于博客有些不协调。而且评论需要github账号 livere中文名字叫来必力，是一款韩国的评论系统，在不带有任何民族情感的前提下来看确实棒子的东西还是不错的，也是我目前在使用的一款，我主要用它的原因有几点 支持很多种格式的评论导入，你可以很方便的吧之前在其他平台上的评论数据导入进来，支持多种json格式。 简介的UI提供多种主题。 国外的东西不受国内的限制。 集成：先去livere的官网注册m，具体过程我就不讲了，一步一步安她的来就行，之后他会给你一个安装代码，像这样： 里面主要的信息就是data-uid。NEXT主题本身是已经集成了livere评论的，只不过被注释掉了。找到主题配置文件 _config.yml 找到如下代码 打开注释填入你在livere中注册后它给你的UID即可。然后 保存 -&gt; 三步即可。 九：多终端操作背景大家都知道HEXO是静态博客，所有的页面都是静态的通过本地文件渲染然后再部署上去，这就带来一个多终端部署的问题，比如公司电脑配置好了，想回家在进行写作，发现家里什么都没有还需要重新配置环境，不过这倒是次要，关键是如果不能保证两个终端的内容完全一样就会造成服务器上的数据会被最后一次部署覆盖，导致前几次的都被覆盖掉。 解决其实大家应该也看出HEXO整体的一套流程下来就是git的工作流程，不管你用github还是bitbucket都是遵循gitflow的，而gitflow就是一种多终端多人协同工作的解决方案。所以我们可以用它来解决多终端同步的问题。 流程我们先来了解下hexo的整体流程。我们正常的为文件夹结构如图： 第一步：hexo g source文件夹下存放着我们的文章，tag、归档之类的信息，也就是我们的博客的内容。当我们在终端执行 hexo g 的时候会被source中的文件按照某种规则方式渲染成静态的页面文件放到public中： 第二步：hexo d 然后我们执行 hexo d 这一步暂时我们可以认为就是对public中的文件进行push到我们的git仓库的过程。所以在我们的仓库中 XXXXXX.bitbucket.io 大家看到的文件只有public中的文件。 附加：hexo clean 其实这一步是和gitflow没有关系的，但是既然讲到流程我这边也在说下，之前说过这步是用来清理缓存的，其实他的作用是运行在第一步之前，将整个public文件删除，然后我们再执行 hexo g 重新渲染进public，之后再 hexo d 进行部署，这样就避免之前的内容对我们造成影响。 具体操作 通过上一步流程我们知道如果git服务器上只有public是不够的，我们需要有我们整个博客文件夹下的所有文件才能进行多终端操作。所有这边有两个方法： 新建另一个仓库我们暂时命名为MyProject，把我们所有的文件传到这个Git仓库上，当我们换另一台电脑时候我们直接拉这个新仓库的代码然后进行写作 -&gt; 三步走最后在将所有文件推到MyProject以后所有的git操作都在这个仓库中进行。 git给我们提供了多分支操作，我们可以做xxxx.github.io这个仓库中创建一个新的分支暂时命名为hexo分支，这个分支的作用和上一个方法里MyProject的作用以及里面的文件一模一样，只不过我们这个方法就省的我们再创建一个仓库了。以后所有的git操作都去这个分支进行，本地的文件一直保持在这个分支就行，不过有一点需要注意的就是，即使所有的操作都在hexo分支下进行也必须保证master分支为主分支(default branch)，不然你就打不开你的博客了。 以上两种都是属于基本的git操作，本文不再赘述。不过有一点这里要强调下，还记一开始我跟大家说的主题的是推荐大家直接去主题所在的repo下载zip然后解压拖进博客目录里面吗？如果你不是拖拽进来的而是clone下来的话在这一步你会涉及到git的 add submodule操作。其实操作不难，具体的命令网上也是大把。不过如果你像我一样使用bitbucket的话可能发现无法进行submodule操作，不知道这个是bitbucket的BUG还是什么其他原因，同样的命令使用github托管博客的时候是没有问题的，而bitbucket就不行，当你使用另一台电脑的进行拉去的时候执行 git submodule init 操作的时候他会提示找不到。至今未解决，如果哪位大神有什么方法及时联系我。 十：绑定个人域名注意：bitbucket 从2015年开始关闭了个人博客自定义域名的功能，也就是说如果你是按照上面操作把个人博客部署在bitbucket中的话就无法使用自己的域名，关于这一点bitbucket文档已经有明显的说明 准备工作在github上创建仓库，仓库的名字为 username.github.io。然后修改站点配置文件中部署地址（repo对应的字段），将原本的bitbucket的仓库地址改为github的地址 之后进行保存然后三步走，部署成功后你的博客就从bitbucket上迁移到github中了，这样一来，你整体的博客仓库还是在bitbucket中的私有库中，但是public文件夹中的公开文件已经被你部署到github的仓库中。该保密的信息仍然保密，同时也不影响你绑定自己的域名，一举两得。正常情况下按照上面步骤完成后的博客地址是 xxx.github.io，下面就开始绑定自己的域名。 域名购买这个渠道有很多，我就不再一一赘述，我这边以阿里云的万网域名购买为例,找到合适自己的域名 域名解析购买域名并且按照他的步骤实名认证之后，需要把域名解析到我们的博客中，在阿里云的控制台找到域名右侧对应的解析按钮。点击然后添加解析 然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址 之后记得启用该记录，不过如果你像我一样是阿里云购买并且配置的话是不需要启用的，默认帮你启用。 仓库配置然后回到你的github仓库，进入你的仓库设置页面，找到如下字段，在红框处添加你的域名，然后保存即可 博客配置回到你的博客目录，在source目录下创建一个不带任何后缀的文件，命名为 CNAME，里面填写你的域名，我是这样，只添加你的域名不要添加其他东西。然后保存 执行三步之后就可以通过你的域名访问你的博客啦，如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以了。 十一：实现https协议按照以上步骤完成后可以通过域名访问，但是有个问题就是如果你用谷歌浏览器或者Safari，他就会提示你网站不被信任，只有你点击仍要继续才会展示你的博客，并且地址栏里面还是有个红色的×，虽说不影响使用和阅读，但是还是感觉别扭，这次我们来讲如何将自己的博客协议改为Https。这里有几种方法： 购买证书 使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制 使用CDN进行反向代理 如果使用上两步的话基本上证书的服务商都会告诉你如何配置，他们的文档讲的一定比我的详细，不过主要原因是我们使用的github Page是不支持上传证书的，所以这里主要说下第三步，通过CDN配置反向代理，这里就需要用到一个国外的CDN服务提供商Cloudflare: 原理Cloudflare 提供DNS解析服务，而且速度很快，在阿里云半个小时才能生效的解析在它这里瞬间就生效，它提供了免费的https服务(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。 用户看到的小锁其实是用户连接到Cloudflare的证书，而由Cloudflare到github是没有https的，不过对于我们静态博客已经够了。 配置第一步：还是先去官网注册，然后添加你的域名，注意添加的是你购买的域名。 第二步：进入DNS解析界面填入如下解析，因为我们使用clouldflare做DNS解析所以一会我们需要把我们购买域名的那个地方的解析删掉。 其中前两个是使你的域名指向github的服务器地址，github文档中给的就是这个两个地址，最后那个CNAME记录指向的是你的github仓库域名username.github.io。一定要严格按照这个来配置。 第三步：记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把你域名购买处（我的是阿里云）的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为我们以后就靠clouleflare来解析DNS啦。 第四步：回到clouldflare 上面选择crypto选项然后下面选择full或者是Flexible 选项中几个的区别如下图 最后那个是需要证书支持的。然后滚动到下面打开always use HTTPS开关 第五步：以上步骤配置好之后基本就完成了，但是如果直接有人在地址栏里面输入http://XXXXX 进入你的博客的话你这边还是会出现非Https的效果，所以我们这里要做一个强制跳转。 这样就万无一失了。 坑点：我之前按照以上步骤操作完成后发现首页虽然是https了也不显示红叉了，但是也没有显示绿色的小锁，而是一个叹号，但是有些博文页面可以正常显示https绿锁。后来发现是因为当前页面中有非https的链接导致，比如图片图床不是https的，或者评论插件不支持https，不过我博客中使用的来必力评论是支持https，只是我当时的图床无都是http所以只能是显示叹号了，后来把所有图片图床换成https的就好啦。 十二：为博客添加音乐HEXO博客添加的音乐的地方有两个。一个个首页侧边栏，另一个是每个页面里面。但是个人觉得添加侧边栏里面并不好，因为添加侧边栏的话用户只有在浏览你首页的时候才能听到音乐，而且期间不能点击任何站内链接，否则音乐就会中断，试想下，一般首页都是文章列表，点击文章里面之后才是正文，所以用户在首页停留的时间很短，基本上找到自己想看的文章就会马上点进去看，所以这里放音乐没有太大意义；而页面内插入音乐会更好点，读者可以一边浏览文章一边听音乐，这也正是我们想要的。不过解决前者问题的办法也不是没有，比如点击链接的话直接开另一个浏览器标签来打开新页面也可以做到不中断音乐，但是总觉得有点小题大做了。总不能读者看个你的博客而占用了一堆标签。 网易云音乐外链这个是最简单的方法，通过网易云音乐官网生成播放器外链。 可以自己配置一些属性，然后自动生成配置代码，放到你的博客里面就行啦，粘贴到你文章中想要的地方 优点缺点截图上也有，不过网上也说这样的方式会影响SEO，具体什么原理也不太清楚。总之简单便捷，不过网易的logo去不掉。 aplayer添加音乐这个算是HEXO最常用也是最出名名的播放器了，还有Dpleyer是用来视屏播放的，暂时我们不说。首先需要安装aplayer依赖，终端中切换到你的博客根目录执行 npm install aplayer --save 安装成功后就可以了。参数就不给大家一一讲解了，官方文档都有，我这里只提供一个例子。 页面中添加音乐&#123;% aplayerlist %&#125;&#123; "autoplay": true, "showlrc": 0, "mutex": true, "music": [ &#123; "title": "에필로그 (Epilogue)", "author": "이동준", "url": "https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%8B%E1%85%A6%E1%84%91%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.mp3", "pic": "https://y.gtimg.cn/music/photo_new/T002R300x300M000000RmZHf3qhLUL.jpg?max_age=2592000", "lrc": "https://歌词.lrc" &#125; ]&#125;&#123;% endaplayerlist %&#125; 以上代码插到文章中任意一个你想的地方就可以 pic就是歌曲显示图片的链接。大家可以看到music是个数组，所以想添加列表的话就在数组中再添加个歌曲字典就好了。建议歌词lrc要用URL形式，不然txt格式可能要编辑死。。好多人问歌曲的MP3外链从哪里来。这个其实很简单，首先把歌曲下载下来然后上传到七牛云就可以在七牛云生成外链啦，七牛云有免费的存储空间，只存歌曲的话足够啦。歌词URL 侧边栏中添加音乐其实之前讲过，不建议在侧边栏中添加，但是这里还是简单介绍下。首先要做的是在node_modules 目录下找到 APlayer.min.js 文件，将其复制到 theme/next/source/js/src/ 目录下。然后打开 theme/next/layout/_custom/ 文件夹下的 sidebar.swig 文件，向其中添加以下代码： &lt;div id="player1" class="aplayer"&gt;&lt;/div&gt;&lt;script src="/js/src/APlayer.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var ap = new APlayer(&#123; element: document.getElementById('player1'), // Optional, player element narrow: false, // Optional, narrow style autoplay: false, // Optional, autoplay song(s), not supported by mobile browsers showlrc: 0, // Optional, show lrc, can be 0, 1, 2, see: ###With lrc mutex: true, // Optional, pause other players when this player playing theme: '#e6d0b2', // Optional, theme color, default: #b7daff mode: 'random', // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` preload: 'metadata', // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' listmaxheight: '513px', // Optional, max height of play list music: [ &#123; // Required, music info, see: ###With playlist title: 'Sometimes When We Touch', // Required, music title author: 'Oliveia', // Required, music author url: 'https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/SometimesWhenWeTouch.mp3', // Required, music url pic: 'https://y.gtimg.cn/music/photo_new/T002R300x300M000003LIDEL0NQInJ.jpg?max_age=2592000', // Optional, music picture lrc: 'https://歌词.lrc' // Optional, lrc, see: ###With lrc &#125;, &#123; "title": "大鱼", "author": "周深", "url": "https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3", "pic": "https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000", "lrc": "https://歌词.lrc" &#125; ]&#125;);&lt;/script&gt; 只是换成了JS的语法，其实原理，参数都一样。然后执行三步走就可以看到啦，注意有浏览器缓存，所以多刷新几次就会有了。 歌词、音乐外链相关歌曲说过大家可以用七牛的免费存储功能，但是会发现一个问题七牛的歌曲外链不支持https，这会导致配置有ssl证书的人掉绿锁，其实如果有这个需求的大家可以放弃七牛，改用腾讯云，这样就OK啦，一样的操作。 好多人问歌词的URL好难找啊，去哪里找呢，大家可以看下这个 MeetingJS这个其实是基于Aplayer的一个小封装，目的是简化Aplayer的接入成本，但是因为之前我介绍了接入步骤所以这里我们只用它的歌词API就可以。ttps://demo.meting.api.meto.moe/action/metingapi?server=tencent&amp;type=lrc&amp;id=004OQ5Mt0EmEzv 其中要改的只有两个参数seaver是音乐平台包含百度、网易、QQ音乐等平台 id字段对应的是歌曲的ID 这个你只要打开个歌曲网页链接里面应该都包含id。文章结尾的播放就是这么加入的 最后整篇文章只有开始一小部分在讲解如何搭建博客，后续的基本都是交给大家如何优化，调整一些细节问题如UI、用户体验之类的，当然我们能做的远远不止这些，如果有什么问题欢迎与我探讨。下面的留言我都会看的。此外当本人对HEXO有新的看法或者玩法的话该文章会不断的更新，希望大家关注我的小站，感谢。 var options = {"narrow":false,"autoplay":true,"showlrc":3,"mutex":true,"music":[{"title":"凉城","author":"任然","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/liangcheng.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M0000008nl2Y1HlxUm.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=002SKEeh1VzObP"},{"title":"Love Story","author":"린 (LYn)","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E1%84%85%E1%85%B5%E1%86%AB-Love%20Story.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M0000048KLcQ4LDbZz.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=0028RAj0187nEg"},{"title":"大鱼","author":"周深","url":"https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/bigfish.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004Y7V4s3ug4cC.jpg?max_age=2592000","lrc":"https://demo.meting.api.meto.moe/action/metingapi?server=tencent&type=lrc&id=004OQ5Mt0EmEzv"}]}; options.element = document.getElementById("aplayer2"); new APlayer(options);]]></content>
      <categories>
        <category>通用开发</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能是最全的iOS端HttpDns集成方案]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84iOS%E7%AB%AFHttpDns%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[科普片1、DNS劫持的危害 不知道大家有没有发现这样一个现象，在打开一些网页的时候会弹出一些与所浏览网页不相关的内容比如这样奇(se)怪(qing)的东西 或者这样 ， 其实造成这样的原因就是DNS劫持，在我们正常浏览的网页链接里面被恶意插入一些奇怪的东西。不止是这些，DNS劫持还会对我们的个人信息安全造成很大的伤害，钓鱼网站之类的，也许我们所访问的网站根本不是我们需要的网站，或者根本打不开网页，有时还会消耗我们过多的流量。 2、什么是DNS解析 现在假如我们访问一个网站www.baidu.com从按下回车到百度页面显示到我们的电脑上会经历如下几个步骤 1：计算机会向我们的运营商(移动、电信、联通等)发出打开www.baidu.com的请求。 2：运营商收到请求后会到自己的DNS服务器中找www.baidu.com这个域名所对应的服务器的IP地址(也就是百度的服务器的IP地址)，这里比如是180.149.132.47。 3：运营商用第二步得到的IP地址去找到百度的服务器请求得到数据后返回给我们。 其中第二步就是我们所说的DNS解析过程，域名和IP地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是IP地址\身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在IP上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是IP的，所以DNS解析就应运而生了。 3：什么是DNS劫持DNS劫持，是指在DNS解析过程中拦截域名解析的请求，然后做一些自己的处理，比如返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。根本原因就是以下两点： 1：恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。 2：运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。 4：防止DNS劫持 了解了DNS劫持的相关资料后我们就知道了，防止NDS劫持就要从第二步入手，因为DNS解析过程是运营商来操作的，我们不能去干涉他们，不然我们也就成了劫持者了，所以我们要做的就是在我们请求之前对我们的请求链接做一些修改，将我们原本的请求链接www.baidu.com 修改为180.149.132.47，然后请求出去，这样的话就运营商在拿到我们的请求后发现我们直接用的就是IP地址就会直接给我们放行，而不会去走他自己DNS解析了，也就是说我们把运营商要做的事情自己先做好了。不走他的DNS解析也就不会存在DNS被劫持的问题，从根本是解决了。 技术篇5：项目中的实际操作5.1：DNSPOD相关 我们知道要要把项目中请求的接口替换成成IP其实很简单，URL是字符串，域名替换IP，无非就是一个字符串替换而已，的确这块其实没有什么技术含量，而且现在像阿里云(没开源)，七牛云(开源)，等一些比较大的平台在这方面也都有了比较成熟的解决方案，一个SDK，传个普通的URL进去就会返回一个域名被替换成IP的URL出来，也比较好用，这里要说一下IP地址的来源，如何拿到一个域名所对应的IP呢？这里就是需要用到另一个服务——HTTPDNS，国内比较有名的就是DNSPOD，包括阿里，七牛等也是使用他们的DNS服务来解析，就是这个 他会给我们提供一个接口，我们使用HTTP请求的方式去请求这个接口，参数带上我们的域名，他们就会把域名对应的IP列表返回回来。类似这样：///这个请求URL的结构是固定的119.29.29.29是DNSPOD固定的服务器地址，ttl参数的意思是返回结果是否带ttl是个BOOL，dn就是我们需要解析的域名，id就是我们在dnspod上注册时候他给我们的一个KEYNSString *url = [NSString stringWithFormat:@"http://119.29.29.29/d?ttl=1&amp;dn=www.baidu.com&amp;id=KEY"];NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10];NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:&amp;networkError]; 这里使用同步还是异步都是可以的，具体根据你们业务需求。 5.2：项目中的使用 其实dnspod最难的部分是接入的部分，因为不同的APP不同的网络环境会导致各种各样的问题，如果你是一个新的项目那么接入难度会大大降低，因为你完全可以自己封装一套网络请求，把DNS解析相关的逻辑都封装到自己的网络请求中，这样你就可以得到APP所有的网络层的控制权，想干什么就干什么，但是如果是在一个已经比较完善的APP中加入DNS防劫持的话那就是比较困难，因为你不能拿到所有网络请求的控制权这篇文章中我主要使用是NSURLProtocol + Runtime hook方式来处理这些东西的，NSURLProtocol属于iOS黑魔法的一种可以拦截任何从APP的 URL Loading System系统中发出的请求，其中包括如下 File Transfer Protocol (ftp://) Hypertext Transfer Protocol (http://) Hypertext Transfer Protocol with encryption (https://) Local file URLs (file:///) Data URLs (data://) 如果你的请求不在以上列表中就不能进行拦截了，比如WKWebview，AVPlayer(比较特殊，虽然请求也是http/https但是就是不走这套系统，苹果爸爸就是这样~)等，其实对于正常来说光用已经NSURLProtocol足够了。 NSURLProtocol这个类我们不能直接使用，我们需要自己创建一个他的子类然后在我们的子类中操作他们像这样 // 注册自定义protocol[NSURLProtocol registerClass:[CustomURLProtocol class]]; NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];configuration.protocolClasses = @[[CustomURLProtocol class]]; 在这个类中我们可以拦截到请求，然后进行处理。这个类中有四个非常重要的方法+ (BOOL)canInitWithRequest:(NSURLRequest *)request;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;- (void)startLoading;//对于拦截的请求，NSURLProtocol对象在停止加载时调用该方法- (void)stopLoading; + (BOOL)canInitWithRequest:(NSURLRequest *)request;通过返回值来告诉NSUrlProtocol对进来的请求是否拦截，比如我只拦截HTTP的，或者是某个域名的请求之类 + (NSURLRequest )canonicalRequestForRequest:(NSURLRequest )request;如果上面的方法返回YES那么request会传到这里，这个地方通常不做处理 直接返回request - (void)startLoading;这个地方就是对我们拦截的请求做一些处理，我们文中所做的IP对域名的替换就在这里进行，处理完之后将请求转发出去，比如这样- (void)startLoading &#123;///其中customRequest是处理过的请求(域名替换后的) NSURLSession *session = [NSURLSession sessionWithConfiguration:[[NSURLSessionConfiguration alloc] init] delegate:self delegateQueue:nil]; NSURLSessionDataTask *task = [session dataTaskWithRequest:customRequest]; [task resume];&#125; 你可以在 - startLoading 中使用任何方法来对协议对象持有的 request 进行转发，包括 NSURLSession、 NSURLConnection 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 client，帮助其正确渲染就可以，比如这样：- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed]; completionHandler(NSURLSessionResponseAllow);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; [[self client] URLProtocol:self didLoadData:data];&#125; client在后面会有讲解。 - (void)stopLoading;请求完毕后调用大概的执行流程是这样 在NSURLProtocol中有一个贯穿始终的变量/*! @method client @abstract Returns the NSURLProtocolClient of the receiver. @result The NSURLProtocolClient of the receiver. */@property (nullable, readonly, retain) id &lt;NSURLProtocolClient&gt; client; 你可以认为是这个是请求的发送者，打个比方，A想给B发送一个消息，由于距离遥远于是A去了邮局，A把消息内容告诉了邮局，并且A在邮局登记了自己名字方便B有反馈的时候邮局来通知A查收。这个例子中邮局就是NSURLProtocol，A在邮局登记的名字就是client。所有的 client 都实现了 NSURLProtocolClient 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：@protocol NSURLProtocolClient &lt;NSObject&gt;...- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;...@end 当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。到此正常情况下的DNS的解析过程已经结束，如果你发现按照如上操作之后并没有达到预期效果那么请往下看，(通常情况下完成以上操作 原有的URL的就会变成http://123.456.789.123/XXX/XXX/XXX的格式。如果发现请求不成功就往下看吧) 6：遇到的坑点6.1：我们知道运营商本来是根据域名来确定一个URL的，我们将域名改为IP之后虽然不用运营商帮我们解析了，但是运营商在收到一串数字的时候也是懵逼状态，我们还是需要将域名传给他们，但是不能用正常的方式传，我们需要把原来的域名加到http请求的Header中的host字段下，根据Http协议的规定，如果在URL中无法找到域名的话就会去Header中找，这样一来我们既把域名告诉了运营商同时也直接制定了IP地址，这个是必须配置的，不然的话是请求不成功的。[mutableRequest setValue:self.request.URL.host forHTTPHeaderField:@"HOST"]; 加上Header再去请求就没问题了，不过有些特殊的情况下会需要带上cookie，同样也是加到Header中[mutableRequest setValue:YOUR Cookie forHTTPHeaderField:@"Cookie"]; 6.2：关于AfNetworking的问题，现在大部分网络请求是基于Afnetworking的，这里有一个坑，我们知道我们注册CustomProtocol的时候是这样 // 注册自定义protocol[NSURLProtocol registerClass:[CustomURLProtocol class]]; NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];configuration.protocolClasses = @[[CustomURLProtocol class]]; 在系统的configuration加入我们的CustomProtocol，protocolClasses是一个数组里面可以放很多各种不同的CustomProtocol，我们看一下afnetworking的初始化方法。AFHTTPSessionManager * sessionManager = [AFHTTPSessionManager manager]; 我相信大家通常都会这么来创建，但是这里我要说下manager并不是一个单利，最后都会调到一个方法- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; . . .&#125; 大家注意第二个判断，如果没有传入configuration的话他会创建一个默认的，这样以至于我们之前在configuration的protocolClasses中注册类全部被这个新的configuration替换掉了，所以无法解析。这里我采取的办法就是runtime hook，因为hook第三方的代码并不是一个很好的办法，所以我直接hook NSURLSession的sessionWithConfiguration方法，因为通过观察Afnetworking的源码最终都是走到这里的。Hook之后把自己的configuration换进去，像这样+ (NSURLSession *)swizzle_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration &#123; NSURLSessionConfiguration *newConfiguration = configuration; // 在现有的Configuration中插入我们自定义的protocol if (configuration) &#123; NSMutableArray *protocolArray = [NSMutableArray arrayWithArray:configuration.protocolClasses]; [protocolArray insertObject:[CustomProtocol class] atIndex:0]; newConfiguration.protocolClasses = protocolArray; &#125; else &#123; newConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSMutableArray *protocolArray = [NSMutableArray arrayWithArray:configuration.protocolClasses]; [protocolArray insertObject:[CustomProtocol class] atIndex:0]; newConfiguration.protocolClasses = protocolArray; &#125; return [self swizzle_sessionWithConfiguration:newConfiguration];&#125; 然后就完美解决了。不过要注意下系统的是有两个方法的/* * Customization of NSURLSession occurs during creation of a new session. * If you only need to use the convenience routines with custom * configuration options it is not necessary to specify a delegate. * If you do specify a delegate, the delegate will be retained until after * the delegate has been sent the URLSession:didBecomeInvalidWithError: message. */+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue; 这两个方法不能确定最终会走那个，所以为了保险起见都hook下，hook的方式是一样的6.3：AVPlayer请求，AVPlayer是我们iOS系统中系统自带的播放视频的框架，用到地方也很多，但是这个是比较坑的，因为AVPlayer虽然也有http/https/file……请求这个概念，但是AVPlayer所有的请求都不会走URL Loading System，也就是说所有由AVPlayer发出的请求都不能被我们的CustomProtocol拦截，这时候大家也许会问，不对呀，我们正常调试的时候可以被拦截到的啊。其实苹果官方上是说AVPlayer在真机调试和模拟器调试时候走的完全不是一套策略，也就是说在模拟器运行时候是完全正常的，可以被拦截到也可以被解析，但是在真机上面就恰恰相反了，因为我们最后还是以真机为准，所以我们采取的办法还是hook，因为我们需要在媒体URL传给AVPlayer前就要将相关东西配置好，域名替换啊，加host啊之类的，所以我们要找AVPlayer的入口，先看初始化方法，我发现项目中使用一个AVURLAsset来初始化AVPlayer，那么AVURLAsset又是什么呢？继续查到AVURLAsset的初始化方法，可以发现这个方法：/*! @method initWithURL:options: @abstract Initializes an instance of AVURLAsset for inspection of a media resource. @param URL An instance of NSURL that references a media resource. @param options An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above. @result An instance of AVURLAsset.*/- (instancetype)initWithURL:(NSURL *)URL options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIALIZER; 其中URL就是我们传给AVPlayer播放的URL，找到目标就Hook下就可以了，具体过程就不多说了还是字符串替换，但是有一点需要注意的是，我之前上文说过做完IP对域名的替换之后还需要设置下request的Host，但是这个地方只有一个URL并没有Request该如何处理呢？其实这个方法里面的opinion参数就是处理这个的，可以添加cookie之类的类似与httpheader的东西，可以添加这几个KeyAVF_EXPORT NSString *const AVURLAssetPreferPreciseDurationAndTimingKey NS_AVAILABLE(10_7, 4_0);AVF_EXPORT NSString *const AVURLAssetReferenceRestrictionsKey NS_AVAILABLE(10_7, 5_0);AVF_EXPORT NSString *const AVURLAssetHTTPCookiesKey NS_AVAILABLE_IOS(8_0);AVF_EXPORT NSString *const AVURLAssetAllowsCellularAccessKey NS_AVAILABLE_IOS(10_0); 但是并没有发现和Host相关的Key，其实这个key是有的就是AVURLAssetHTTPHeaderFieldsKey只是因为这个Key没暴露出来。这个地方不太确定是不是苹果的私有API，网上查了大量的资料也没有个说法，甚至我亲自去苹果开发者去问，苹果也没有给任何答复，各种说法都有，具体使用的话就是[self swizzle_initWithURL:videoURL options:@&#123;AVURLAssetHTTPHeaderFieldsKey : @&#123;@"Host":host&#125;&#125;] 这样使用是没有任何问题的，但是毕竟是没有暴露出来的方法，我们不能这样明目张胆的使用，其实对于字符串来说还是比较好规避的，只要不要明文出现这个KEY就可以，我在这里使用了一个加密，吧key变成密文然后这个地方通过解密获取，就像这样：//加密后的KEYconst NSString * headerKey = @"35905FF45AFA4C579B7DE2403C7CA0CCB59AA83D660E60C9D444AFE13323618F";...//getRequestHeaderKey方法为解密方法return [self swizzle_initWithURL:videoURL options:@&#123;[self getRequestHeaderKey] : @&#123;@"Host":host&#125;&#125;]; 这样之后就大功告成了，AVPlayer可以在DNS被劫持的情况下播放了，6.4：POST请求这块也算是一个大坑，我们知道http的post请求会包含一个body体，里面包含我们需要上传的参数等一些资料，对于POST请求我们的NSURLProtocol是可以正常拦截的，但是我们拦截之后发现无论怎么样我们获得的body体都为nil！后来查了一些资料发下又是苹果爸爸在做手脚。NSURLProtocol在拦截NSURLSession的POST请求时不能获取到Request中的HTTPBody，这个貌似早就国外的论坛上传开了，但国内好像还鲜有人知，据苹果官方的解释是Body是NSData类型，即可能为二进制内容，而且还没有大小限制，所以可能会很大，为了性能考虑，索性就拦截时就不拷贝了（内流满面脸）。为了解决这个问题，我们可以通过把Body数据放到Header中，不过Header的大小好像是有限制的，我试过2M是没有问题，不过超过10M就直接Request timeout了。。。而且当Body数据为二进制数据时这招也没辙了，因为Header里都是文本数据，另一种方案就是用一个NSDictionary或NSCache保存没有请求的Body数据，用URL为key，最后方法就是别用NSURLSession，老老实实用古老的NSURLConnection算了。。。你以为这么就结束了吗？并没有，后来查了大量的资料发现，既然post请求的httpbody没有苹果复制下来，那我们就不用httpbody，我们再往底层去看就会发现HTTPBodyStream这个东西我们可以通过他来获取请求的body体具体代吗如下#pragma mark -#pragma mark 处理POST请求相关POST 用HTTPBodyStream来处理BODY体- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request &#123; NSMutableURLRequest * req = [request mutableCopy]; if ([request.HTTPMethod isEqualToString:@"POST"]) &#123; if (!request.HTTPBody) &#123; uint8_t d[1024] = &#123;0&#125;; NSInputStream *stream = request.HTTPBodyStream; NSMutableData *data = [[NSMutableData alloc] init]; [stream open]; while ([stream hasBytesAvailable]) &#123; NSInteger len = [stream read:d maxLength:1024]; if (len &gt; 0 &amp;&amp; stream.streamError == nil) &#123; [data appendBytes:(void *)d length:len]; &#125; &#125; req.HTTPBody = [data copy]; [stream close]; &#125; &#125; return req;&#125; 这样之后的req就是携带了body体的request啦，可以愉快地做post请求啦。6.5：WKWebview是新出的浏览器控件，这里就不多说了，WKWebview不走URL Loading System，所以也不会被拦截，不过也是有办法的，但是因为这次项目中没有用到，所以没有过多的去研究，后续我会写一篇关于这个博客，不是很难，依旧是runtime大法。6.6：SNI环境，这个可是坑了我好久好久的东西，所以我会放在最后去说，SNI环境因为涉及到证书验证所以是在https的基础上来说的，SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。其实关于SNI环境在这里就不过多解释，阿里云文档有很明白的解释，同时他也有安卓和iOS在SNI环境下的处理文档，我们发现安卓部分写的很详细，可是已到了iOS这边就这样了： 三行文字加三个链接就完事了。其实在遇到这个坑的时候我也查过很多相关资料，无非就是这三行话加这三个链接复制来复制去，没有实质性的进展，大部分公司或者是项目没有这么重的Httpdns需求，所以也就不会有这个环境，即使遇到了也就直接关闭httpdns了，后来只能自己去用CFNetwork一点点实现。具体代码就不跟大家粘贴了因为涉及到一些公司内部的代码，不过我会把我主要的参考资料发给大家。这里有个小技巧，因为都在说CFNetwork是比较底层的网络实现，好多东西需要开发者自行处理比如一些变量的释放之类的，所以我们能少用尽量少用，因为Cfnetwork是为SNI(https)环境服务,所以我们在拦截判断的时候可以区分是用上层的网络请求转发还是用底层的cfnetwork来转发， if ([self.request.URL.scheme isEqualToString:@"https"] ) &#123;//使用CFnetwork curRequest = req; self.task = [[CustomCFNetworkRequestTask alloc] initWithURLRequest:originalRequest swizzleRequest:curRequest delegate:self]; if (self.task) &#123; [self.task startLoading]; &#125; &#125; else &#123;//使用普通网络请求 NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; self.session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionTask *task = [self.session dataTaskWithRequest:req]; [task resume]; &#125; 我是这么做的。6.7：在NSURLProtocol中的那几个类方法中是可以发送同步请求的，但是在实例方法发送同步请求就会卡死，所以实例方法中不能有任何的阻塞，进行同步操作。不然就卡死。7：总结 完成了以上的步骤之后你回发现在DNS坏掉的情况下手机里面除了微信QQ(他们也做了DNS解析)之外其他应用都不能上网了但是你的App依然可以正常浏览网络数据。这就是我最近在做的时候遇到的一些问题，有什么问题及时与我交流吧]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>底层</tag>
        <tag>httpdns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在iOS工程中Cocoapods的使用]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADCocoapods%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们在开发iOS程序的时候，往往都会根据需要导入很多的第三方框架，但是不同的框架完成的功能不同，所以导入的方式也不同，并不是把它直接拖进工程中就完事了，我们需要配置各种环境，链接各种库文件等等。有的时候我们并不能一个不漏的完成导入，而一旦出了问题，尤其是那些需要框架比较多的工程(比如早期的百度地图框架)，将很难解决，而且，如果遇到了第三方库升级，更新了方法那么我们还需要把之前的旧版本删掉，再重复一下前面的工作，这将是非常的繁琐，极大地影响了开发的效率。这个时候我们就需要用到cocoapods来管理我们的第三方了，在我们有了CocoaPods这个工具之后，只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后在命令行执行$ pod install命令。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数，不管是导入还是更新或者移除，都是一句命令就搞定的。网上也有类似的教程，但是有些很旧，有些写的不详细，导致新手在使用的时候整的一头雾水，我就来说下。 第一步 ：首先安装cocoapods要在ruby环境下进行，虽然我们的mac系统都是自带了ruby，但是为了保险起见我们还是要先更新一下ruby环境：在这里我们直接使用 sudo gem update –system 命令来更新，网上有的说使用 gem update –system 前面少了sudo，其实加sudo的目的就是用管理员的权限去执行这句更新命令，不加的话容易出现这个错误 意思是你没有权限去执行这个命令，等出现了RubyGems system software updated 这句话的时候就证明升级成功了。 第二步：安装cocoapods时候我们要访问cocoapods.org这个网站，不用想这个网站已经被墙了，所以我们可以用淘宝的ruby的镜像来访问该网站。首先我们输入 gem sources -l 来看一下我们现在有什么，我目前里面只有一个 也就是我们需要的，不过可能有些人的里面不止一个，会有其他的东西，这时候我们先用gem sources –remove XXXXXXXXXXXXXXX 来把其他的source删除掉，只保留这一个，如果没有的话就手动添加用这个命令 gem sources -a https://ruby.taobao.org/ 来将我们需要的源添加进去，最后再用那个查看命令 最后只有确保像我里面一样只有那一个就好，要注意的是 https 网上好多教程写的是 http，那个已经作废了 第三步：安装是cocoapods 使用 sudo gem install cocoapods 命令来安装cocoapods，你输入完这个命令回车后会提示你输入密码，这时候是没有光标提示的，也不会移动，凭感觉输入对之后就回车吧，然后就是等，时间长短是根据你的网速来的。安装完成后终端就进入待命阶段了。 第四步：使用search命令来搜索类库，这个是支持模糊搜索的，记不清全名，打一部分名也行，不过那样的就要从搜出来的东西里找你想要的类库了。比如我想找afnetworking 我就输入 pod search afn 回车后就会输出所有以afn开头的类库名字，像这样 搜出很多，其中第三就是我们想要的，afnetworking，用红圈圈起来是一会编辑podfile时候需要用的，可以先把他复制下来省的手打，后面的小数代表的是类库的版本，一般是最新的显示在这里，下面的version是历史版本，如果有需要可以直接导入它的历史版本，就是把后面的版本号替换下就好。 值得注意的是如果你不是第一次安装cocoapods， 那么之前的缓存会对你有影响search先清理下缓存 使用这个命之后就可以了 rm ~/Library/Caches/CocoaPods/search_index.json第五步：进入你的工程目录，这里建议直接右键你工程中.xcodeproj文件选择在终端中打开，然后 在终端中输入命令cd .. 就会跳到.xcodeproj所在的目录，也就是我们需要的目录，很多新手在这个地方容易出错。然后输入命令 vim Podfile熟悉Linux的用户都知道这是创建一个Podfile文件并打开编辑，按 “i” 进入编辑模式，将第五部粘贴的东西拷贝进来，然后依次操作esc键 -&gt; “:” -&gt; 输入wq 然后输入命令来安装 pod update –verbose –no-repo-update 等待过后就安装完成啦，其实使用pod install也可以，只是后者需要更新一个仓库，这是相当耗时的，我们可以使用前者来避免更新仓库就好，很快就结束了。 安装成功！以后打卡工程就直接打开这个文件就好啦 其中podfile文件中显示了我们这个工程中所以集成的第三方， 想修改版本的话就把后面的版本号改成你所需要的版本号就好，想删除的话就把这行删掉，想添加的话就用第五部的搜索命令去搜索然后同样把搜索结果中以pod开头的那句话复制进来就好。注意以上所有的增删改操作完成之后需要在去终端中相应的目录下使用 pod install –verbose –no-repo-update 命令来更新，这样才会真正的生效。 第六步：关于cocoapods的更新。有的时候在pod install的时候会出现[!] The ‘master’ repo requires CocoaPods 0.32.1 - 这样的错误，是由于你cocoapods版本过低的原因，这时候需要进行更新，跟新的过程其实就是把以上所有的从新走一遍就相当于安装遍就好了。 值得注意1经常遇到的错误比如下面这个 通常出现在OS X 10.11系统上 这是由于从这个系统开始苹果开始使用无根安装，这时你再用这个方法就会报这个错，这时只需 这个命令就可以成功升级啦 值得注意2有的时候大家在pod search的时候搜不到，但是明明有这个类库别人都可以都到课时就是自己搜不到，其实原因是这样的：pod search只会搜索你本地缓存的框架，如果你想搜索到最新的第三方框架或者某个框架的最新版本，必须先使用pod repo update（推荐）或者pod setup将远程仓库的框架信息更新到本地。其实，从pod search的响应速度飞快，也可以猜出它并没有连接服务器，仅仅是搜索了本地的框架信息[呵呵] 此外，如果你的框架更新比较慢，可以尝试执行下面2条指令更换镜像服务器1：pod repo remove master2：pod repo add master http://git.oschina.net/akuandev/Specs.git 更换镜像完毕后，以后执行pod repo update的速度就会快很多。在说明一点上面两条指令如果第二条无法执行提示403错误像这样 那么在执行完第一条之后直接pod search 命令就好 这样他会自动找合适的配置了，因为第二条那个网址可能会变。 总结：关于使用cocoapods在自己的项目中集成第三方就这些内容。有什么不懂的欢迎来找我交流，本人才疏学浅，如果那里写的不对请及时批评指正，免得误导新人。 新浪微博小耗子上桌子也是我，大家也可以去看下微博多多关注 谢谢！]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义AlertView]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%87%AA%E5%AE%9A%E4%B9%89AlertView%2F</url>
    <content type="text"><![CDATA[CustomAlertView一个自定义的AlertView，用户可以根据自己的需求来设置。 使用方法 类似于系统的初始化方法，如果没有值的话就传nil就好，不要传空字符串。最后一个参数传title数组就好了。 然后调用showInViewWithAction方法显示出来 最后一个参数是button的点击事件，根据tag值来区分不同的button点击，只有取消button的tag是0，其他的是1.2.3…依次往下排列就好 这些属性可以自定义，这里就不细说了，大家可以使试试。 样式截图 大概就这么多，很简单的有问题随时联系我吧。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>AlertView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSURLProtocol对WKWebView的处理]]></title>
    <url>%2F2018%2F01%2F24%2FNSURLProtocol%E5%AF%B9WKWebView%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前写过一篇文章是关于基于NSURLProtocol做的DNS解析，其中对NSURLProtocol也有了简单的介绍，我们都知道他可以拦截所有基于URL Loading System 中的请求，但是对于WKWebview里面所发出的请求即使他是http/https 也无能为力，先来简单的了解下WKWebView. WKWebview iOS8以后，苹果推出了新框架Webkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！我们做开发最关系的是内存问题，基本上网上所有的资料都在说WKWebview的内存占用会更少，但是到底少了多少我这边做了下测试，同样是加载163的首页 从上图看出内存大概能优化百分之八十左右，而且从网页的滑动上也确实有所改善。这么明显的性能提升但是苹果并没有完全放弃UIWebView也一定有他的道理，就拿本文要讲的NSURLProtocol拦截请求来说，WKWebview的兼容并不UIWebView好，还需要开发者做一些操作。 WebKit源码分析 由于WKWebview是基于webkit内核来做的，所以我们在使用的时候需要导入一个这样的东西。 #import &lt;WebKit/WebKit.h&gt; 通过这个我们可以猜到WKWebview中所有的请求以及一些逻辑肯定走的都是webkit里面的东西，所以他对于网页的加载之之类的操作也不会走系统本省的URL Loading System，这么说来他的请求不能被NSURLProtocol拦截也是理所当然的了。不过WKWebview是否真的和NSURLProtocol一点关系都没有还需要去研究，幸好webkit是开源的，github上很容易找到源码（大小大概是1G多点的zip，花了我将近一天时间来看）。拉下代码直接搜索NSURLProtocol，看看有没有有关的信息 看来的确是有和NSURLProtocol有关系，后面通过断点的调用栈中也找到了 + [NSURLProtocol canInitWithRequest:] 这样的字样，再通过网上查一些资料也证实了我的猜想，其实WKWebview在一开始时候是会调用到NSURLProtocol中的入口方法canInitWithRequest的，但是就没有然后了，也就是说WKWebview是和NSURLProtocol有一定关联，只是在NSURLProtocol的入口处返回NO所以导致NSURLProtocol不接管WKWebview的请求。我们点进webkit源码中的CustomProtocol可以看到，整体的结构我们都差不多，但是我注意到每个CustomProtocol的入口函数都有这样一个判断： (粉色的可以暂时认定为是它内部的一个custom字符串)通过这个可以猜想，WKWebview并不是不走NSURLProtocol，而是需要满足他的一个规则，他才会在入口函数这里返回YES来给你放行，这个规则便是你所请求的URL的Scheme要和它内部配置的CustomScheme相同。不过这里有一个疑问，苹果在使用webkit时候为什么会把http/https这样大众化的scheme过滤掉，看来他是不建议开发者来使用NSURLProtocol。接下来我们来看这个CustomScheme，既然苹果内部规定好的那么一定能通过某种方式来注册一个自己的scheme，实在不行就hook嘛。通过翻他的源码发现最终都指向一句代码 [WKBrowsingContextController registerSchemeForCustomProtocol:testScheme]; 方法实现为 + (void)registerSchemeForCustomProtocol:(NSString *)scheme { WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(scheme); } void WebProcessPool::registerGlobalURLSchemeAsHavingCustomProtocolHandlers(const String&amp; urlScheme)&#123; if (!urlScheme) return; globalURLSchemesWithCustomProtocolHandlers().add(urlScheme); for (auto* processPool : allProcessPools()) processPool-&gt;registerSchemeForCustomProtocol(urlScheme);&#125; 通过方法名字可以看出这个就是那个向webkit注册CustomScheme的方法，只要我们在注册完我们自己的CustomProtocol之后在调用该方法应该就可以了。通过他的源码也进一步印证了我的猜想(他也是这么写的) 具体实施 找到了方法就要去实施，不过因为registerSchemeForCustomProtocol是WKBrowsingContextController的类方法，所以只能用WKBrowsingContextController去调用，但是在webkit的头文件发现WKBrowsingContextController并没有开放出来，所以我们采用NSClassFromString和NSSelectorFromString方法来拿到类和对应的方法，整体代码如下//注册自己的protocol[NSURLProtocol registerClass:[CustomProtocol class]];//创建WKWebviewWKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init];WKWebView * wkWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) configuration:config];[wkWebView loadRequest:webViewReq];[self.view addSubview:wkWebView];//注册schemeClass cls = NSClassFromString(@"WKBrowsingContextController");SEL sel = NSSelectorFromString(@"registerSchemeForCustomProtocol:");if ([cls respondsToSelector:sel]) &#123; // 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System [cls performSelector:sel withObject:@"http"]; [cls performSelector:sel withObject:@"https"];&#125; 实现效果。我将网页中所有的图片替换成了柴犬图片 值得注意 关于私有API 因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。 关于post请求大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在之前的文章也有提过 #pragma mark -#pragma mark 处理POST请求相关POST 用HTTPBodyStream来处理BODY体- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request &#123; NSMutableURLRequest * req = [request mutableCopy]; if ([request.HTTPMethod isEqualToString:@"POST"]) &#123; if (!request.HTTPBody) &#123; uint8_t d[1024] = &#123;0&#125;; NSInputStream *stream = request.HTTPBodyStream; NSMutableData *data = [[NSMutableData alloc] init]; [stream open]; while ([stream hasBytesAvailable]) &#123; NSInteger len = [stream read:d maxLength:1024]; if (len &gt; 0 &amp;&amp; stream.streamError == nil) &#123; [data appendBytes:(void *)d length:len]; &#125; &#125; req.HTTPBody = [data copy]; [stream close]; &#125; &#125; return req;&#125;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>webview</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Runtime简单介绍，以及不同类的Method Swizzling]]></title>
    <url>%2F2018%2F01%2F24%2FiOS-Runtime%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E7%9A%84Method-Swizzling%2F</url>
    <content type="text"><![CDATA[Runtime介绍： runtime顾名思义就是运行时，其实我们的App从你按下command+R开始一直到App运行起来经历了大致两个阶段，1：编译时，2：运行时。还记得一道很经典的面试题 这里给大家解释下：首先， * testObject 是告诉编译器，testObject是一个指向某个Objective-C对象的指针。因为不管指向的是什么类型的对象，一个指针所占的内存空间都是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把testObject当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告。接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在testObject里。那么运行时(从这段代码执行开始，到程序结束)，testObject指向的内存空间就是一个NSData对象。你可以把testObject当做一个NSData对象来用。 所以编译时是NSString，运行时是NSData。runtime是什么：在runtime中，所有的类在OC中都会被定义成一个结构体，像这样类在runtime中的表示struct objc_class { Class isa;//指针，顾名思义，表示是一个什么， //实例的isa指向类对象，类对象的isa指向元类#if !__OBJC2__ Class super_class; //指向父类 const char *name; //类名 long version; //类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取（class_getVersion）。 long info; /*供运行期使用的一些位标识。有如下一些位掩码： CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量； CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法； CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置； CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）； CLS_MAPPED (0x10L) 为ObjC运行期所使用 CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用 CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用 CLS_NEED_BIND (0x80L) 为ObjC运行期所使用 CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；*/ long instance_size //该类的实例变量大小（包括从父类继承下来的实例变量）； struct objc_ivar_list *ivars //成员变量列表 struct objc_method_list **methodLists; //方法列表 struct objc_cache *cache;//缓存 一种优化，调用过的方法存入缓存列表，下次调用先找缓存 struct objc_protocol_list *protocols //协议列表 #endif&#125; OBJC2_UNAVAILABLE; 相关的定义/// 描述类中的一个方法typedef struct objc_method *Method; /// 实例变量typedef struct objc_ivar *Ivar; /// 类别Categorytypedef struct objc_category *Category; /// 类中声明的属性typedef struct objc_property *objc_property_t; ObjC 为每个类的定义生成两个 objc_class ，一个即普通的 class，另一个即 metaclass。我们可以在运行期创建这两个 objc_class 数据结构，然后使用 objc_addClass 动态地创建新的类定义。 runtime能干什么： ：1：获取一个类中的列表比如方法列表、属性列表、协议列表、成员变量列表像如下这样 其中获取到的属性、方法都是可以获取public和private的。 unsigned int count; Class clas = [WKWebViewController class]; //是我自己的类，之所以不用系统的类是因为系统的类方法属性太多了 objc_property_t * propertyList = class_copyPropertyList(clas, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@" %@ 属性(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@",clas,[NSString stringWithUTF8String:propertyName]); &#125; NSLog(@"-------------------------------------------------------------------------------------------------------------- "); Method * methodList = class_copyMethodList(clas, &amp;count); for (int i = 0; i &lt; count; i++) &#123; Method methodName = methodList[i]; NSLog(@" %@ 方法(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@",clas,NSStringFromSelector(method_getName(methodName))); &#125; NSLog(@"-------------------------------------------------------------------------------------------------------------- "); Ivar *ivarList = class_copyIvarList(clas, &amp;count); for (int i = 0; i&lt;count; i++) &#123; Ivar myIvar = ivarList[i]; const char *ivarName = ivar_getName(myIvar); NSLog(@"%@ 成员变量(包括私有) --------&gt;&gt;&gt;&gt;&gt; %@",clas, [NSString stringWithUTF8String:ivarName]); &#125; NSLog(@"-------------------------------------------------------------------------------------------------------------- "); //获取协议列表 __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; Protocol *myProtocal = protocolList[i]; const char *protocolName = protocol_getName(myProtocal); NSLog(@"%@ 协议 --------&gt;&gt;&gt;&gt;&gt; %@",clas, [NSString stringWithUTF8String:protocolName]); &#125; 输出后的结果是其中也包括了私有方法。 2：拦截方法调用有的时候我们用一个类或者一个实例变量去调用一个方法，由于操作失误或者是其他原因，导致这个所被调用的方法并不存在，报出这样的错误，然后闪退！ 这个时候如果我们想避免这些崩溃，我们就需要在运行时对其做一些手脚。iOS中方法调用的流程：其实调用方法就是发送消息，所有调用方法的代码例如 [obj aaa] 在运行时runtime会将这段代码转换为objc_msgSend(obj, [@selector]);（本质就是发送消息）然后obj会通过其中isa指针去该类的缓存中(cache)查找对应函数的Method, 如果没有找到，再去该类的方法列表（methodList）中查找，如果没有找到再去该类的父类找，如果找到了，就先将方法添加到缓存中，以便下次查找，然后通过method中的指针定位到指定方法执行。如果一直没有找到，便会走完如下四个方法之后崩溃。 /** 如果调用的是不存在的实例方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理 */+(BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;&#125;/** 如果调用的是不存在的类方法则会在奔溃前进入该方法，防止崩溃可以在此处做处理 */+(BOOL)resolveClassMethod:(SEL)sel &#123; return YES;&#125;/** 这个方法会把你所调用的不存在的方法重定向到一个声明了该方法的类中，只需要你返回一个有该方法的 类就可以，如果你重定向的这个类仍然不具有该方法那么会继续崩溃 */-(id)forwardingTargetForSelector:(SEL)aSelector &#123;&#125;/** 将你不存在的方法打包成NSInvocation对象，做完你自己的处理之后 调用invokeWithTarget让某个target来处理该方法 */-(void)forwardInvocation:(NSInvocation *)anInvocation &#123; [anInvocation invokeWithTarget:self];&#125; 3：动态添加方法因为我们调用了一个不存在的方法导致崩溃，那么我们在判断出不存在后就动态添加上一个方法吧 这样不就不会蹦了吗？我们先写一个方法用来给我们做出提示 - (void) errorMethod &#123; NSLog(@"no method!!!!!!!");&#125; 如果调用了没有的方法，那么就把这个方法添加进去，然后把被调用的方法的指针指向这个error1：，那么一旦调用了没有的方法就会走这个。我们来看代码 +(BOOL)resolveInstanceMethod:(SEL)sel &#123; Method errorMethod = class_getInstanceMethod([self class], @selector(errorMethod)); if ([NSStringFromSelector(sel) isEqualToString:@"testMethod"]) &#123; BOOL isAdd = class_addMethod([self class], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod)); NSLog(@"tinajia = %d",isAdd); &#125; //Do something return YES;&#125; 主要用到 /** 添加方法 @param class] 在哪个类里添加 @param sel 添加的方法的名字 @param errorMethod 添加的方法的实现IMP指 @param types 方法的标示符 @return 是否添加成功 */BOOL isAdd = class_addMethod([self class], sel, method_getImplementation(errorMethod), method_getTypeEncoding(errorMethod)); 然后运行下： WKWebViewController * vc= [[WKWebViewController alloc] init];[vc performSelector:@selector(testMethod)]; 我调用了并不存在的testMethod方法并没有崩溃并且方法已经成功添加了 4：动态交换方法（也叫iOS黑魔法，慎用）没什么好例子，用一个网上说的例子(引用别人的东西，懒得复制了，就截了图) 其实本质即使SEL和IMP的交换，原理是这样的：在iOS中每一个类中都有一个叫dispatch table的东西，里面存放在SEL 和他所对应的IMP指针，之前也说过方法调用就是通过sel找IMP指针然后指针定位调用方法。方法交换就是对这个dispatch table进行操作。让A的SEL去对应B的IMP，B的SEL对应A的IMP，如图 这样就达到方法交换的目的，下面看代码： + (void)changeMethod &#123; // 如果是类方法 要使用 ! // 如果是系统的集合类的属性要用元类 比如 __NSSetM = NSMutableSet // Class class = NSClassFromString(@"__NSSetM"); // Class metaClass = objc_getMetaClass([NSStringFromClass(class) UTF8String]); Class systemClass = NSClassFromString(__NSSetM); SEL sel_System = NSSelectorFromString(addObject:); SEL sel_Custom = @selector(swizzle_addObject:); Method method_System = class_getInstanceMethod(systemClass, sel_System); Method method_Custom = class_getInstanceMethod([self class], sel_Custom); IMP imp_System = method_getImplementation(method_System); IMP imp_Custom = method_getImplementation(method_Custom); method_exchangeImplementations(method_System, method_Custom);&#125;- (void)swizzle_addObject:(id) obj &#123; if (obj) &#123; [self swizzle_addObject:obj]; &#125;&#125; 主要代码 method_exchangeImplementations(method1, method2); 这两个参数很简单，就是两个需要交换的方法。最后我调用了m1但是实际上走了m2。 动态交换方法的原理以及交换过程中指针的变化在通常的方法交换中我们通常有两种情景，一种是我会针对被交换的类建一个category，然后hook的方法会写在category中。另一种是自己创建一个Tool类里面放些常用的工具方法其中包含了方法交换。可能大家普遍选择第一种方法，但是如果你需要hook的类非常多的(我实际项目中就遇到这样的问题)那你就需要针对不同的类创建category，就会导致文件过多，且每一个文件中只有一个hook方法，这样一来左侧一堆文件，所以我用了第二种方法，但是在使用过程中出现一个问题，先看下我的代码结构 我要hook的是ViewController中的viewDidLoad方法，我建立了两个类一个是ViewController的category，另一个是Tool类，为了一会区别演示不同类hook的不同(两个类中hook的代码完全一样) ViewController中将要被替换的系统方法 Category中将要用来替换的自定义方法 然后在ViewController中的load中做方法替换 运行一下的输出结果想必大家已经猜到了先执行custom再执行system，这是通常情况下大家的做法。 下面再来看下如果我将替换方法写在不同类中会怎样，调用Tool中的交换方法 然后直接看结果了，因为代码都是一模一样的我直接复制过去的 发生了crash，原因是ViewController中没有swizzel_viewDidLoad_custom这个方法，为什么不同类的交换会出现这种问题，我们用个图来说明下 解决的办法是我们在交换方法之前要先像其中添加方法，也就是说把customMethod添加到SystemClass中，但是注意要把customMethod的实现指向syetemMethod的实现。这样一来就可以达到SystemClass调用customMethod却执行systemMethod的代码的效果，实现以上要求我们需要在交换之前执行这个方法。 class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System)) 其中第一个参数是需要往哪个类添加；第二个参数是要添加的方法的方法名；第三个参数是所添加的方法的方法实现，第四个是方法的标识符。经过就该之后我们的代码是这样 ..之前的都一样就省略..if (class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))) &#123; class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System)); &#125; else &#123; method_exchangeImplementations(method_System, method_Custom); &#125; 我们来看下执行完add操作之后此时的方法和类的对应关系(红色的为add的修改) 因为SystemClass中本身不包含customMethod所以add一定是成功的，也就是说会进入判断执行replace方法。 class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System)); 第一个参数：需要修改的方法的所在的类；第二个参数：需要替换其实现的方法名；第三个参数：需要把哪个实现替换给他；第四个参数：方法标识符。此时看下我们做完replace之后的类与方法名以及他们实现的关系(红色的为replace的修改)。 此时大家已经看出来了，虽然没有执行exchange方法，但是我已经达到了方法交换的目的。系统执行systemMethod时候会走customMethod的实现但是因为在customMethod方法中我会递归执行[self customMethod]，所以又会走到systemMethod的实现，因为之前进行了方法添加，所以此时A类中有了customMethod方法，不会再发生之前的crash。达到一个不同类进行Method Swizzling的目的。 综上来看一个完整严谨的MethodSwizzling应该在交换前先add，并且add方法的参数不能错+ (void)changeMethod &#123; Class systemClass = NSClassFromString(@"你的类"); SEL sel_System = @selector(系统方法); SEL sel_Custom = @selector(你自己的方法); Method method_System = class_getInstanceMethod(systemClass, sel_System); Method method_Custom = class_getInstanceMethod([self class], sel_Custom); IMP imp_System = method_getImplementation(method_System); IMP imp_Custom = method_getImplementation(method_Custom); if (class_addMethod(systemClass, sel_Custom, imp_System, method_getTypeEncoding(method_System))) &#123; class_replaceMethod(systemClass, sel_System, imp_Custom, method_getTypeEncoding(method_System)); &#125; else &#123; method_exchangeImplementations(method_System, method_Custom); &#125;&#125; 以上代码无论是写在工具类中还是category中都是没有问题的。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS端自动内存泄漏检测工具]]></title>
    <url>%2F2018%2F01%2F24%2FiOS%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[产生的背景 在移动设备上内存是一块公用的区域，如果一个App没有做好内存管理那么一定会导致性能急剧下降甚至会崩溃。Facebook的iOS端有许多的地方都共享着一块内存，如果任何一个地方占用太多的内存的话就会影响到整个App，比如一个地发生了内存泄漏，就会出现这种情况。我们把一组内存分配我们的一个对象，但是当我们使用完之后忘记释放他，这就通常就会引起内存泄漏，这就意味着系统永远不能回收这块内存也就导致这块内存一直不能分配给别的对象。在Facebook里我们有许多许多的工程师在代码的不同部分工作，内存泄漏时不可避免的，当一旦有内存泄漏发生我们就需要立即找到并且修复。虽然现在有好多检测内存泄漏的工具但是这些工具并不完善，他们仍然需要开发者去做一些工作： 1：打开Xcode并且Build 2：运行instrument 3：使用App尽可能的去复现 4：寻找内存泄漏的来源 5：解决问题 这意味着需要大量的体力活，并且都是些重复无聊的工作，这也导致了我们不能在开发周期就定位并且修复问题。 将这个过程自动化可以让我们在不需要太多的开发者的情况下更快的去找到内存泄漏。为了解决这个问题我们已经建立一套工具使我们能够自动的去完成这些过程，并且这套工具已经解决了我们自己代码的一些问题，今天我们很激动的宣布我们把他们发布了出来FBRetainCycleDetector, FBAllocationTracker, and FBMemoryProfiler. 循环引用 Objective-C使用引用计数来管理内存的，内存中的一个对象可以引用其他的对象，只要有一个对象使用它，那么他就会一直被留在内存中。我们也可以说一个对象持有另一个对象。 &emsp;&emsp;一般来说这都没问题。但是有一种情会使我们陷入僵局。当两个obj不在相互持有，而是通过另一个obj来互相持有，这样就会陷入一个循环引用的状态就像下面这张图 一个View Controller持有一个Viw View中持有delegate delegate中持有ViewController。这样就形成一个环状，谁也无法释放。 &emsp;&emsp;循环引用会导致一些列的的问题，如果一个对象在RAM中无限的占用空间，充其量也只是浪费一点点内存。如果这些泄漏的对象正在做一些其他的事情那么就会导致App的其他的地方再也无法使用这块内存。更严重的如果循环引用过多，就会浪费掉大量的内存最终导致程序的crash。 &emsp;&emsp;在我们进行人工调试的时候我们已经找出了大量的很明显的循环引用，我们能很好地定位他，但是在运行之后我们就很难发现他们，但是我们这SDK能很轻松的做这些事。 在Runtime下的循环引用检测&emsp;&emsp;在OC中找循环引用其实就类似于在一个节点为对象，链接线为引用关系的有向无环图中寻找一个环。打个比方如果A引用B那么A到B就会有箭头指向可以看这个我们发现这张图在箭头处发生循环引用 &emsp;&emsp;这个是一个很简单的引用关系我们必须确保我们能像左侧那样的来引用对象，其实对于每一个对象我们都获取他所有引用(持有的)对象，有的是强引用有的是弱引用，但是循环引用只发生在强引用上，对于每个对象我们需要搞清楚如何找到引用关系。 &emsp;&emsp;幸运的是OC给我提供了强大的Runtime，这足够让我们去挖掘其中的关系，图中的一个点可能是block或者是Object中的其中一个，让我们来分别讨论下 Objects&emsp;&emsp;Runtime中有很多工具去帮助我们了解其中的东西，首先我们搞懂到所有实例变量的引用关系const char *class_getIvarLayout(Class cls);const char *class_getWeakIvarLayout(Class cls); 对于一个给定的对象，实例变量布局图告诉我们了他都引用了哪些对象，他会给我提供一个索引，这个索引相当于一个偏移量，该对象加上这个偏移量就是他所引用的对象的地址。运行时会给我们提供一个“弱引用”的布局图，也就是该对象所有弱引用的对象，强引用和弱引用之间的区别我们可以猜想为就是强引用的布局图。 &emsp;&emsp;对于objective-c++来说我们可以用结构体来定义一个对象，这些对象不会再实例变量的布局图中被获取到，不过Runtime给我提供了“类型编码”来处理这个问题，对于每个实例变量，类型编码描述了变量是如何构造的。如果它是一个struct，类型编码可以描述出它包含的字段和类型。我们解析类型编码以找到哪些实例变量是objective-c的对象。然后我们可以像在布局图中那样计算他的偏移量然后拿到他所引用的对象的地址。 &emsp;&emsp;还有一些我们不会深入讨论的边缘案例。这些都是不同的集合，我们必须列举它们来获取它们的保留对象，这可能会产生一些副作用。 Blocks&emsp;&emsp;block和对象有一点不同。运行时不允许我们轻松地查看它们的布局，但是我们仍然可以进行猜测。在处理block时，我们使用了Mike Ash在他的项目Circle中提出的想法:也正是这个项目激发FBRetainCycleDetector的项目。 &emsp;$emsp;我们可以使用application binary interface for blocks (ABI)，他可以向我们展示一个block在内存中是什么样子的，如果我们知道了我们所研究的block的表现形式我们就可以用一个假的结构体来模仿实现block的功能，之后我们就能知道了哪些对象被block引用并且一直在那里，但是不幸的是我们并不知道这些事强引用还是弱引用。 &emsp;&emsp;为了做到这些我们使用黑盒的方法，首先我们创建一个假的对象来模仿我们所研究的Block，因为是我们自己创建的假对象，所以我们可以完全的操作他，我们给这个假装的block上面装上释放探测器，释放探测器是监听发给他们的释放消息的一个对象，如果一个所有者想放弃对对象们所有权的时候，释放探测器会给他所有强引用的对象发出消息，当我们释放我们的假对象时，我们可以检查哪些探测器收到了这样的消息。便知道了哪些block是被强引用的。这样一来我们可以找到我们原始block所持有的真是的对象，如下图所示 自动化&emsp;&emsp;员工在进行持续执行时，这个工具就会非常出色。自动化在客户端上是非常容易的，我们使用定时器来建立一个循环引用检测，用来周期性的扫描一部分内存去寻找循环引用，不过还是有点问题，我们第一次运行检测器的时候我们发现他不快速的扫描完整个内存空间，所以我们需要给他提供一个候选检测对象，为了做到这一点，我们建立了FBAllocationTracker，他可以追踪任何一个Nsobject对象的创建和销毁，他同样可以在任何给定的时刻以最小的性能开销来获取任何类的实例对象。 &emsp;&emsp;在客户端上实现了这样的自动化操作意味着我们可以更加简单的在NSTimer上使用FBRetainCycleDetector和添加用了追踪实例的FBAllocationTracker，现在让我们来看下后端到底发生了什么，循环引用可以有多个对象来组成，如果创建了许多的引用环并且有一个泄漏了那么事情将会变得非常复杂。如下如所示A-&gt;B就是一个坏的引用环导致了A-&gt;B-&gt;C-&gt;D和A-&gt;B-&gt;C-&gt;E 遇到这样的问题就会给我们的SDK带来两个问题： 如果这两个环是由于一个不良引用引起我们就直接标记一处不良引用就可以了，不用标记两处，这样会给开发者一个错误信号。 如果这两个环是虽然由一个不良引用引起但是会导致两个不同的错误，那么我们就需要将这个两个循环引用都标记出来 因此我们需要建立一个循环引用群，我们通过下面这些启发写了一种算法。 1：把给定日期中所检测出的所有循环引用收集起来。 2：找到每个循环引用环中Facebook特定的类名。 3：找到每个环中最小的那个环。 4：把最小周期放到一个组中。 5：仅仅只像开发者报告最小的周期。 有了这些最后一部分就是找出谁可能会意外的引入一个循环引用，我们通过“git/hg blame”来做到这些。猜测这可能是导致出现问题的最新修改。最后一个提交代码的人会收到一个通知。整个系统可以如下展示 手工配置&emsp;&emsp;尽管自动化帮助简化了寻找循环引用的过程，并减少了开发人员的工作，但是手动配置仍然很重呀。我们开发的另一款工具允许任何人查看应用程序的内存使用情况，甚至不用将手机插入电脑。FBMemoryProfiler可以很容易地添加到任何应用中，让你手动配置你的工程，并在应用中运行循环引用检测，它可以通过使用FBAllocationTracker和fbretaincycle检测器来完成。 原文链接 https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>优化</tag>
        <tag>国外文献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)如何掌握所有的程序语言]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%BD%AC-%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[觉得作者写的很好就转载下，原文链接：http://www.yinwang.org/blog-cn/2017/07/06/master-pl 对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道标题问题的答案，所以总感觉这个问题是如此“低级”，一直没来得及回复 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。今天休闲活动进入第二个星期，稍微闲下来一点，我想来统一回答一下这个搁置已久的“初级问题”。这个话题貌似曾经写过，然而现在我想把它重新写一遍。因为通过跟很多人的交流，我对自己头脑中的（未转化为语言的）想法，有了更精确的表达。如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：你是编程初学者，不知道该选择什么程序语言来入门。你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”于那种语言。你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪…… 虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝 :P其实呢，我并不是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。。。 :P重视语言特性，而不是语言很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：变量定义算术运算for 循环语句，while 循环语句函数定义，函数调用递归静态类型系统类型推导lambda 函数面向对象垃圾回收指针算术goto 语句 这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，我都可以把他纠结过的语言全部掌握了。初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。在这个过程中，他会问这样的问题：这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？…… 注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的博文里指出了 checked exception 和 union type 之间的关系 :P很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。合理的入门语言所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：SchemeCJavaPythonJavaScript 那么相比之下，我不推荐用哪些语言入门呢？ShellPowerShellAWKPerlPHPBasicGo 总的说来，你不应该使用所谓“脚本语言”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。掌握关键语言特性，忽略次要特性为了达到我之前提到的“融会贯通”，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的内容分心。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解“变量”和“函数”是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 %d，%f，%.2f 的含义都记不住，还怎么学编程！然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？所以你就发现一旦被坏老师教过，这个程序员基本就毁了。就算遇到好的老师，她也很难纠正过来。自己动手实现语言特性在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完完全全的拥有它们，成为它们的主人。否则你就只是它们的使用者，你会永远做语言创造者们的仆人。有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念。它甚至能帮助你理解各种面向对象实现的差异，这种效果是你直接学习 OOP 语言也得不到的。类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前都是可以被任意拆卸组装玩弄的玩具，而不再是凌驾于我之上，高高在上的神圣。总结写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是整个语言的“品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码]]></content>
      <categories>
        <category>通用开发</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Runtime Hook的问题]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Runtime-Hook%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景项目中遇到一个问题，需要引入两个SDK，我们暂且命名为A 和 B，由于业务需要这两个SDK都需要对一个系统函数C进行hook, 但是有一个前提，由于B 所做的是一个统计相关的SDK，所以B要监控App内的所有代码这其中也包括了 SDK A 所做的一些操作，所以我们必须确保B在hook C函数时候 A已经对C函数hook完毕，其实这就涉及到hook顺序的问题。 研究先看下代码，我用hookMethod来模仿系统方法。- (void) TEST_HOOK_TWICE &#123; [self changeOrginalSelectorName:@"hookedMethod" inClass:@"RootViewController" withCustomSelectorName:@"swizzle_hookedMethod1" isClassMethod:NO]; [self changeOrginalSelectorName:@"hookedMethod" inClass:@"RootViewController" withCustomSelectorName:@"swizzle_hookedMethod2" isClassMethod:NO]; [self hookedMethod];&#125;- (void)hookedMethod &#123; NSLog(@"原始方法");&#125;- (void)swizzle_hookedMethod1 &#123; NSLog(@"1"); [self swizzle_hookedMethod1];&#125;- (void)swizzle_hookedMethod2 &#123; NSLog(@"2"); [self swizzle_hookedMethod2];&#125; 然后看下没有hook之前的样子 然后我们执行代码//第一步：交换A中的方法和系统方法 [self changeOrginalSelectorName:@"hookedMethod" inClass:@"RootViewController" withCustomSelectorName:@"swizzle_hookedMethod1" isClassMethod:NO];//第二步：交换B中的方法和系统方法[self changeOrginalSelectorName:@"hookedMethod" inClass:@"RootViewController" withCustomSelectorName:@"swizzle_hookedMethod2" isClassMethod:NO];//第三步：调用系统方法[self hookedMethod]; 然后我们一步一步来看，先看调用第一步之后是什么样子的(红色箭头为第一步之后的样子) 然后看第二步调用完之后的样子(绿色是第二步调用) 接下来我们调用系统方法也就是第三步，然后我们看下流程是怎样的(每个方法实现里面都会递归调用下自身，为了是hook时候不改变原有逻辑) 这样一来就很明显 如果想想监控住所有的代码那就需要在A IMP 这步，因为之前的Hook顺序是先A -&gt; B -&gt; System 这样一来只要我们改一下顺序改为 B -&gt; A -&gt; System就可以让B SDK监控到所有的代码。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>runtime</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中使用OpenGL实现增高功能]]></title>
    <url>%2F2018%2F01%2F23%2FiOS%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%E5%AE%9E%E7%8E%B0%E5%A2%9E%E9%AB%98%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[功能效果 功能分析 功能：渲染一张传入的图片 -&gt; 手动选择编辑区域 -&gt; 通过滑块来编辑区域的增高或者缩短 OpenGL原理： 因为OpenGL 只能绘制三角形，所以在处理图像或者图形的时候我们需要将被处理的对象用三角行来分割转换为三角形和顶点的组成的对象。 OpenGL里面坐标是以左下角为原点X轴向上为正，Y轴向右为正 功能实现 渲染图片拆分图片： 拆分方法1：通过图形看出是一个矩形，而矩形是可以分成两个三角形和四个顶点，通过此可以用GL渲染出图片。 这样拆分之后虽然可以正常渲染，但是带来的问题是我的四个顶点都是死的，也就是四个顶点必须是画布的四个顶点，改变顶点的坐标后只能导致整张画布的变动，而不是某一个区域的变动，拉伸的话也是整张图片的拉伸，所以想要实现局部处理的话这种分割方式不可行。 拆分方法2：将整张图片先拆分为三个矩形，然后再把每个矩形拆分成两个三角形，得到6个三角形，8个顶点，如下图： 这样一来就可以保证中间的矩形的高度可以任意变化而上下两部分的高度不变只改变位置，也就是说我们这个DEMO中所做的任何拉伸操作都是对中间矩形的操作，换而言之就是改变最上面的矩形和最下面的矩形之间的距离来达到对中间区域的拉伸和压缩的目的。根据拆分的方式我们用顶点的坐标创建一个数组//顶点数组GLfloat vertices[] = &#123; -1.2, -1.2, //左下 1.2, -1.2, //右下 -1.2, -0.4, //小矩形左下 1.2, -0.4, //小矩形右下 -1.2, 0.4, //小矩形左上 1.2, 0.4, //小矩形右上 -1.2, 1.2, //左上 1.2, 1.2, //右上&#125;; //填充纹理的数组GLfloat texCoords[] = &#123; 0, 0, //左下 //下标为 0 1 1, 0, //右下 //下标为2 3 0, 1.0/3.0, //小矩形左下 //下标为4 5 1, 1.0/3.0, //小矩形右下 //下标为6 7 0, 2.0/3.0, //小矩形左上角 //下标为8 9 1, 2.0/3.0, //小矩形右上角 //下标为10 11 0, 1, //左上 //下标为12 13 1, 1, //右上 //下标为14 15&#125;; 手动选择区域：通过添加带有自定义手势的UIView 来实现拖动修改选择区域。 *****************CustomPanView代码******************#import &lt;UIKit/UIKit.h&gt;@protocol CustomPanViewDelegate &lt;NSObject&gt;/** * 开始拖拽 * * @param customPanView 自身 * @param centerY 自身所在的y坐标 */- (void)beginDragWithCoustomPanView:(UIView *)customPanView centerY:(CGFloat)centerY;@end@interface CustomPanView : UIView@property (nonatomic, assign) id&lt;CustomPanViewDelegate&gt; delegate;@end *****************CustomPanViewDelegate代码******************#pragma mark -#pragma mark 拖拽View的代理方法-(void)beginDragWithCoustomPanView:(UIView *)customPanView centerY:(CGFloat)centerY &#123; // 限制范围：裁剪区不能大于图片区域 if (customPanView.center.y &gt;= imageBottom) &#123; customPanView.center = CGPointMake(customPanView.center.x, imageBottom); &#125; if (customPanView.center.y &lt;= imageTop) &#123; customPanView.center = CGPointMake(customPanView.center.x, imageTop); &#125;// 获取两条线的坐标 CGFloat topY = _topView.center.y; CGFloat bottomY = _bottomView.center.y;// 根据两条线的坐标刷新裁剪区域UI [_cutLabel setFrame:CGRectMake(0, topY &lt; bottomY ? topY : bottomY, SCREEN_WIDTH, fabs(bottomY - topY))];// 算出裁剪起始坐标和结束坐标 CGFloat fromPoint = topY &lt; bottomY ? (imageBottom - bottomY) / imageHeight : (imageBottom - topY) / imageHeight; CGFloat toPoint = topY &lt; bottomY ? (imageBottom - topY) / imageHeight : (imageBottom - bottomY) / imageHeight; //将中间的矩形的顶点坐标和坐标联系裁剪区域联系起来。 [self sendFromePoint:fromPoint endPoint:toPoint]; if (_cutLabel.frame.size.height &lt; 30) &#123; //隐藏文字 _cutLabel.text = @""; &#125; else &#123; _cutLabel.text = @"编辑区域"; &#125; [self.slider setValue:0.0 animated:YES]; tmpHeight = 0.0f;&#125; 使用一个Delegate将拖移后的Y坐标返回，因为是竖直运动的所以我们只关心Y轴坐标。 改变大小：通过将UISliderBar的ValueChange和顶点坐标关联来实现改变顶点坐标，之后调用GLKView 的display的方法来刷新UI，将变化的过程展现出来。 - (void)action:(UISlider *)sender &#123; //判断是否是向右滑动 isRightDirection = sender.value &gt;= judgeDirection ? YES : NO; //所改变的高度 changeHeight = sender.value - tmpHeight; //遍历数组 for (int i = 0; i &lt; 16; i ++) &#123; //将Y坐标筛选出来 if (i % 2 != 0) &#123; //下半部分矩形 if (i &lt;= 7) &#123; //下半部分矩形Y轴做减法减去变化的高度 vertices[i] = verticesCopy[i] - changeHeight; //上半部分矩形 &#125; else if (i &gt;= 9) &#123; //上半部分矩形Y轴做加法加上变化的高度 vertices[i] = verticesCopy[i] + changeHeight; &#125; &#125; &#125; //缩小时候如果编辑区域已经成为一条线了就不能在缩小了 if (vertices[11] &gt; vertices[7]) &#123; [self.glView display]; &#125;&#125; 通过glReadPixels来从内存中读取像素数据，GLubyte -&gt; CGImageRef -&gt; UIimage 然后最相关的保存或者其他操作。 #pragma mark -#pragma mark 获取处理后的图片- (UIImage *) createImage &#123; int imageY = 0; int imgHeight = 0; if (isRightDirection) &#123; // 判断slider滑动方向 imageY = fabs(imageTop - fabs(changeHeight * perOpengleseCoordinate)) * screenScale; imgHeight = fabs(imageHeight + 2 * fabs(changeHeight * perOpengleseCoordinate)) * screenScale; &#125; else &#123; imageY = fabs(imageTop + fabs(changeHeight * perOpengleseCoordinate)) * screenScale; imgHeight = fabs(imageHeight - 2 * fabs(changeHeight * perOpengleseCoordinate)) * screenScale; &#125; int imageWidth = SCREEN_WIDTH * screenScale; int dataLength = imageWidth * imgHeight * 4; GLubyte *data = (GLubyte*)malloc(dataLength * sizeof(GLubyte)); glPixelStorei(GL_PACK_ALIGNMENT, 4); glReadPixels(0, imageY, imageWidth, imgHeight, GL_RGBA, GL_UNSIGNED_BYTE, data); //从内存中读取像素 CGDataProviderRef ref = CGDataProviderCreateWithData(NULL, data, dataLength, NULL); CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB(); CGImageRef iref = CGImageCreate(imageWidth, imgHeight, 8, 32, imageWidth * 4, colorspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast,ref, NULL, true, kCGRenderingIntentDefault); UIGraphicsBeginImageContext(CGSizeMake(imageWidth, imgHeight)); CGContextRef cgcontext = UIGraphicsGetCurrentContext(); CGContextSetBlendMode(cgcontext, kCGBlendModeCopy); CGContextDrawImage(cgcontext, CGRectMake(0, 0, imageWidth, imgHeight), iref); CGImageRef imageMasked = CGBitmapContextCreateImage(cgcontext); UIImage * image = [UIImage imageWithCGImage:imageMasked scale:screenScale orientation:UIImageOrientationUp]; UIGraphicsEndImageContext(); free(data); CFRelease(ref); CFRelease(colorspace); CGImageRelease(iref); return image;&#125;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>UI</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于物理效果的动画引擎UIDynamic介绍]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8EUIDynamic%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[这几天事情超多，实在很难静下心来研究一个东西，但是这个类我也是关注好久了，早就想总结下写出来， 可能这篇文章并不会像之前额那样那么详细，按理说写动画相关的东西应该是配gif的，但是真的是没有心思再去搞那些东西，代码并不难，大家可以照着代码写一下看下效果。 为了实现动力UI，需要注册一套UI行为的体系，之后UI便会按照预先的设定进行运动了。我们应该了解的新的基本概念有如下四个：UIDynamicItem：用来描述一个力学物体的状态，其实就是实现了UIDynamicItem委托的对象，或者抽象为有面积有旋转的质点； 简单的说就是一个控件，就是你想往谁上面加动画，这个就是谁。UIDynamicBehavior：动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则。一般我们使用这个类的子类对象来对一组UIDynamicItem应该遵守的行为规则进行描述；简单的说就是动画效果，这个类是动画效果的一个父类，它的子类大家可以用运行时的方法输出一下看一下，或者一会看我介绍，一个子类是一个效果，各种效果比如重力啊碰撞啊，链接啊之类的。UIDynamicAnimator；动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；ReferenceView：等同于力学参考系，如果你的初中物理不是语文老师教的话，我想你知道这是啥..只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。下面看下我们给一个button加一个重力下坠的动画 使用self.View做参考系来建立动画 然后 你可以吧这里航代码写到button的点击事件中，这样你一点就会下坠。很简单吧。 再看下一个碰撞 我这里写碰撞动画的时候用了两个button，其实大家可以猜到我是让两个button来碰撞的，碰撞的过程中也是会走代理方法的，开始碰撞啊，碰撞结束啊之类的。最后那句话的意思是吧他的参考系(这里是的self.view)的边界作为碰撞边界，就是说这段代码运行后这两个 这两控件撞到屏幕self.view的边框会发生物理的碰撞反弹效果。想这样(点我开始那个按钮) 除了重力和碰撞，iOS SDK还预先帮我们实现了一些其他的有用的物理行为，它们包括 UIAttachmentBehavior 描述一个view和一个锚相连接的情况，也可以描述view和view之间的连接。attachment描述的是两个点之间的连接情况，可以通过设置来模拟无形变或者弹性形变的情况（再次希望你还记得这些概念，简单说就是木棒连接和弹簧连接两个物体）。当然，在多个物体间设定多个；UIAttachmentBehavior，就可以模拟多物体连接了..有了这些，似乎可以做个老鹰捉小鸡的游戏了- -…UISnapBehavior 将UIView通过动画吸附到某个点上。初始化的时候设定一下UISnapBehavior的initWithItem:snapToPoint:就行，因为API非常简单，视觉效果也很棒，估计它是今后非游戏app里会被最常用的效果之一了；UIPushBehavior 可以为一个UIView施加一个力的作用，这个力可以是持续的，也可以只是一个冲量。当然我们可以指定力的大小，方向和作用点等等信息。UIDynamicItemBehavior 其实是一个辅助的行为，用来在item层级设定一些参数，比如item的摩擦，阻力，角阻力，弹性密度和可允许的旋转等等 其实流程很简单创建animator 然后创建behivator 设置behivator属性 然后animator addBehivator 。就是这个么流程。写代码要学会举一反三触类旁通。 这篇博客写的比较急，但是总体上来说功能没问题，细节上有什么问题，大家找我一起交流]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于视图在切圆角时候的导致的性能下降的一些探讨]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE%E5%9C%A8%E5%88%87%E5%9C%86%E8%A7%92%E6%97%B6%E5%80%99%E7%9A%84%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[iOS中有的时候我们控件要做成圆形 或者是切成圆角，这个时候我们一般都会使用.layer.cornerRadius -&gt; clipsToBounds = YES 的属性来切，这样完全能达到我们的效果，但是如果一个界面上需要切圆角的控件很多，并且列表很长的时候，尤其是像tableView那样如果每一个cell上都有大量的控件需要切，那么就会非常卡顿，帧数严重下降 。其实原因就是这样设置会触发离屏渲染，比较消耗性能。注意：png图片UIImageView处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）。这里先说下离屏渲染： iOS的渲染机制： CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。GPU屏幕渲染有以下两种方式：On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由以上可以看出离屏渲染需要重新开辟新的缓存空间，必定要更加消耗资源。通过查资料目前知道了设置了以下属性时，都会触发离屏绘制：shouldRasterize（光栅化）masks（遮罩）shadows（阴影）edge antialiasing（抗锯齿）group opacity（不透明）复杂形状设置圆角等渐变我用一个现有的小DEMO来测试下，因为这个demo中没有切圆角，但是有阴影，一样可以出发离屏渲染，所以效果是一样的，在tableView中的自定义cell类中我设置了阴影如图： 使用Instruments测试得到当前帧数在二三十左右 同时屏幕是也出现了黄色图层 所有黄色的高亮的图层都进行了离屏渲染，也表示这些图层存在着问题，影响性能。而且帧数过低也会直接影响我们对APP的体验。 如何避免离屏渲染： 方法一：使用光栅化，.layer.shouldRasterize = YES; -&gt; .layer.rasterizationScale=[UIScreen mainScreen].scale;设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。 方法二：最简单的方法，就是图片不作处理，直接覆盖一张中间为圆形透明的图片（推荐使用）这种方法GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的 方法三：Core Graphics绘制圆角。这种方式GPU损耗最低，可以用UIimageView添加个点击手势当做UIButton使用。UIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);[[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];[image drawInRect:avatarImageView.bounds];avatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();这段方法可以写在SDWebImage的completed回调里，在主线程异步绘制。也可以封装到UIImageView里，写了个DSRoundImageView。后台线程异步绘制，不会阻塞主线程。目前这种方法只用在imageView上，其他地方呢不知道怎么用，不过这种方法会耗费大量的CPU资源和占用内存，本人不太建议使用。 最后给大家测试下，因为我之前的demo没有切圆角，而是使用的阴影，所以我就用第一种方法给大家测一下。 然后运行，打开Instruments，然后看屏幕 图层都是绿色没问题，我们再来看帧数，几乎到60 ，效果很明显。 由此可见以后大家再切圆角的时候多注意下，刚才就研究了这么多，有什么问题及时与我交流吧。。。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFNetwork的介绍和使用]]></title>
    <url>%2F2018%2F01%2F23%2FCFNetwork%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CFNetwork背景简介CFNetwork是ISO中一个比较底层的网络框架，C语言编写，可以控制一些更底层的东西，如各种常用网络协议、socket通讯等，我们通常使用的NSURL则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。CFNetwork已经接近于UNIX系统的socket通信了，使用CFHttpMessageRef进行HTTP连接的好处就是控制的粒度更细了，例如你可以设置SSL连接的PeerName，证书验证的方式，还可以控制每个响应包的接收。不过CFNetwork本质上还是应用层上的封装的通用API。使用者可以不用关心底层协议的实际细节。下图是CFNetwork在iOS系统中的位置(图片来源于官方文档)。 由上图可以看出目前iOS的网络编程分四层： WebKit：属于Cocoa层，苹果很多地方用到的页面渲染引擎WKWebview； NSURL：也属于Cocoa层，对各类URL请求的封装(NSURLRequest)； CFNetwork：属于Core Foundation层，基于C的封装，同样的还有CFNetServices(write/readstream)； BSD sockets：属于OS层，也是基于C的封装； CFNetwork结构上图也是官方文档的图片，描述了CFNetwork的结构，下面逐一讲解。 CFSocket APISocket是网络通讯的底层基础，两个socket端口可以互发数据。我们通常使用的是BSD socket，CFSocket则是BSD socket的抽象，基本上实现了几乎所有BSD socket的功能，并且还融入了run loop。 CFStream APICFStream API提供了数据读写的方法，即读写流，使用它可以为内存、文件、网络（使用socket）的数据建立stream，我们进行网络请求就是对数据的读写，CFStream提供API对两种CFType对象提供抽象：CFReadStream and CFWriteStream。它同时也是CFHTTP和CFFTP的基础。stream有一个很重要的特性就是一旦数据流被提供或者被消耗，就不能从流中重新取出。比如这样 uint8_t d[1024] = &#123;0&#125;;//循环条件：流中是否有可用数据(被读过的数据不可用了)while ([self.inputStream hasBytesAvailable]) &#123; //读取相应长度的数据数据 NSInteger len = [self.inputStream read:d maxLength:1024]; //如果读取到数据，便将数据快拼接 if (len &gt; 0 &amp;&amp; !self.inputStream.streamError) &#123; [data appendBytes:(void *)d length:len]; &#125; else &#123; break; &#125;&#125; CFFTP API对用FTP协议通信的封装，能下载、上传文件和目录到FTP服务器。CFFTP建立的连接可以是同步或者异步，此次不做详解。 CFHTTP API是HTTP协议的抽象，主要对象是CFHTTPMessageRef(类似于我们通常的NSURLRequest)我们需要像构建NSURLRequest那样来构建CFHTTPMessageRef，同样包含一下几个元素 必须元素 请求方法 (类型为CFStringRef)：POST、GET、DELETE等.. 请求的URL地址 (类型为CFURLRef)：https://www.baidu.com 请求的HTTP版本(类型为CFStringRef)：通常使用kCFHTTPVersion1_1 kCFAllocatorDefault：用于创建消息引用的指定默认的系统内存分配器。 可选参数 body体(类型为CFDataRef) CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData) CF_AVAILABLE(10_1, 2_0); 消息头部，如User-Agent等； CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef __nullable value) CF_AVAILABLE(10_1, 2_0); CFNetwork请求过程1：构造并创建CFHTTPMessageRef对象//构造的方式上一步已讲CFHTTPMessageCreateRequest(CFAllocatorRef __nullable alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion) CF_AVAILABLE(10_1, 2_0); 2：使用CFHTTPMessageRef对象创建输入流//第一个参数传默认CFReadStreamCreateForHTTPRequest(CFAllocatorRef __nullable alloc, CFHTTPMessageRef request) CF_DEPRECATED(10_2, 10_11, 2_0, 9_0, "Use NSURLSession API for http requests"); 3：适配SNI环境（一个 IP 地址上可以为不同域名分配使用不同的 SSL 证书；这同时意味着，共享 IP 的虚拟主机也可实现 SSL/TLS 连接。）因为配置sni环境的所有配置都是基于输入流来操作，所以我们构建完成输入流之后来处理sni，像这样[self.inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];//请求的URL的HostNSDictionary *sslProperties = @&#123; (__bridge id) kCFStreamSSLPeerName : host &#125;;[self.inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings]; 4：打开输入流打开输入流分为两步 设置代理：[self.inputStream setDelegate:weakSelf] 加入当前的runloop： [_inputStream removeFromRunLoop:self.runloop forMode:[self runloopMode]]; 调用Open方法 5：收到代理数据回调- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode; 其中分为几个状态typedef NS_OPTIONS(NSUInteger, NSStreamEvent) &#123; NSStreamEventNone = 0, NSStreamEventOpenCompleted = 1UL &lt;&lt; 0, NSStreamEventHasBytesAvailable = 1UL &lt;&lt; 1, NSStreamEventHasSpaceAvailable = 1UL &lt;&lt; 2, NSStreamEventErrorOccurred = 1UL &lt;&lt; 3, NSStreamEventEndEncountered = 1UL &lt;&lt; 4&#125;; 通常我们会关心NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable、NSStreamEventErrorOccurred、由于数据是以流的形式回来，我们需要在在NSStreamEventHasBytesAvailable下取出数据然后做数据拼接，拼接好完整的数据才可使用，像这样 case NSStreamEventHasBytesAvailable:&#123; UInt8 buffer[BUFFER_SIZE]; //设置缓存区 NSInteger numBytesRead = 0; NSInputStream *inputstream = (NSInputStream *) aStream; // Read data do &#123; numBytesRead = [inputstream read:buffer maxLength:sizeof(buffer)]; if (numBytesRead &gt; 0) &#123; [self.resultData appendBytes:buffer length:numBytesRead]; &#125; &#125; while (numBytesRead &gt; 0);&#125;break; 循环结束后我们的resultData就是完整的返回数据了。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Http请求、DNS劫持与解析]]></title>
    <url>%2F2018%2F01%2F23%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Http%E8%AF%B7%E6%B1%82%E3%80%81DNS%E5%8A%AB%E6%8C%81%E4%B8%8E%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景前段时间在处理iOS端的HTTPDNS相关SDK，在接入和测试环节发现大家对HTTP的整体请求流程包括HTTP劫持原理以及HTTPDNS的工作原理并不是太清楚，所以写下这边文章帮助大家深入web请求过程：如何发起请求，HTTP协议解析，DNS域名解析。 HTTP发起一个请求过程当我们在手机端请求一个@”www.baidu.com”的域名的时候 1.请求到达运营商的DNS服务器并由其把这个域名解析成对应的IP地址。 2.根据IP地址在互联网上找到对应的服务器，向这个服务器发起一个get\post请求。 3.由这个服务器找到对应的资源原路返回给访问的用户。 这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器上又会处理这个用户的请求。 HTTP劫持我们使用HTTPDNS的主要目的就是解决HTTP劫持问题。HTTP的劫持分两种第一种是DNS劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解： 1：DNS劫持 劫持流程DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示 从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。 解决办法 DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。 HttpDNS是使用HTTP协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求,绕开了运营商的Local DNS，从而避免了使用运营商Local DNS造成的劫持和跨网问题 2：内容劫持 劫持流程内容劫持网上很少有提到，这也是在做httpDNS SDK所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据 黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。 解决办法：现在暂时无法通过HTTPdns和其他手段解决，不过这样的劫持不是很多。 DNS解析过程如果是iOS设备请直接跳到第三步骤 1.系统会检查浏览器缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。 2.如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的Host文件。 3.如果本地Host文件中没有那么操作系统会把这个域名发送给这里设置的LocalDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约90%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。 4.如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析 5.根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD是国际顶级域名服务器，如.com，.cn、.org等。全球只有13台左右。 6.本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。 7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成 8.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。 9.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。 10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。以上的流程可以简化为下图 绿色的为非iOS设备的操作流程 CDN工作机制CDN简介CDN，全称Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他-有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN=镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN可以明显提高Internet中信息流动的效率。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。这里引用一个网上比较形象的例子：A家的网速 100M的，但他只用了10M的速度，B家的网速是10M的，但是他需要15M的速度才行。怎么办呢。 C是一家CDN服务商，在A家有个节点（就像A是一个赞助商一样）B在C家买了CDN加速服务。当B的速度不够的时候，CDN加速就会选择有节余的节点来帮B，提高B的速度。这样B的速度就能达到或超过15M ，A没浪费，B速度有了，C赚了钱，皆大欢喜。 当C的节点在全国都有，非常多的时候。那么你用C家的CDN加速服务，你就会健步如飞了。 CDN工作流程一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。 负载均衡负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。CDN整体的工作流程可以大概归为下图： 总结以上就是Http请求的一些理解，如果有不对的地方及时与我来沟通。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在iOS11下app图标变空白的问题解决]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%9C%A8iOS11%E4%B8%8Bapp%E5%9B%BE%E6%A0%87%E5%8F%98%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[背景：最近在做项目的时候发现运行在模拟器上图标丢失，变成了苹果默认的白板图标。因为一开始只在模拟器上出现，而且也确认没有人动过图标文件，所以没有在意，后来慢慢的该问题出现在真机上，一开始是只有iPhone X，然后就是iPhone 8，慢慢的变成不管是模拟器还是真机，所有iOS11 系统的图标都没有了。接下来影响到的机型和系统越来越多。 尝试：1：一开始想到的是可能有人误改了图标文件，于是删除了images.xcassest中的AppIcon文件，从新生成→添加图标，但是依然未解决。（✘） 2：想到是图片格式/尺寸的问题，于是所有图片按照规定重新生成，但是仍然无济于事。（✘） 3：因为设置图标的方法除了在images.xcassest中的AppIcon文件中设置还可以在info.plist设置、或者直接在工程里面放一个icon.png的图片来设 置，所以都检查了一便发现也不是这个原因（✘） 3：重置手机。(✘) 解决：google了下发现好多国外的开发遇到这个问题，并且都是使用xcode9.X.X版本，所以怀疑是苹果的BUG 不过这个问题并不是谁都会出现也不是所有使用xcode9 + iOS11的设备都会出现 后来经过大家的讨论终于有人说这个其实是cocoapods的BUG，暂时并不能通过更新cocoapods更新来解决，因为最新版的cocoapods 也存在这个问题，解决方法如下： 在你的podfile中加入以下代码就可以了 post_install do |installer| copy_pods_resources_path = "Pods/Target Support Files/Pods-工程名/Pods-工程名-resources.sh" string_to_replace = '--compile "$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;"' assets_compile_with_app_icon_arguments = '--compile "$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;" --app-icon "$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;" --output-partial-info-plist "$&#123;BUILD_DIR&#125;/assetcatalog_generated_info.plist"' text = File.read(copy_pods_resources_path) new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments) File.open(copy_pods_resources_path, "w") &#123;|file| file.puts new_contents &#125;end 像这样：]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>xcode</tag>
        <tag>cocoapods</tag>
        <tag>podfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS下三种DNS解析方式分析（LocalDns）]]></title>
    <url>%2F2018%2F01%2F23%2FIOS%E4%B8%8B%E4%B8%89%E7%A7%8DDNS%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90%EF%BC%88LocalDns%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景最近在做iOS的DNS解析，顺便研究了下iOS端本地的DNS解析方式（localDNS）,也就是不依赖Http请求，而是用原始的API进行解析，虽然有HttpDNS但是考虑到成本、第三方服务稳定性的问题，LocalDNS仍然是一个很重要的部分，在iOS系统下，localDNS的解析方式有三种，下面主要对三种方式进行下利弊分析及简单的原理介绍。 方式一这个也是我一开始在项目中使用的方式。1：struct hostent *gethostbyname(const char *);2：struct hostent *gethostbyname2(const char *, int); 两个函数作用完全一样，返回值一样，但是第一个只能用于IPV4的网络环境，而第二个则IPV4和IPV6都可使用，可以通过第二个参数传入当前的网络环境。 使用方式：CFAbsoluteTime start = CFAbsoluteTimeGetCurrent(); char *ptr, **pptr; struct hostent *hptr; char str[32]; ptr = "www.meitu.com"; NSMutableArray * ips = [NSMutableArray array]; if((hptr = gethostbyname(ptr)) == NULL) &#123; return; &#125; for(pptr=hptr-&gt;h_addr_list; *pptr!=NULL; pptr++) &#123; NSString * ipStr = [NSString stringWithCString:inet_ntop(hptr-&gt;h_addrtype, *pptr, str, sizeof(str)) encoding:NSUTF8StringEncoding]; [ips addObject:ipStr?:@""]; &#125; CFAbsoluteTime end = CFAbsoluteTimeGetCurrent(); NSLog(@"22222 === ip === %@ === time cost: %0.3fs", ips,end - start); 使用gethostbyname方法后会得到一个struct,也就是上文的struct hostent *hptr：struct hostent &#123; char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses from name server */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define h_addr h_addr_list[0] /* address, for backward compatibility */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */&#125;; 参数解析： hostent-&gt;h_name表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。 hostent-&gt;h_aliases表示的是主机的别名www.baidu.com的别名就是他自己。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。 hostent-&gt;h_addrtype表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6) hostent-&gt;h_length表示的是主机ip地址的长度 hostent-&gt;h_addr_lisst表示的是主机的ip地址，注意，这个是以网络字节序存储的。不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt)，来把它转成char。详细使用见上文 缺点： 在进行网络切换的时候小概率卡死，自测十次有一两次左右。 在本地的LocalDns被破坏的时候会必卡死30秒，然后返回nil 。 缓存是个玄学东西，他会对自己解析出来的IP进行缓存（可能是运营商缓存）缓存时间不确定，有可能我即使切换了无数个网络，但是从早到晚同一个域名总是解析出同样的IP， 网上说的比较多的问题 方式二除了经常用到的gethostbyname(3)和gethostbyaddr(3)函数以外, Linux(以及其它UNIX/UNIX-like系统)还提供了一套用于在底层处理DNS相关问题的函数(这里所说的底层仅是相对gethostbyname和gethostbyaddr两个函数而言). 这套函数被称为地址解析函数(resolver functions)。曾经尝试过这个方式…int res_query __P((const char *, int, int, u_char *, int));函数原型为：int res_query(const char *dname, int class, int type, unsigned char *answer, int anslen) 这个方式需要在项目中添加libresolv.tbd库，因为要依赖于库中的函数去解析。res_query用来发出一个指定类(由参数class指定)和类型(由参数type指定)的DNS询问. dname是要查询的主机名. 返回信息被存储在answser指向的内存区域中. 信息的长度不能大于anslen个字节. 这个函数会创建一个DNS查询报文并把它发送到指定的DNS服务器。 使用方式CFAbsoluteTime start = CFAbsoluteTimeGetCurrent(); unsigned char auResult[512]; int nBytesRead = 0; nBytesRead = res_query("www.meitu.com", ns_c_in, ns_t_a, auResult, sizeof(auResult)); ns_msg handle; ns_initparse(auResult, nBytesRead, &amp;handle); NSMutableArray *ipList = nil; int msg_count = ns_msg_count(handle, ns_s_an); if (msg_count &gt; 0) &#123; ipList = [[NSMutableArray alloc] initWithCapacity:msg_count]; for(int rrnum = 0; rrnum &lt; msg_count; rrnum++) &#123; ns_rr rr; if(ns_parserr(&amp;handle, ns_s_an, rrnum, &amp;rr) == 0) &#123; char ip1[16]; strcpy(ip1, inet_ntoa(*(struct in_addr *)ns_rr_rdata(rr))); NSString *ipString = [[NSString alloc] initWithCString:ip1 encoding:NSASCIIStringEncoding]; if (![ipString isEqualToString:@""]) &#123; //将提取到的IP地址放到数组中 [ipList addObject:ipString]; &#125; &#125; &#125; CFAbsoluteTime end = CFAbsoluteTimeGetCurrent(); NSLog(@"11111 === ip === %@ === time cost: %0.3fs", ipList,end - start); &#125; 参数解析由于该逻辑是Linux底层提供的代码，苹果用宏做了一次封装，具体的函数含义还需要对Linux内核的理解，这里放一篇参考资料 优点： 在LocalDns被破坏掉的情况下能及时响应不会延迟。 没有缓存，缓存由开发者控制缺点 在进行网络切换时候3G/4G切wify高概率出现卡死这一个缺点是比较致命的，所以没有再继续使用。 方式三苹果原生的DNS解析 Boolean CFHostStartInfoResolution (CFHostRef theHost, CFHostInfoType info, CFStreamError *error); 使用方法：Boolean result,bResolved;CFHostRef hostRef;CFArrayRef addresses = NULL;NSMutableArray * ipsArr = [[NSMutableArray alloc] init];CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, "www.meitu.com", kCFStringEncodingASCII);hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);if (result == TRUE) &#123; addresses = CFHostGetAddressing(hostRef, &amp;result);&#125;bResolved = result == TRUE ? true : false;if(bResolved)&#123; struct sockaddr_in* remoteAddr; for(int i = 0; i &lt; CFArrayGetCount(addresses); i++) &#123; CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i); remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData); if(remoteAddr != NULL) &#123; //获取IP地址 char ip[16]; strcpy(ip, inet_ntoa(remoteAddr-&gt;sin_addr)); NSString * ipStr = [NSString stringWithCString:ip encoding:NSUTF8StringEncoding]; [ipsArr addObject:ipStr]; &#125; &#125;&#125;CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();NSLog(@"33333 === ip === %@ === time cost: %0.3fs", ipsArr,end - start);CFRelease(hostNameRef);CFRelease(hostRef); 参数解析：/* * CFHostStartInfoResolution() * * Discussion: * Performs a lookup for the given host. It will search for the * requested information if there is no other active request. * Previously cached information of the given type will be released. * * Mac OS X threading: * Thread safe * * Parameters: * * theHost: //需要被解决的CFHostRef的对象 * The CFHostRef which should be resolved. Must be non-NULL. If * this reference is not a valid CFHostRef, the behavior is * undefined. * * info: 返回值的类型 数组/Data/string.. * The enum representing the type of information to be retrieved. * If the value is not a valid type, the behavior is undefined. * * error: 错误 * A reference to a CFStreamError structure which will be filled * with any error information should an error occur. May be set * to NULL if error information is not wanted. * * Result: 解析结果成功还是失败 * Returns TRUE on success and FALSE on failure. In asynchronous * mode, this function will return immediately. In synchronous * mode, it will block until the resolve has completed or until the * resolve is cancelled. * */CFN_EXPORT __nullable CFArrayRefCFHostGetAddressing(CFHostRef theHost, Boolean * __nullable hasBeenResolved) CF_AVAILABLE(10_3, 2_0); 优点： 在网络切换时候不会卡顿。缺点： 在本地DNS被破坏的情况下会出现卡死的现象(卡30s)总结：以上三个方法除了第二个方法会在网络切换时候卡死不可用之外，其他两个方法都是可选择的，关于那个本地LocalDns破坏会卡死的问题看来是无法避免，不过开发者可以自行通过ping等方式来判断LocalDns的正确性，在被破坏的情况下使用httpDns来进行解析即可。具体的demo可以到这里查看]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>DNS解析</tag>
        <tag>LocalDNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome To My Site]]></title>
    <url>%2F2018%2F01%2F19%2Ftest-source%2F</url>
    <content type="text"><![CDATA[var options = {"narrow":false,"autoplay":true,"showlrc":0,"mutex":true,"music":[{"title":"见字如面","author":"唐甜甜","url":" https://molier-1256056152.cos.ap-guangzhou.myqcloud.com/%E5%94%90%E7%94%9C%E7%94%9C%20-%20%E8%A7%81%E5%AD%97%E5%A6%82%E9%9D%A2.mp3","pic":"https://y.gtimg.cn/music/photo_new/T002R300x300M000004a1Pzy39RQWd.jpg?max_age=2592000","lrc":"https://歌词.lrc"}]}; options.element = document.getElementById("aplayer0"); new APlayer(options); Todayyou’ll view the world differently welcome !!!]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>欢迎页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算的简单理解😊]]></title>
    <url>%2F2018%2F01%2F19%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%F0%9F%98%8A%2F</url>
    <content type="text"><![CDATA[1：背景从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。 我们每一种语言最终都会通过编译器转换成机器语言来执行，所以直接使用底层的语言就不需要便编译器的转换工作从而得到更高的执行效率，当然可读性可能会降低，这也是为什么汇编在大部分情况下有更快的速度。项目中合理的运用位运算能提高我们代码的执行效率。 在iOS系统中位运算多见于枚举中，其他地方很少见，因为位运算是底层的计算机语言，而在iOS开发中不管是Objective—C还是Swift都属于高级的编程语言，大量的位运算都被苹果封装了起来，我们只关心调用的接口不用关心内部的实现。 typedef NS_OPTIONS(NSUInteger, NSLayoutFormatOptions) &#123; NSLayoutFormatAlignAllLeft = (1 &lt;&lt; NSLayoutAttributeLeft), NSLayoutFormatAlignAllRight = (1 &lt;&lt; NSLayoutAttributeRight), NSLayoutFormatAlignAllTop = (1 &lt;&lt; NSLayoutAttributeTop), NSLayoutFormatAlignAllBottom = (1 &lt;&lt; NSLayoutAttributeBottom), NSLayoutFormatAlignAllLeading = (1 &lt;&lt; NSLayoutAttributeLeading), NSLayoutFormatAlignAllTrailing = (1 &lt;&lt; NSLayoutAttributeTrailing),.... &#125; 10：计算机计算原理加法和乘法举一个简单的例子来看下CPU是如何进行计算的，比如这行代码 int a = 35;int b = 47;int c = a + b; 计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加 35: 0 0 1 0 0 0 1 147: 0 0 1 0 1 1 1 1————————————————————82: 0 1 0 1 0 0 1 0 再来看下乘法，执行如下的代码 int a = 3;int b = 2;int c = a * b;3: 0 0 0 0 0 0 1 1 * 2————————————————————6: 0 0 0 0 0 1 1 0*********************************************int a = 3;int b = 4;int c = a * b;3: 0 0 0 0 0 0 1 1 * 4————————————————————12: 0 0 0 0 1 1 0 0*********************************************int a = 3;int b = 8;int c = a * b;3: 0 0 0 0 0 0 1 1 * 8————————————————————24: 0 0 0 1 1 0 0 0 通过以上运算可以看出当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位，放到代码中 我们可以这样来写 a &lt;&lt; N,所以上面3 2、3 4、3 * 8其实是可以写成3&lt;&lt;1、3&lt;&lt;2、3&lt;&lt;3，运算结果都是一样的。 那假如相乘的两个数都不满足2^N怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足2^N的数相加的情况，打个比方 int a = 15; int a = 15int b = 13; =&gt; int b = (4 + 8 + 1)int c = a * b; int c = a * b 最后其实执行相乘运算就会变成这样 15 4 + 15 8 + 15 * 1，按照上文说的移位来转换为位运算就会变成15 &lt;&lt; 2 + 15 &lt;&lt; 3 + 15 &lt;&lt; 0 减法和除法减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作(因为正数的源码补码反码都与本身相同)。首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成string的形式，这也是为什么浮点运算会消耗大量的时钟周期(操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz频率的CPU可以在一秒执行运算3.010241024*1024个时钟周期) 11：位运算符使用的运算符包括下面： 含义 运算符 例子 左移 &lt;&lt; 0011 =&gt; 0110 右移 &gt;&gt; 0110 =&gt; 0011 按位或 ︳ 0011 ——- =&gt; 10111011 按位与 &amp; 0011 ——- =&gt; 10111011 按位取反 ~ 0011 =&gt; 1100 按位异或 (相同为零不同为一) ^ 0011 ——- =&gt; 10001011 100：颜色转换背景上面说了iOS中经常见到的位运算的地方是在枚举中，那么颜色转换应该是除了枚举之外第二比较常用位运算的场景。打个比方设计师再给我们出设计稿的时候通常会在设计稿上按照16进制的样子给我们标色值。但是iOS中的UIColor并不支持使用十六进制的数据来初始化。所以我们需要将十六进制的色值转换为UIColor。 原理分析UIColor中通常是用传入RGB的数值来初始化，而且每个颜色的取值范围是十进制下的0~255，而设计同学又给的是十六进制数据，所以在操作系统中需要把这两种进制的数据统一成二进制来进行计算，这就用到了位运算。这里用一个十六进制的色值来举例子比如0xffa131我们要转换就要先理解其组成 0x或者0X：十六进制的标识符，表示这个后面是个十六进制的数值，对数值本身没有任何意义 ff 颜色中的R值,转换为二进制为 1111 1111 a1 颜色中的G值,转换为二进制为 1010 0001 31 颜色中的B值,转换为二进制为 0011 0001 上述色彩值转换为二进制后为1111 1111 1010 0001 0011 0001(每一位十六进制的对应4位二进制，如果位数不够记得高位补零) 通常来讲十六进制的颜色是按照上面的RGB的顺序排列的，但是并不固定，有时候可能会在其中加A(Alpha)值，具体情况按照设计为准，本文以通用情况举例。 综上，我们只需把对应位的值转换为10进制然后/255.0f就可得到RGB色彩值，从而转换为UIColor 转换代码先列出代码，后续解析 - (UIColor *)colorWithHex:(long)hexColor alpha:(float)opacity&#123; //将传入的十六进制颜色0xffa131 转换为UIColor float red = ((hexColor &amp; 0xFF0000) &gt;&gt; 16)/255.0f; float green = ((hexColor &amp; 0xFF00) &gt;&gt; 8)/255.0f; float blue = (hexColor &amp; 0xFF)/255.0f; return [UIColor colorWithRed:red green:green blue:blue alpha:opacity];&#125; 大概原理可以看出将RGB每个值都解析出来然后变成UIColor，先拿第一步转换红色值来说，我们按照运算顺序一步步来讲(默认将参数代入，用0xffa131代替hexColor) 0xffa131 &amp; 0xFF0000 我们知道红色值是前两位也就是ff，所以这一步我们既然要取出红色值就要把其他位全部置零来排除干扰，这步操作便是如此，在计算机系统内是二进制来实现的，即： 1111 1111 1010 0001 0011 0001——————————————- =&gt; &amp; =&gt; 1111 1111 0000 0000 0000 1111 1111 0000 0000 0000 0000这部操作做完后可以看出将除了R值之外的G值B值全部置零了，但是离最终结果还差点，因为0xFF是1111 1111，而我们的结果后面多出了16个0，所以便有了第二步操作 &gt;&gt; 16 将上一步得到的结果右移16位即得到0000 0000 0000 0000 1111 1111高位的零可以忽略，这也是最终的结果 / 255.0f 这一步应该都知道UIColor中传入的数值范围在0~1，所以我们要做下转换 后续的G值和B值都是一样的，只是大家注意位数就可以了，值得注意的是两个二进制数进行位运算一定保证两个数的位数相同，位数不够的那个数高位要用0补齐 101：枚举关于枚举中使用位运算我们之前也讲过，下面我们自己来写一个枚举(伪代码) typedef NS_OPTIONS(NSUInteger, TestOptions) &#123; TestOptionOne = 1 &lt;&lt; 0, （000001) TestOptionTwo = 1 &lt;&lt; 1, (000010) TestOptionThree = 1 &lt;&lt; 2, (000100) TestOptionFour = 1 &lt;&lt; 3, (001000) TestOptionFive = 1 &lt;&lt; 4, (010000) TestOptionSix = 1 &lt;&lt; 5, (100000).... 解析上面的枚举我后面用括号表明了位移后对应的二进制的值。这样写枚举的好处是我可以对其中选项多选比如TestOptionOne | TestOptionTwo （000001 | 000010 =&gt; 000011） 或者有其他的自定义组合。 110：加密在iOS中我们可以利用异或来进行加解密，异或的特性如下A ^ B = C =&gt; C ^ A = B =&gt; C ^ B = A 上文我们可以把A认为是需要加密的数据，B认为是密钥 C是加密后的数据比如: #include &lt;stdio.h&gt;main()&#123; char a[]="MyPassword"; /*要加密的密码*/ char b[]="cryptographic"; /*密钥*/ int i; /*加密代码*/ for(i=0;a[i]!='\0';i++)a[i]=a[i]^b[i]; printf("You Password encrypted: %s\n",a); /*解密代码*/ for(i=0;a[i]!='\0';i++)a[i]=a[i]^b[i]; printf("You Password: %s\n",a);&#125; 111：其他应用 记得iOS总有一道面试题在不使用第三个变量的情况下交换两个变量的值，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如下位运算操作 void exchange(int x , int y)&#123; x ^= y; y ^= x; x ^= y;&#125; 判断一个数的奇偶性，其实我们可以用%2来判断，代码量不高，但是之前讲过，除法运算的时钟周期非常多，所以代码虽然不多并不代表效率高，我们可以用如下运算来完成: void test(int x)&#123; if (x&amp;1) &#123; printf("奇数"); &#125; else &#123; printf("偶数"); &#125;&#125; 原理很简单，因为二进制是满二进一，一旦超过1就会变0并进一位，这时候和00001做&amp;操作一定会为0，反之不为零。这样写效率会更高。 计算两个数的平均值，通常我们都是（x+y）/2,先不考虑效率问题，这样还会引起一个其他的问题，那就是x+y的值很有可能溢出大于INT_MAX，所以我们采用位运算的办法来解决即可： int average(int x, int y)&#123; return (x&amp;y)+((x^y)&gt;&gt;1);&#125; 1000：总结其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
